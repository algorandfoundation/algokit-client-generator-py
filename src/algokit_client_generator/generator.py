import dataclasses
from collections.abc import Iterable, Sequence
from typing import Literal

from algokit_utils import ApplicationSpecification, OnCompleteActionName

from algokit_client_generator import utils
from algokit_client_generator.document import DocumentParts, Part
from algokit_client_generator.spec import ABIContractMethod, ContractMethod, get_contract_methods

ESCAPED_QUOTE = r"\""


@dataclasses.dataclass(kw_only=True)
class GenerationSettings:
    indent: str = "    "
    max_line_length: int = 80

    @property
    def indent_length(self) -> int:
        return len(self.indent)


class GenerateContext:
    def __init__(self, app_spec: ApplicationSpecification):
        self.app_spec = app_spec
        # TODO: track these as they are emitted?
        self.used_module_symbols = {
            "_APP_SPEC_JSON",
            "APP_SPEC",
            "_T",
            "_TArgs",
            "_TResult",
            "_ArgsBase",
            "_TypedDeployCreateArgs",
            "_TypedDeployArgs",
            "_as_dict",
            "_convert_on_complete",
            "_convert_deploy_args",
            "GlobalState",
            "LocalState",
        }
        self.used_client_symbols = {
            "__init__",
            "app_spec",
            "app_client",
            "no_op",
            "create",
            "update",
            "delete",
            "opt_in",
            "close_out",
            "clear_state",
            "deploy",
            "get_global_state",
            "get_local_state",
        }
        self.client_name = utils.get_unique_symbol_by_incrementing(
            self.used_module_symbols, utils.get_class_name(f"{self.app_spec.contract.name}_client")
        )
        self.methods = get_contract_methods(app_spec, self.used_module_symbols, self.used_client_symbols)
        self.disable_linting = True
        self.settings = GenerationSettings()


def generated_comment(context: GenerateContext) -> DocumentParts:
    yield "# This file was automatically generated by algokit-client-generator."
    yield "# DO NOT MODIFY IT BY HAND."


def disable_linting(context: GenerateContext) -> DocumentParts:
    yield "# flake8: noqa"  # this works for flake8 and ruff
    yield "# fmt: off"  # disable formatting
    yield '# mypy: disable-error-code="no-any-return, no-untyped-call"'  # disable common type warnings


def imports(context: GenerateContext) -> DocumentParts:
    yield utils.lines(
        """import base64
import dataclasses
import typing
from abc import ABC, abstractmethod

import algokit_utils
import algosdk
from algosdk.atomic_transaction_composer import TransactionSigner, TransactionWithSigner"""
    )


def typed_argument_class(abi: ABIContractMethod) -> DocumentParts:
    assert abi
    yield "@dataclasses.dataclass(kw_only=True)"
    yield f"class {abi.args_class_name}(_ArgsBase[{abi.python_type}]):"
    yield Part.IncIndent
    if abi.method.desc:
        yield utils.docstring(abi.method.desc)
        yield Part.Gap1
    if abi.args:
        for arg in abi.args:
            yield Part.InlineMode
            yield f"{arg.name}: {arg.python_type}"
            if arg.has_default:
                yield " | None = None"
            yield Part.RestoreLineMode
            if arg.desc:
                yield utils.docstring(arg.desc)
        yield Part.Gap1
    yield "@staticmethod"
    yield "def method() -> str:"
    yield Part.IncIndent
    yield Part.InlineMode
    yield "return "
    yield utils.string_literal(abi.method.get_signature())
    yield Part.DecIndent
    yield Part.DecIndent
    yield Part.RestoreLineMode


def helpers(context: GenerateContext) -> DocumentParts:
    yield '_T = typing.TypeVar("_T")'
    has_abi_create = any(m.abi for m in context.methods.create)
    has_abi_update = any(m.abi for m in context.methods.update_application)
    has_abi_delete = any(m.abi for m in context.methods.delete_application)
    if context.methods.has_abi_methods:
        yield '_TReturn = typing.TypeVar("_TReturn")'
        yield Part.Gap2
        yield utils.indented(
            """
class _ArgsBase(ABC, typing.Generic[_TReturn]):
    @staticmethod
    @abstractmethod
    def method() -> str:
        ..."""
        )
    yield Part.Gap2
    if has_abi_create or has_abi_update or has_abi_delete:
        yield '_TArgs = typing.TypeVar("_TArgs", bound=_ArgsBase)'
        yield Part.Gap2
    if has_abi_create:
        yield utils.indented(
            """
@dataclasses.dataclass(kw_only=True)
class _TypedDeployCreateArgs(algokit_utils.DeployCreateCallArgs, typing.Generic[_TArgs]):
    args: _TArgs
"""
        )
        yield Part.Gap2
    if has_abi_update or has_abi_delete:
        yield utils.indented(
            """
@dataclasses.dataclass(kw_only=True)
class _TypedDeployArgs(algokit_utils.DeployCallArgs, typing.Generic[_TArgs]):
    args: _TArgs"""
        )
        yield Part.Gap2

    yield Part.Gap2
    yield utils.indented(
        """
def _as_dict(data: _T | None) -> dict[str, typing.Any]:
    if data is None:
        return {}
    if not dataclasses.is_dataclass(data):
        raise TypeError(f"{data} must be a dataclass")
    return {f.name: getattr(data, f.name) for f in dataclasses.fields(data)}
"""
    )
    yield Part.Gap2
    yield utils.indented(
        """
def _convert_on_complete(on_complete: algokit_utils.OnCompleteActionName) -> algosdk.transaction.OnComplete:
    on_complete_enum = on_complete.replace("_", " ").title().replace(" ", "") + "OC"
    return getattr(algosdk.transaction.OnComplete, on_complete_enum)"""
    )
    yield Part.Gap2
    yield utils.indented(
        """
def _convert_deploy_args(
    deploy_args: algokit_utils.DeployCallArgs | None,
) -> dict[str, typing.Any] | None:
    if deploy_args is None:
        return None

    deploy_args_dict = _as_dict(deploy_args)
    if hasattr(deploy_args, "args") and hasattr(deploy_args.args, "method"):
        deploy_args_dict["args"] = _as_dict(deploy_args.args)
        deploy_args_dict["method"] = deploy_args.args.method()

    return deploy_args_dict"""
    )
    yield Part.Gap2


def typed_arguments(context: GenerateContext) -> DocumentParts:
    # typed args classes
    processed_abi_signatures: set[str] = set()
    for method in context.methods.all_abi_methods:
        abi = method.abi
        assert abi
        abi_signature = abi.method.get_signature()
        if abi_signature in processed_abi_signatures:
            continue
        processed_abi_signatures.add(abi_signature)
        yield typed_argument_class(abi)
        yield Part.Gap2

    # typed deploy args
    for method in context.methods.create:
        if not method.abi:
            continue
        yield f"{method.abi.deploy_create_args_class_name} = _TypedDeployCreateArgs[{method.abi.args_class_name}]"

    processed_abi_signatures.clear()
    for method in (m for m in context.methods.update_application + context.methods.delete_application if m.abi):
        abi = method.abi
        assert abi
        abi_signature = abi.method.get_signature()
        if abi_signature in processed_abi_signatures:
            continue
        processed_abi_signatures.add(abi_signature)
        yield f"{abi.deploy_args_class_name} = _TypedDeployArgs[{abi.args_class_name}]"

    yield Part.Gap2


def state_type(context: GenerateContext, class_name: str, schema: dict[str, dict]) -> DocumentParts:
    if not schema:
        return

    yield f"class {class_name}:"
    yield Part.IncIndent
    yield "def __init__(self, data: dict[bytes, bytes | int]):"
    yield Part.IncIndent
    for field, value in schema.items():
        key = value["key"]
        if value["type"] == "bytes":
            yield f'self.{field} = ByteReader(typing.cast(bytes, data.get(b"{key}")))'
        else:
            yield f'self.{field} = typing.cast(int, data.get(b"{key}"))'
        desc = value["descr"]
        if desc:
            yield utils.docstring(desc)
    yield Part.DecIndent
    yield Part.DecIndent
    yield Part.Gap2


def state_types(context: GenerateContext) -> DocumentParts:
    app_spec = context.app_spec
    global_schema = app_spec.schema.get("global", {}).get("declared", {})
    local_schema = app_spec.schema.get("local", {}).get("declared", {})
    has_bytes = any(i.get("type") == "bytes" for i in [*global_schema.values(), *local_schema.values()])
    if has_bytes:
        yield utils.indented(
            """
class ByteReader:
    def __init__(self, data: bytes):
        self._data = data

    @property
    def as_bytes(self) -> bytes:
        return self._data

    @property
    def as_str(self) -> str:
        return self._data.decode("utf8")

    @property
    def as_base64(self) -> str:
        return base64.b64encode(self._data).decode("utf8")

    @property
    def as_hex(self) -> str:
        return self._data.hex()"""
        )
        yield Part.Gap2
    yield state_type(context, "GlobalState", global_schema)
    yield state_type(context, "LocalState", local_schema)


def typed_client(context: GenerateContext) -> DocumentParts:
    yield utils.indented(
        f"""
class {context.client_name}:
    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
    ):
        ...

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
    ):
        ...

    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account | None = None,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
    ):
        self.app_spec = APP_SPEC

        # calling full __init__ signature, so ignoring mypy warning about overloads
        self.app_client = algokit_utils.ApplicationClient(  # type: ignore[call-overload, misc]
            algod_client=algod_client,
            app_spec=self.app_spec,
            app_id=app_id,
            creator=creator,
            indexer_client=indexer_client,
            existing_deployments=existing_deployments,
            signer=signer,
            sender=sender,
            suggested_params=suggested_params,
            template_values=template_values,
        )"""
    )
    yield Part.Gap1
    yield Part.IncIndent
    yield get_global_state_method(context)
    yield Part.Gap1
    yield get_local_state_method(context)
    yield Part.Gap1
    yield call_methods(context)
    yield Part.Gap1
    yield special_method(context, "create", context.methods.create)
    yield Part.Gap1
    yield special_method(context, "update", context.methods.update_application)
    yield Part.Gap1
    yield special_method(context, "delete", context.methods.delete_application)
    yield Part.Gap1
    yield special_method(context, "opt_in", context.methods.opt_in)
    yield Part.Gap1
    yield special_method(context, "close_out", context.methods.close_out)
    yield Part.Gap1
    yield clear_method(context)
    yield Part.Gap1
    yield deploy_method(context)


def embed_app_spec(context: GenerateContext) -> DocumentParts:
    yield Part.InlineMode
    yield '_APP_SPEC_JSON = r"""'
    yield context.app_spec.to_json()
    yield '"""'
    yield Part.RestoreLineMode
    yield "APP_SPEC = algokit_utils.ApplicationSpecification.from_json(_APP_SPEC_JSON)"


def call_method(context: GenerateContext, contract_method: ABIContractMethod) -> DocumentParts:
    yield f"def {contract_method.client_method_name}("
    yield Part.IncIndent
    yield "self,"
    yield "*,"
    for arg in contract_method.args:
        yield Part.InlineMode
        yield f"{arg.name}: {arg.python_type}"
        if arg.has_default:
            yield " | None = None"
        yield ","
        yield Part.RestoreLineMode
    yield "transaction_parameters: algokit_utils.TransactionParameters | None = None,"
    yield Part.DecIndent
    yield f") -> algokit_utils.ABITransactionResponse[{contract_method.python_type}]:"
    yield Part.IncIndent
    # TODO: yield doc

    if not contract_method.args:
        yield f"args = {contract_method.args_class_name}()"
    else:
        yield f"args = {contract_method.args_class_name}(", Part.IncIndent
        for arg in contract_method.args:
            yield f"{arg.name}={arg.name},"
        yield Part.DecIndent, ")"

    yield utils.indented(
        """
return self.app_client.call(
    call_abi_method=args.method(),
    transaction_parameters=_as_dict(transaction_parameters),
    **_as_dict(args),
)"""
    )
    yield Part.DecIndent


def call_methods(context: GenerateContext) -> DocumentParts:
    for method in context.methods.no_op:
        if method.abi:
            yield call_method(context, method.abi)
        else:
            yield utils.indented(
                """
def no_op(
    self,
    transaction_parameters: algokit_utils.TransactionParameters | None = None
) -> algokit_utils.TransactionResponse:
    return self.app_client.call(
        call_abi_method=False,
        transaction_parameters=_as_dict(transaction_parameters),
    )"""
            )
        yield Part.Gap1


def signature(
    context: GenerateContext, name: str, args: "Sequence[str | DocumentParts]", return_types: list[str]
) -> DocumentParts:
    yield f"def {name}("
    yield Part.IncIndent
    for arg in args:
        yield Part.InlineMode
        if isinstance(arg, str):
            yield arg
        else:
            yield arg
        yield ","
        yield Part.RestoreLineMode

    return_signature = f") -> {' | '.join(return_types)}:"

    if context.settings.indent_length + len(return_signature) < context.settings.max_line_length:
        yield Part.DecIndent, return_signature
    else:
        yield Part.DecIndent, ") -> ("
        yield Part.IncIndent
        for idx, return_type in enumerate(return_types):
            yield Part.InlineMode
            if idx:
                yield "| "
            yield return_type
            yield Part.RestoreLineMode
        yield Part.DecIndent, "):"


def on_complete_literals(on_completes: Iterable[OnCompleteActionName]) -> DocumentParts:
    yield Part.InlineMode
    yield 'on_complete: typing.Literal["'
    yield utils.join('", "', on_completes)
    yield '"]'
    if "no_op" in on_completes:
        yield ' = "no_op"'
    yield Part.RestoreLineMode


def multi_typed_arg(arg_name: str, arg_types: list[str], *, include_none_default: bool) -> DocumentParts:
    yield Part.InlineMode
    yield f"{arg_name}: "
    yield utils.join(" | ", arg_types)
    if include_none_default:
        yield " = None"
    yield Part.RestoreLineMode


def special_typed_args(methods: list[ContractMethod]) -> DocumentParts:
    has_bare = any(not m.abi for m in methods)
    args = [m.abi.args_class_name for m in methods if m.abi]
    if has_bare:
        args.append("None")
    yield multi_typed_arg("args", args, include_none_default=has_bare)


def special_overload(
    context: GenerateContext,
    method_name: Literal["create", "update", "delete", "opt_in", "close_out"],
    method: ContractMethod,
) -> DocumentParts:
    yield "@typing.overload"
    args: list[str | DocumentParts] = ["self", "*"]

    if method.abi:
        args.append(f"args: {method.abi.args_class_name}")
        return_type = f"algokit_utils.ABITransactionResponse[{method.abi.python_type}]"
    else:
        args.append("args: typing.Literal[None] = None")
        return_type = "algokit_utils.TransactionResponse"
    if method_name == "create":
        args.append(on_complete_literals(method.on_complete))
        args.append("transaction_parameters: algokit_utils.CreateTransactionParameters | None = None")
    else:
        args.append("transaction_parameters: algokit_utils.TransactionParameters | None = None")
    yield signature(context, method_name, args, [return_type])
    yield Part.IncIndent, "...", Part.DecIndent


def special_method(
    context: GenerateContext,
    method_name: Literal["create", "update", "delete", "opt_in", "close_out"],
    methods: list[ContractMethod],
) -> DocumentParts:
    if not methods:
        return
    is_create = method_name == "create"
    has_bare = any(not m.abi for m in methods)
    bare_only = all(not m.abi for m in methods)
    # typed overloads
    if len(methods) > 1:
        for method in methods:
            yield special_overload(context, method_name, method)
            yield Part.Gap1

    # signature
    args: list[str | DocumentParts] = ["self", "*"]
    if not bare_only:
        args.append(special_typed_args(methods))
    if is_create:
        args.append(on_complete_literals(sorted({c for m in methods for c in m.on_complete})))
        args.append("transaction_parameters: algokit_utils.CreateTransactionParameters | None = None")
    else:
        args.append("transaction_parameters: algokit_utils.TransactionParameters | None = None")

    return_types = []
    if has_bare:
        return_types.append("algokit_utils.TransactionResponse")

    return_types.extend(sorted(f"algokit_utils.ABITransactionResponse[{m.abi.python_type}]" for m in methods if m.abi))
    yield signature(context, method_name, args, return_types)

    # implementation
    yield Part.IncIndent

    yield f"return self.app_client.{method_name}("
    yield Part.IncIndent
    if bare_only:
        yield "call_abi_method=False,"
    else:
        yield "call_abi_method=args.method() if args else False,"
    if is_create:
        yield (
            "transaction_parameters=_as_dict(transaction_parameters) | "
            '{"on_complete": _convert_on_complete(on_complete)},'
        )
    else:
        yield "transaction_parameters=_as_dict(transaction_parameters),"
    if not bare_only:
        yield "**_as_dict(args),"
    yield Part.DecIndent
    yield ")"
    yield Part.DecIndent


def clear_method(context: GenerateContext) -> DocumentParts:
    yield utils.indented(
        """
def clear_state(
    self,
    transaction_parameters: algokit_utils.TransactionParameters | None = None,
    app_args: list[bytes] | None = None,
) -> algokit_utils.TransactionResponse:
    return self.app_client.clear_state(_as_dict(transaction_parameters), app_args)"""
    )


def deploy_method_args(context: GenerateContext, arg_name: str, methods: list[ContractMethod]) -> DocumentParts:
    yield Part.InlineMode
    has_bare = any(not m.abi for m in methods) or not methods
    args = [
        m.abi.deploy_create_args_class_name if m.call_config == "create" else m.abi.deploy_args_class_name
        for m in methods
        if m.abi
    ]
    if has_bare:
        args.append("algokit_utils.DeployCallArgs")
        args.append("None")
    yield multi_typed_arg(arg_name, args, include_none_default=has_bare)
    yield ","
    yield Part.RestoreLineMode


def deploy_method(context: GenerateContext) -> DocumentParts:
    yield utils.indented(
        """
def deploy(
    self,
    version: str | None = None,
    *,
    signer: TransactionSigner | None = None,
    sender: str | None = None,
    allow_update: bool | None = None,
    allow_delete: bool | None = None,
    on_update: algokit_utils.OnUpdate = algokit_utils.OnUpdate.Fail,
    on_schema_break: algokit_utils.OnSchemaBreak = algokit_utils.OnSchemaBreak.Fail,
    template_values: algokit_utils.TemplateValueMapping | None = None,"""
    )
    yield Part.IncIndent
    yield deploy_method_args(context, "create_args", context.methods.create)
    yield deploy_method_args(context, "update_args", context.methods.update_application)
    yield deploy_method_args(context, "delete_args", context.methods.delete_application)
    yield Part.DecIndent
    yield utils.indented(
        """
) -> algokit_utils.DeployResponse:
    return self.app_client.deploy(
        version,
        signer=signer,
        sender=sender,
        allow_update=allow_update,
        allow_delete=allow_delete,
        on_update=on_update,
        on_schema_break=on_schema_break,
        template_values=template_values,
        create_args=_convert_deploy_args(create_args),
        update_args=_convert_deploy_args(update_args),
        delete_args=_convert_deploy_args(delete_args),
    )"""
    )


def get_global_state_method(context: GenerateContext) -> DocumentParts:
    if not context.app_spec.schema.get("global", {}).get("declared", {}):
        return
    yield "def get_global_state(self) -> GlobalState:"
    yield Part.IncIndent
    # TODO: what if the key can't be decoded to utf8
    yield "state = self.app_client.get_global_state(raw=True)"
    yield "return GlobalState(state)"
    yield Part.DecIndent


def get_local_state_method(context: GenerateContext) -> DocumentParts:
    if not context.app_spec.schema.get("local", {}).get("declared", {}):
        return
    yield "def get_local_state(self, account: str | None = None) -> LocalState:"
    yield Part.IncIndent
    # TODO: what if the key can't be decoded to utf8
    yield "state = self.app_client.get_local_state(account, raw=True)"
    yield "return LocalState(state)"
    yield Part.DecIndent


def generate(context: GenerateContext) -> DocumentParts:
    if context.disable_linting:
        yield disable_linting(context)
    yield generated_comment(context)
    yield imports(context)
    yield Part.Gap1
    yield embed_app_spec(context)
    yield helpers(context)
    yield Part.Gap2
    yield typed_arguments(context)
    yield Part.Gap2
    yield state_types(context)
    yield Part.Gap2
    yield typed_client(context)
