# flake8: noqa
# fmt: off
# mypy: disable-error-code="no-any-return, no-untyped-call, misc, type-arg"
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [4, 56], "bareActions": {"call": [], "create": []}, "methods": [{"actions": {"call": [], "create": ["NoOp"]}, "args": [{"type": "string", "name": "nfdName"}, {"type": "address", "name": "seller"}, {"type": "address", "name": "buyer"}, {"type": "uint64", "name": "purchaseAmount"}, {"type": "uint64", "name": "expTime"}, {"type": "address", "name": "commission1Addr"}, {"type": "uint64", "name": "commission1Pct"}, {"type": "address", "name": "commission2Addr"}, {"type": "uint64", "name": "commission2Pct"}, {"type": "uint64", "name": "segmentRootAppId"}, {"type": "address", "name": "segmentRootCommissionAddr"}], "name": "createApplication", "returns": {"type": "void"}}, {"actions": {"call": ["UpdateApplication"], "create": []}, "args": [{"type": "string", "name": "versionNum"}], "name": "updateApplication", "returns": {"type": "void"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "gas", "returns": {"type": "void"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "name": "nfdName"}, {"type": "string", "name": "url"}], "name": "mintAsa", "returns": {"type": "void"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "byte[][]", "name": "fieldNames"}], "name": "deleteFields", "returns": {"type": "void"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "name": "childNfdName"}, {"type": "uint64", "name": "childNfdAppID"}], "name": "updateSegmentCount", "returns": {"type": "void"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "byte[][]", "name": "fieldAndVals"}], "name": "getFieldUpdateCost", "returns": {"type": "uint64"}, "readonly": true}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "byte[][]", "name": "fieldAndVals"}], "name": "updateFields", "returns": {"type": "void"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "byte[]", "name": "fieldName"}], "name": "readField", "returns": {"type": "byte[]"}, "readonly": true}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "sellAmount"}, {"type": "address", "name": "reservedFor"}], "name": "offerForSale", "returns": {"type": "void"}, "events": [{"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}, {"type": "address", "name": "seller"}, {"type": "uint64", "name": "amount"}, {"type": "address", "name": "reservedFor"}], "name": "nfd_offerForSale", "desc": ""}]}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "cancelSale", "returns": {"type": "void"}, "events": [{"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}], "name": "nfd_saleCancelled", "desc": ""}]}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "offer"}, {"type": "string", "name": "note"}], "name": "postOffer", "returns": {"type": "void"}, "events": [{"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}, {"type": "address", "name": "sender"}, {"type": "uint64", "name": "amount"}, {"type": "string", "name": "note"}], "name": "nfd_postedOffer", "desc": ""}]}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "oneYearPrice"}, {"type": "uint64", "name": "segmentPlatformCostInAlgo"}], "name": "mintPayout", "returns": {"type": "(uint64,address,uint64,address,uint64)", "struct": "PayoutInfo"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "pay", "name": "payment"}], "name": "purchase", "returns": {"type": "void"}, "events": [{"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}, {"type": "address", "name": "seller"}, {"type": "address", "name": "buyer"}, {"type": "uint64", "name": "sellAmount"}, {"type": "uint64", "name": "offerAmount"}, {"type": "uint64", "name": "overpaymentRefund"}, {"type": "address", "name": "convFeeAddr"}, {"type": "uint64", "name": "convFeeAmount"}], "name": "nfd_purchased", "desc": ""}]}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "name": "fieldName"}, {"type": "address", "name": "address"}], "name": "isAddressInField", "returns": {"type": "bool"}, "readonly": true}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "getRenewPrice", "returns": {"type": "uint64"}, "readonly": true}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "byte[]", "name": "hash"}], "name": "updateHash", "returns": {"type": "void"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "bool", "name": "lock"}], "name": "contractLock", "returns": {"type": "void"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "bool", "name": "lock"}, {"type": "uint64", "name": "usdPrice"}], "name": "segmentLock", "returns": {"type": "void"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "bool", "name": "lock"}], "name": "vaultOptInLock", "returns": {"type": "void"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64[]", "name": "assets"}], "name": "vaultOptIn", "returns": {"type": "void"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "amount"}, {"type": "address", "name": "receiver"}, {"type": "string", "name": "note"}, {"type": "uint64", "name": "asset"}, {"type": "uint64[]", "name": "otherAssets"}], "name": "vaultSend", "returns": {"type": "void"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "pay", "desc": "The payment transaction from which the renewal period is determined..", "name": "payment"}], "name": "renew", "returns": {"type": "void"}, "desc": "Renew adds more time to an existing NFDs expiration, or renews it if expired.\n\n\nAs part of v2-v3 upgrade, the NFDs are converted from lifetime NFDs to renewal NFDs. The v2 contract is upgraded\nto v3, then renew is called on the (now v3) nfd to turn it into a renewal (note the if curExpiration === 0 check)\n\n\nIf already renewal, then it extends the current expiration time by the time specified (minimum 1 yr) (365 / price paid * mint price)\nExpirations can never be more than NFD_MAX_EXPIRATION_DAYS days in the future.\n\n\nIF the NFD is expired:\n    x The current owner can take it back over at base price - and NFD metadata doesn't have to be cleared - they\n    get it back as-is.\n    x If not current owner, then the price goes from high of base price * 10,000 down to base price over 24 hrs where\n    'buyer' has to pay at least that price.  The NFD MUST ALREADY HAVE ITS METADATA CLEARED!", "events": [{"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}], "name": "nfd_saleCancelled", "desc": ""}, {"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}, {"type": "address", "name": "origOwner"}, {"type": "address", "name": "buyer"}, {"type": "uint64", "name": "priceOneYear"}, {"type": "uint64", "name": "renewAmount"}, {"type": "uint64", "name": "expTime"}], "name": "nfd_renewed", "desc": ""}]}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "name": "fieldName"}, {"type": "address", "name": "address"}], "name": "setPrimaryAddress", "returns": {"type": "void"}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "- MUST START with u.cav. (!)\ngets 'added' to 'set' in next arg - must be fixed-sized bytes", "name": "fieldBeingVerified"}, {"type": "string", "desc": "(must BE v.ca[...].as)", "name": "fieldSetName"}], "name": "registryAddingVerifiedAddress", "returns": {"type": "bool", "desc": "true if added or already present, false otherwise"}, "desc": "Approved call from registry instructing us to move the specified u.cav.xx field and add to the specified\nverified field.", "events": [{"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}, {"type": "address", "name": "address"}], "name": "nfd_addressLinked", "desc": ""}]}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "The field being changed in the address registry.", "name": "fieldBeingChanged"}, {"type": "address", "desc": "The address to be removed from the field.", "name": "address"}, {"type": "address", "desc": "the address to send reclaimed MBR (if any)\n boolean - true if valid removed", "name": "mbrRefundDest"}], "name": "registryRemovingVerifiedAddress", "returns": {"type": "bool"}, "desc": "Approved call from registry instructing us to REMOVE an address from the specified verified address set", "events": [{"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}, {"type": "address", "name": "address"}], "name": "nfd_addressUnlinked", "desc": ""}]}], "name": "NFDInstance", "state": {"keys": {"box": {}, "global": {}, "local": {}}, "maps": {"box": {"boxes": {"keyType": "AVMBytes", "valueType": "AVMBytes"}}, "global": {"globalState": {"keyType": "AVMBytes", "valueType": "AVMBytes"}}, "local": {}}, "schema": {"global": {"bytes": 30, "ints": 0}, "local": {"bytes": 0, "ints": 0}}}, "structs": {"PayoutInfo": [{"name": "amountToSeller", "type": "uint64"}, {"name": "commissionAddress", "type": "address"}, {"name": "amountToCommission", "type": "uint64"}, {"name": "segmentRootOwner", "type": "address"}, {"name": "amountToSegmentRoot", "type": "uint64"}]}, "desc": "", "events": [{"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}, {"type": "address", "name": "seller"}, {"type": "uint64", "name": "amount"}, {"type": "address", "name": "reservedFor"}], "name": "nfd_offerForSale", "desc": ""}, {"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}], "name": "nfd_saleCancelled", "desc": ""}, {"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}, {"type": "address", "name": "sender"}, {"type": "uint64", "name": "amount"}, {"type": "string", "name": "note"}], "name": "nfd_postedOffer", "desc": ""}, {"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}, {"type": "address", "name": "seller"}, {"type": "address", "name": "buyer"}, {"type": "uint64", "name": "sellAmount"}, {"type": "uint64", "name": "offerAmount"}, {"type": "uint64", "name": "overpaymentRefund"}, {"type": "address", "name": "convFeeAddr"}, {"type": "uint64", "name": "convFeeAmount"}], "name": "nfd_purchased", "desc": ""}, {"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}, {"type": "address", "name": "origOwner"}, {"type": "address", "name": "buyer"}, {"type": "uint64", "name": "priceOneYear"}, {"type": "uint64", "name": "renewAmount"}, {"type": "uint64", "name": "expTime"}], "name": "nfd_renewed", "desc": ""}, {"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}, {"type": "address", "name": "address"}], "name": "nfd_addressLinked", "desc": ""}, {"args": [{"type": "uint64", "name": "appId"}, {"type": "string", "name": "name"}, {"type": "address", "name": "address"}], "name": "nfd_addressUnlinked", "desc": ""}], "scratchVariables": {"adminAsaId": {"slot": 200, "type": "uint64"}, "registryAppId": {"slot": 201, "type": "uint64"}}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAwIDEgMiAzMiBUTVBMX3JlZ2lzdHJ5QXBwSWQgOCAzIDYgMzY1IDQwMCA0IDEwIDI1MDAgNSA4NjQwMCAxMDAwMDAwIDEwMF8wMDAgNTAwIDEwMDAgMjAwIFRNUExfYWRtaW5Bc2FJZApieXRlY2Jsb2NrIDB4ICJpLm93bmVyLmEiICJpLnRpbWVDaGFuZ2VkIiAiaS5taW50aW5nIiAiaS5uYW1lIiAiaS5jb21taXNzaW9uMUFnZW50LmEiICJpLnNlbGxhbXQiICJpLmNvbW1pc3Npb24xIiAiaS5yZXNlcnZlZE93bmVyLmEiICJpLnNlZ21lbnRBZ2VudC5hIiAiaS5zZWxsZXIuYSIgMHgxNTFmN2M3NSAiaS5taW50aW5nS2lja29mZkNyZWF0b3IuYSIgImkubWludGluZ0tpY2tvZmZBbW91bnQiIDB4MGE4MTAxIDB4MzEgImkuY29tbWlzc2lvbjJBZ2VudC5hIiAiaS5leHBpcmF0aW9uVGltZSIgImkuYXNhaWQiICIxIiAiaS52YXVsdE9wdEluTG9ja2VkIiAiaS5zZWdtZW50TG9ja2VkIiAiaS5jb21taXNzaW9uMiIgMHgzMCAiMCIgImkuY29udHJhY3RMb2NrZWQiICJpLmhpZ2hlc3RTb2xkQW10IiAiaS5wYXJlbnRBcHBJRCIgMHgyZSAweDAwICIyIiAweDYyNmY3ODUyNjU2Njc1NmU2NCAiaS5zZWdtZW50UHJpY2VVc2QiIDB4NzYyZTYzNjE0MTZjNjc2ZiAiaS50aW1lUHVyY2hhc2VkIiAiaS5zZWdtZW50Q291bnQiIDB4NDM2NWVkOTAgMHg3MDNiOGNlNyAweDc2MmU2MzYxIDB4MmU2MTczICJpLnZlciIgMHgwMDBhIDB4MDAyYQoKLy8gVGhpcyBURUFMIHdhcyBnZW5lcmF0ZWQgYnkgVEVBTFNjcmlwdCB2MC4xMDUuNQovLyBodHRwczovL2dpdGh1Yi5jb20vYWxnb3JhbmRmb3VuZGF0aW9uL1RFQUxTY3JpcHQKCi8vICEhISEgV0FSTklORzogVGhpcyBjb250cmFjdCBpcyAqTk9UKiBBUkM0IGNvbXBsaWFudC4gSXQgbWF5IGNvbnRhaW4gQUJJIG1ldGhvZHMsIGJ1dCBpdCBhbHNvIGFsbG93cyBhcHAgY2FsbHMgd2hlcmUgdGhlIGZpcnN0IGFyZ3VtZW50IGRvZXMgTk9UIG1hdGNoIGFuIEFCSSBzZWxlY3RvcgoKLy8gVGhlIGZvbGxvd2luZyB0ZW4gbGluZXMgb2YgVEVBTCBoYW5kbGUgaW5pdGlhbCBwcm9ncmFtIGZsb3cKLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgdG8gbWFrZSBpdCBlYXN5IGZvciBhbnlvbmUgdG8gcGFyc2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGFuZCBkZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyBhY3Rpb24gaXMgYWxsb3dlZAovLyBIZXJlLCBhY3Rpb24gcmVmZXJzIHRvIHRoZSBPbkNvbXBsZXRlIGluIGNvbWJpbmF0aW9uIHdpdGggd2hldGhlciB0aGUgYXBwIGlzIGJlaW5nIGNyZWF0ZWQgb3IgY2FsbGVkCi8vIEV2ZXJ5IHBvc3NpYmxlIGFjdGlvbiBmb3IgdGhpcyBjb250cmFjdCBpcyByZXByZXNlbnRlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudAovLyBJZiB0aGUgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgY29udHJhY3QsIGl0cyByZXNwZWN0aXZlIGJyYW5jaCB3aWxsIGJlICIqTk9UX0lNUExFTUVOVEVEIiB3aGljaCBqdXN0IGNvbnRhaW5zICJlcnIiCnR4biBBcHBsaWNhdGlvbklECiEKaW50YyA3IC8vIDYKKgp0eG4gT25Db21wbGV0aW9uCisKc3dpdGNoICpjYWxsX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKmNhbGxfVXBkYXRlQXBwbGljYXRpb24gKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJLy8gVGhlIHJlcXVlc3RlZCBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgY29udHJhY3QuIEFyZSB5b3UgdXNpbmcgdGhlIGNvcnJlY3QgT25Db21wbGV0ZT8gRGlkIHlvdSBzZXQgeW91ciBhcHAgSUQ/CgllcnIKCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKHN0cmluZyxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CgkvLyBzZWdtZW50Um9vdENvbW1pc3Npb25BZGRyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxMQoJZHVwCglsZW4KCWludGMgMyAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChzZWdtZW50Um9vdENvbW1pc3Npb25BZGRyKSBmb3IgY3JlYXRlQXBwbGljYXRpb24gbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIHNlZ21lbnRSb290QXBwSWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMTAKCWJ0b2kKCgkvLyBjb21taXNzaW9uMlBjdDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA5CglidG9pCgoJLy8gY29tbWlzc2lvbjJBZGRyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA4CglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDMgKGNvbW1pc3Npb24yQWRkcikgZm9yIGNyZWF0ZUFwcGxpY2F0aW9uIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBjb21taXNzaW9uMVBjdDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA3CglidG9pCgoJLy8gY29tbWlzc2lvbjFBZGRyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA2CglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDUgKGNvbW1pc3Npb24xQWRkcikgZm9yIGNyZWF0ZUFwcGxpY2F0aW9uIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleHBUaW1lOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWJ0b2kKCgkvLyBwdXJjaGFzZUFtb3VudDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglidG9pCgoJLy8gYnV5ZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWR1cAoJbGVuCglpbnRjIDMgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgOCAoYnV5ZXIpIGZvciBjcmVhdGVBcHBsaWNhdGlvbiBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gc2VsbGVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDkgKHNlbGxlcikgZm9yIGNyZWF0ZUFwcGxpY2F0aW9uIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBuZmROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBjcmVhdGVBcHBsaWNhdGlvbihzdHJpbmcsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBjcmVhdGVBcHBsaWNhdGlvbgoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gY3JlYXRlQXBwbGljYXRpb24obmZkTmFtZTogc3RyaW5nLCBzZWxsZXI6IEFkZHJlc3MsIGJ1eWVyOiBBZGRyZXNzLCBwdXJjaGFzZUFtb3VudDogdWludDY0LCBleHBUaW1lOiB1aW50NjQsIGNvbW1pc3Npb24xQWRkcjogQWRkcmVzcywgY29tbWlzc2lvbjFQY3Q6IHVpbnQ2NCwgY29tbWlzc2lvbjJBZGRyOiBBZGRyZXNzLCBjb21taXNzaW9uMlBjdDogdWludDY0LCBzZWdtZW50Um9vdEFwcElkOiB1aW50NjQsIHNlZ21lbnRSb290Q29tbWlzc2lvbkFkZHI6IEFkZHJlc3MpOiB2b2lkCmNyZWF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMTEgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDUKCS8vIGFzc2VydChnbG9iYWxzLmNhbGxlckFwcGxpY2F0aW9uSUQgPT09IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKSwgJ2NhbGxlciBtdXN0IGJlIE5GRCByZWdpc3RyeSEnKQoJZ2xvYmFsIENhbGxlckFwcGxpY2F0aW9uSUQKCWludGMgNCAvLyBUTVBMX3JlZ2lzdHJ5QXBwSWQKCT09CgoJLy8gY2FsbGVyIG11c3QgYmUgTkZEIHJlZ2lzdHJ5IQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDYKCS8vIGFzc2VydChwdXJjaGFzZUFtb3VudCA+IDApCglmcmFtZV9kaWcgLTQgLy8gcHVyY2hhc2VBbW91bnQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT4KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ4CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfSVNMT0NLRUQpLnZhbHVlID0gTkZEX0xPQ0tFRF9WQUxfRkFMU0UKCWJ5dGVjIDI1IC8vICJpLmNvbnRyYWN0TG9ja2VkIgoJYnl0ZWMgMjQgLy8gIjAiCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ5CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVkVSU0lPTikudmFsdWUgPSBORkRfQ1VSUkVOVF9WRVJTSU9OCglieXRlYyA0MCAvLyAiaS52ZXIiCglwdXNoYnl0ZXMgIjMuOCIKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTAKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HKS52YWx1ZSA9IE5GRF9NSU5USU5HX1NUQVRFX1BSRUFTQQoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJYnl0ZWMgMTkgLy8gIjEiCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjUxCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNSRUFURUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCXB1c2hieXRlcyAiaS50aW1lQ3JlYXRlZCIKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTIKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9USU1FQ0hBTkdFRCkudmFsdWUgPSBpdG9iKGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wKQoJYnl0ZWMgMiAvLyAiaS50aW1lQ2hhbmdlZCIKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTMKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9USU1FUFVSQ0hBU0VEKS52YWx1ZSA9IGl0b2IoZ2xvYmFscy5sYXRlc3RUaW1lc3RhbXApCglieXRlYyAzNCAvLyAiaS50aW1lUHVyY2hhc2VkIgoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJaXRvYgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1NAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0lTU0VHTUVOVExPQ0tFRCkudmFsdWUgPSBORkRfTE9DS0VEX1ZBTF9UUlVFCglieXRlYyAyMSAvLyAiaS5zZWdtZW50TG9ja2VkIgoJYnl0ZWMgMTkgLy8gIjEiCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU1CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTkFNRSkudmFsdWUgPSBuZmROYW1lCglieXRlYyA0IC8vICJpLm5hbWUiCglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogc3RyaW5nCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU2CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlID0gcmF3Qnl0ZXMoYnV5ZXIpCglieXRlYyAxIC8vICJpLm93bmVyLmEiCglmcmFtZV9kaWcgLTMgLy8gYnV5ZXI6IEFkZHJlc3MKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTcKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUxMRVIpLnZhbHVlID0gcmF3Qnl0ZXMoc2VsbGVyKQoJYnl0ZWMgMTAgLy8gImkuc2VsbGVyLmEiCglmcmFtZV9kaWcgLTIgLy8gc2VsbGVyOiBBZGRyZXNzCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU4CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfU0VMTF9BTU9VTlQpLnZhbHVlID0gaXRvYihwdXJjaGFzZUFtb3VudCkKCWJ5dGVjIDYgLy8gImkuc2VsbGFtdCIKCWZyYW1lX2RpZyAtNCAvLyBwdXJjaGFzZUFtb3VudDogdWludDY0CglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1OQoJLy8gY29tbWlzc2lvbjFBZGRyICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzCglmcmFtZV9kaWcgLTYgLy8gY29tbWlzc2lvbjFBZGRyOiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9CglieiAqaWYwX2VuZAoKCS8vICppZjBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjAKCS8vIGFzc2VydChjb21taXNzaW9uMVBjdCA+PSAxICYmIGNvbW1pc3Npb24xUGN0IDw9IDUwMCwgJ2NvbW1pc3Npb24gbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDUwJScpCglmcmFtZV9kaWcgLTcgLy8gY29tbWlzc2lvbjFQY3Q6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCT49CglkdXAKCWJ6ICpza2lwX2FuZDAKCWZyYW1lX2RpZyAtNyAvLyBjb21taXNzaW9uMVBjdDogdWludDY0CglpbnRjIDE3IC8vIDUwMAoJPD0KCSYmCgoqc2tpcF9hbmQwOgoJLy8gY29tbWlzc2lvbiBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNTAlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xX0FHRU5UKS52YWx1ZSA9IHJhd0J5dGVzKGNvbW1pc3Npb24xQWRkcikKCWJ5dGVjIDUgLy8gImkuY29tbWlzc2lvbjFBZ2VudC5hIgoJZnJhbWVfZGlnIC02IC8vIGNvbW1pc3Npb24xQWRkcjogQWRkcmVzcwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MgoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xKS52YWx1ZSA9IGl0b2IoY29tbWlzc2lvbjFQY3QpCglieXRlYyA3IC8vICJpLmNvbW1pc3Npb24xIgoJZnJhbWVfZGlnIC03IC8vIGNvbW1pc3Npb24xUGN0OiB1aW50NjQKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gKmlmMV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjYzCgkvLyBjb21taXNzaW9uMkFkZHIgIT09IGdsb2JhbHMuemVyb0FkZHJlc3MKCWZyYW1lX2RpZyAtOCAvLyBjb21taXNzaW9uMkFkZHI6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCWJ6ICppZjFfZW5kCgoJLy8gKmlmMV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NAoJLy8gYXNzZXJ0KGNvbW1pc3Npb24yUGN0ID49IDEgJiYgY29tbWlzc2lvbjJQY3QgPD0gNTAwLCAnY29tbWlzc2lvbiBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNTAlJykKCWZyYW1lX2RpZyAtOSAvLyBjb21taXNzaW9uMlBjdDogdWludDY0CglpbnRjIDEgLy8gMQoJPj0KCWR1cAoJYnogKnNraXBfYW5kMQoJZnJhbWVfZGlnIC05IC8vIGNvbW1pc3Npb24yUGN0OiB1aW50NjQKCWludGMgMTcgLy8gNTAwCgk8PQoJJiYKCipza2lwX2FuZDE6CgkvLyBjb21taXNzaW9uIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA1MCUKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjY1CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQ09NTUlTU0lPTjJfQUdFTlQpLnZhbHVlID0gcmF3Qnl0ZXMoY29tbWlzc2lvbjJBZGRyKQoJYnl0ZWMgMTYgLy8gImkuY29tbWlzc2lvbjJBZ2VudC5hIgoJZnJhbWVfZGlnIC04IC8vIGNvbW1pc3Npb24yQWRkcjogQWRkcmVzcwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NgoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04yKS52YWx1ZSA9IGl0b2IoY29tbWlzc2lvbjJQY3QpCglieXRlYyAyMiAvLyAiaS5jb21taXNzaW9uMiIKCWZyYW1lX2RpZyAtOSAvLyBjb21taXNzaW9uMlBjdDogdWludDY0CglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKKmlmMV9lbmQ6CgoqaWYwX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjY5CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQ0FURUdPUlkpLnZhbHVlID0gJ2NvbW1vbicKCXB1c2hieXRlcyAiaS5jYXRlZ29yeSIKCXB1c2hieXRlcyAweDYzNmY2ZDZkNmY2ZSAvLyAiY29tbW9uIgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1NBTEVUWVBFKS52YWx1ZSA9ICdidXlJdE5vdycKCXB1c2hieXRlcyAiaS5zYWxlVHlwZSIKCXB1c2hieXRlcyAweDYyNzU3OTQ5NzQ0ZTZmNzcgLy8gImJ1eUl0Tm93IgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MgoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0VYUElSQVRJT05USU1FKS52YWx1ZSA9IGl0b2IoZXhwVGltZSkKCWJ5dGVjIDE3IC8vICJpLmV4cGlyYXRpb25UaW1lIgoJZnJhbWVfZGlnIC01IC8vIGV4cFRpbWU6IHVpbnQ2NAoJaXRvYgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3NQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0lTVkFVTFRPUFRJTkxPQ0tFRCkudmFsdWUgPSBORkRfTE9DS0VEX1ZBTF9GQUxTRQoJYnl0ZWMgMjAgLy8gImkudmF1bHRPcHRJbkxvY2tlZCIKCWJ5dGVjIDI0IC8vICIwIgoJYXBwX2dsb2JhbF9wdXQKCgkvLyAqaWYyX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NzcKCS8vIHNlZ21lbnRSb290QXBwSWQgIT09IDAKCWZyYW1lX2RpZyAtMTAgLy8gc2VnbWVudFJvb3RBcHBJZDogdWludDY0CglpbnRjIDAgLy8gMAoJIT0KCWJ6ICppZjJfZW5kCgoJLy8gKmlmMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3OAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1BBUkVOVF9JRCkudmFsdWUgPSBpdG9iKHNlZ21lbnRSb290QXBwSWQpCglieXRlYyAyNyAvLyAiaS5wYXJlbnRBcHBJRCIKCWZyYW1lX2RpZyAtMTAgLy8gc2VnbWVudFJvb3RBcHBJZDogdWludDY0CglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgxCgkvLyBwYXJlbnROYW1lID0gdGhpcy5zYWZlR2xvYmFsQnl0ZUdldEV4KHNlZ21lbnRSb290QXBwSWQsIE5GRF9LRVlfTkFNRSkKCWJ5dGVjIDQgLy8gImkubmFtZSIKCWZyYW1lX2RpZyAtMTAgLy8gc2VnbWVudFJvb3RBcHBJZDogdWludDY0CgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0RXgKCWZyYW1lX2J1cnkgMCAvLyBwYXJlbnROYW1lOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NAoJLy8gYXNzZXJ0KGV4dHJhY3QzKG5mZE5hbWUsIGxlbihuZmROYW1lKSAtIGxlbihwYXJlbnROYW1lKSAtIDEsIGxlbihwYXJlbnROYW1lKSArIDEpID09PSAnLicgKyBwYXJlbnROYW1lKQoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJbGVuCglmcmFtZV9kaWcgMCAvLyBwYXJlbnROYW1lOiBieXRlW10KCWxlbgoJLQoJaW50YyAxIC8vIDEKCS0KCWZyYW1lX2RpZyAwIC8vIHBhcmVudE5hbWU6IGJ5dGVbXQoJbGVuCglpbnRjIDEgLy8gMQoJKwoJZXh0cmFjdDMKCWJ5dGVjIDI4IC8vICAiLiIKCWZyYW1lX2RpZyAwIC8vIHBhcmVudE5hbWU6IGJ5dGVbXQoJY29uY2F0Cgk9PQoJYXNzZXJ0CgoJLy8gKmlmM19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjg4CgkvLyB0aGlzLnNhZmVHbG9iYWxCeXRlR2V0RXgoc2VnbWVudFJvb3RBcHBJZCwgTkZEX0tFWV9JU1NFR01FTlRMT0NLRUQpID09PSBORkRfTE9DS0VEX1ZBTF9GQUxTRQoJYnl0ZWMgMjEgLy8gImkuc2VnbWVudExvY2tlZCIKCWZyYW1lX2RpZyAtMTAgLy8gc2VnbWVudFJvb3RBcHBJZDogdWludDY0CgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0RXgKCWJ5dGVjIDI0IC8vICIwIgoJPT0KCWJ6ICppZjNfZW5kCgoJLy8gKmlmM19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5MAoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgICAgICBzZWdtZW50Um9vdENvbW1pc3Npb25BZGRyICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzLAoJLy8gICAgICAgICAgICAgICAgICAgICAncGFyZW50IGNvbW1pc3Npb24gYWRkcmVzcyBtdXN0IGJlIHNldCBpZiBwYXJlbnQgYXBwIGlkIGlzIHNldCBhbmQgcGFyZW50IGlzIHVubG9ja2VkJywKCS8vICAgICAgICAgICAgICAgICApCglmcmFtZV9kaWcgLTExIC8vIHNlZ21lbnRSb290Q29tbWlzc2lvbkFkZHI6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCgkvLyBwYXJlbnQgY29tbWlzc2lvbiBhZGRyZXNzIG11c3QgYmUgc2V0IGlmIHBhcmVudCBhcHAgaWQgaXMgc2V0IGFuZCBwYXJlbnQgaXMgdW5sb2NrZWQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk3CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2FmZUdsb2JhbEJ5dGVHZXRFeChzZWdtZW50Um9vdEFwcElkLCBORkRfS0VZX1NFTExFUikgPT09IHJhd0J5dGVzKHNlZ21lbnRSb290Q29tbWlzc2lvbkFkZHIpLAoJLy8gICAgICAgICAgICAgICAgICAgICAidGhlIHNlZ21lbnQgY29tbWlzc2lvbiBhZ2VudCBzaG91bGQgYmUgdGhlIHBhcmVudCBuZmQncyBzZWxsZXIiLAoJLy8gICAgICAgICAgICAgICAgICkKCWJ5dGVjIDEwIC8vICJpLnNlbGxlci5hIgoJZnJhbWVfZGlnIC0xMCAvLyBzZWdtZW50Um9vdEFwcElkOiB1aW50NjQKCWNhbGxzdWIgc2FmZUdsb2JhbEJ5dGVHZXRFeAoJZnJhbWVfZGlnIC0xMSAvLyBzZWdtZW50Um9vdENvbW1pc3Npb25BZGRyOiBBZGRyZXNzCgk9PQoKCS8vIHRoZSBzZWdtZW50IGNvbW1pc3Npb24gYWdlbnQgc2hvdWxkIGJlIHRoZSBwYXJlbnQgbmZkJ3Mgc2VsbGVyCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDEKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUdNRU5UX0NPTU1JU1NJT05fQUdFTlQpLnZhbHVlID0gcmF3Qnl0ZXMoc2VnbWVudFJvb3RDb21taXNzaW9uQWRkcikKCWJ5dGVjIDkgLy8gImkuc2VnbWVudEFnZW50LmEiCglmcmFtZV9kaWcgLTExIC8vIHNlZ21lbnRSb290Q29tbWlzc2lvbkFkZHI6IEFkZHJlc3MKCWFwcF9nbG9iYWxfcHV0CgoqaWYzX2VuZDoKCippZjJfZW5kOgoJcmV0c3ViCgovLyB1cGRhdGVBcHBsaWNhdGlvbihzdHJpbmcpdm9pZAoqYWJpX3JvdXRlX3VwZGF0ZUFwcGxpY2F0aW9uOgoJLy8gdmVyc2lvbk51bTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgdXBkYXRlQXBwbGljYXRpb24oc3RyaW5nKXZvaWQKCWNhbGxzdWIgdXBkYXRlQXBwbGljYXRpb24KCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHVwZGF0ZUFwcGxpY2F0aW9uKHZlcnNpb25OdW06IHN0cmluZyk6IHZvaWQKdXBkYXRlQXBwbGljYXRpb246Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTAKCS8vIGFzc2VydCh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfSVNMT0NLRUQpLnZhbHVlICE9PSBORkRfTE9DS0VEX1ZBTF9UUlVFLCAnY29udHJhY3QgbXVzdCBiZSB1bmxvY2tlZCB0byB1cGdyYWRlJykKCWJ5dGVjIDI1IC8vICJpLmNvbnRyYWN0TG9ja2VkIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGVjIDE5IC8vICIxIgoJIT0KCgkvLyBjb250cmFjdCBtdXN0IGJlIHVubG9ja2VkIHRvIHVwZ3JhZGUKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExMwoJLy8gYXNzZXJ0KGdsb2JhbHMuY2FsbGVyQXBwbGljYXRpb25JRCA9PT0gQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnJlZ2lzdHJ5QXBwSWQpLCAnY2FsbGVyIG11c3QgYmUgTkZEIHJlZ2lzdHJ5IScpCglnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAoJaW50YyA0IC8vIFRNUExfcmVnaXN0cnlBcHBJZAoJPT0KCgkvLyBjYWxsZXIgbXVzdCBiZSBORkQgcmVnaXN0cnkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTQKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9WRVJTSU9OKS52YWx1ZSA9IHZlcnNpb25OdW0KCWJ5dGVjIDQwIC8vICJpLnZlciIKCWZyYW1lX2RpZyAtMSAvLyB2ZXJzaW9uTnVtOiBzdHJpbmcKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTE1CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyBvbkNhbGwoKTogdm9pZApvbkNhbGw6Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjAKCS8vIGFzc2VydCghdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX01JTlRJTkcpLmV4aXN0cywgImNhbid0IHN0aWxsIGJlIGluIG1pbnRpbmcgc3RhdGUiKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoKCS8vIGNhbid0IHN0aWxsIGJlIGluIG1pbnRpbmcgc3RhdGUKCWFzc2VydAoKCS8vICppZjRfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjEKCS8vIHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMF0gPT09ICdnYXMnCgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCXB1c2hieXRlcyAweDY3NjE3MyAvLyAiZ2FzIgoJPT0KCWJ6ICppZjRfZW5kCgoJLy8gKmlmNF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjEKCS8vIHJldHVybgoJcmV0c3ViCgoqaWY0X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNQoJLy8gYXNzZXJ0KCF0aGlzLmlzRXhwaXJlZCgpLCAiTkZEIGNhbid0IGJlIGV4cGlyZWQgZm9yIHRoZXNlIHYxL3YyIG9wZXJhdGlvbnMiKQoJY2FsbHN1YiBpc0V4cGlyZWQKCSEKCgkvLyBORkQgY2FuJ3QgYmUgZXhwaXJlZCBmb3IgdGhlc2UgdjEvdjIgb3BlcmF0aW9ucwoJYXNzZXJ0CgoJLy8gKmlmNV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNwoJLy8gdGhpcy50eG4ubnVtQXBwQXJncyA+PSAzICYmIHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMF0gPT09IE5GRF9DQUxMX1VQREFURV9GSUVMRAoJdHhuIE51bUFwcEFyZ3MKCWludGMgNiAvLyAzCgk+PQoJZHVwCglieiAqc2tpcF9hbmQyCgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCXB1c2hieXRlcyAidXBkYXRlX2ZpZWxkIgoJPT0KCSYmCgoqc2tpcF9hbmQyOgoJYnogKmlmNV9lbmQKCgkvLyAqaWY1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzMwoJLy8gdGhpcy51cGRhdGVGaWVsZHNGcm9tQXJncygpCgljYWxsc3ViIHVwZGF0ZUZpZWxkc0Zyb21BcmdzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM0CgkvLyByZXR1cm4KCXJldHN1YgoKKmlmNV9lbmQ6CgkvLyAqaWY2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM2CgkvLyB0aGlzLnR4bi5udW1BcHBBcmdzID49IDEgJiYgdGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVswXSA9PT0gTkZEX0NBTExfREVMRVRFX0ZJRUxECgl0eG4gTnVtQXBwQXJncwoJaW50YyAxIC8vIDEKCT49CglkdXAKCWJ6ICpza2lwX2FuZDMKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMAoJcHVzaGJ5dGVzICJkZWxldGVfZmllbGQiCgk9PQoJJiYKCipza2lwX2FuZDM6CglieiAqaWY2X2VuZAoKCS8vICppZjZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQxCgkvLyB0aGlzLmRlbGV0ZUZpZWxkc0Zyb21BcmdzKCkKCWNhbGxzdWIgZGVsZXRlRmllbGRzRnJvbUFyZ3MKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDIKCS8vIHJldHVybgoJcmV0c3ViCgoqaWY2X2VuZDoKCS8vICppZjdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDQKCS8vIHRoaXMudHhuLm51bUFwcEFyZ3MgPT09IDIgJiYgdGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVswXSA9PT0gTkZEX0NBTExfUkVBRF9QUk9QRVJUWQoJdHhuIE51bUFwcEFyZ3MKCWludGMgMiAvLyAyCgk9PQoJZHVwCglieiAqc2tpcF9hbmQ0Cgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCXB1c2hieXRlcyAicmVhZF9wcm9wZXJ0eSIKCT09CgkmJgoKKnNraXBfYW5kNDoKCWJ6ICppZjdfZW5kCgoJLy8gKmlmN19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDkKCS8vIGxvZyh0aGlzLnJlYWRGaWVsZCh0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzFdIGFzIGJ5dGVzKSkKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMQoJY2FsbHN1YiByZWFkRmllbGQKCWxvZwoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MAoJLy8gcmV0dXJuCglyZXRzdWIKCippZjdfZW5kOgoJLy8gKmlmOF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MwoJLy8gdGhpcy50eG4ubnVtQXBwQXJncyA9PT0gMiAmJiB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzBdID09PSBORkRfQ0FMTF9VUERBVEVfSEFTSAoJdHhuIE51bUFwcEFyZ3MKCWludGMgMiAvLyAyCgk9PQoJZHVwCglieiAqc2tpcF9hbmQ1Cgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCXB1c2hieXRlcyAidXBkYXRlX2hhc2giCgk9PQoJJiYKCipza2lwX2FuZDU6CglieiAqaWY4X2VuZAoKCS8vICppZjhfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0CgkvLyB0aGlzLnVwZGF0ZUhhc2godGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsxXSBhcyBieXRlcykKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMQoJY2FsbHN1YiB1cGRhdGVIYXNoCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU1CgkvLyByZXR1cm4KCXJldHN1YgoKKmlmOF9lbmQ6CgkvLyAqaWY5X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU5CgkvLyB0aGlzLnR4bi5udW1BcHBBcmdzID09PSAyICYmIHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMF0gPT09IE5GRF9DQUxMX0NPTlRSQUNUX0xPQ0sKCXR4biBOdW1BcHBBcmdzCglpbnRjIDIgLy8gMgoJPT0KCWR1cAoJYnogKnNraXBfYW5kNgoJdHhuIEFwcGxpY2F0aW9uQXJncyAwCglwdXNoYnl0ZXMgImNvbnRyYWN0X2xvY2siCgk9PQoJJiYKCipza2lwX2FuZDY6CglieiAqaWY5X2VuZAoKCS8vICppZjlfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTYwCgkvLyB0aGlzLmNvbnRyYWN0TG9jayh0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzFdID09PSAnMScpCgl0eG4gQXBwbGljYXRpb25BcmdzIDEKCWJ5dGVjIDE1IC8vICAiMSIKCT09CgljYWxsc3ViIGNvbnRyYWN0TG9jawoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE2MQoJLy8gcmV0dXJuCglyZXRzdWIKCippZjlfZW5kOgoJLy8gKmlmMTBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNjYKCS8vIHRoaXMudHhuLm51bUFwcEFyZ3MgPT09IDMgJiYgdGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVswXSA9PT0gTkZEX0NBTExfU0VHTUVOVF9MT0NLCgl0eG4gTnVtQXBwQXJncwoJaW50YyA2IC8vIDMKCT09CglkdXAKCWJ6ICpza2lwX2FuZDcKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMAoJcHVzaGJ5dGVzICJzZWdtZW50X2xvY2siCgk9PQoJJiYKCipza2lwX2FuZDc6CglieiAqaWYxMF9lbmQKCgkvLyAqaWYxMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNjcKCS8vIHRoaXMuc2VnbWVudExvY2sodGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsxXSA9PT0gJzEnLCBidG9pKHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMl0pKQoJdHhuIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgl0eG4gQXBwbGljYXRpb25BcmdzIDEKCWJ5dGVjIDE1IC8vICAiMSIKCT09CgljYWxsc3ViIHNlZ21lbnRMb2NrCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTY4CgkvLyByZXR1cm4KCXJldHN1YgoKKmlmMTBfZW5kOgoJLy8gKmlmMTFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNzUKCS8vIHRoaXMudHhuLm51bUFwcEFyZ3MgPj0gMiAmJiB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzBdID09PSBORkRfQ0FMTF9WQVVMVF9PUFRJTgoJdHhuIE51bUFwcEFyZ3MKCWludGMgMiAvLyAyCgk+PQoJZHVwCglieiAqc2tpcF9hbmQ4Cgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCXB1c2hieXRlcyAidmF1bHRfb3B0aW4iCgk9PQoJJiYKCipza2lwX2FuZDg6CglieiAqaWYxMV9lbmQKCgkvLyAqaWYxMV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNzYKCS8vIHRoaXMudmF1bHRPcHRJbkZyb21BcmdzKCkKCWNhbGxzdWIgdmF1bHRPcHRJbkZyb21BcmdzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTc3CgkvLyByZXR1cm4KCXJldHN1YgoKKmlmMTFfZW5kOgoJLy8gdW5rbm93biBtZXRob2QKCWVycgoJcmV0c3ViCgovLyBnYXMoKXZvaWQKKmFiaV9yb3V0ZV9nYXM6CgkvLyBleGVjdXRlIGdhcygpdm9pZAoJY2FsbHN1YiBnYXMKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdhcygpOiB2b2lkCmdhczoKCXByb3RvIDAgMAoJcmV0c3ViCgovLyBtaW50QXNhKHN0cmluZyxzdHJpbmcpdm9pZAoqYWJpX3JvdXRlX21pbnRBc2E6CgkvLyB1cmw6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZXh0cmFjdCAyIDAKCgkvLyBuZmROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBtaW50QXNhKHN0cmluZyxzdHJpbmcpdm9pZAoJY2FsbHN1YiBtaW50QXNhCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBtaW50QXNhKG5mZE5hbWU6IHN0cmluZywgdXJsOiBzdHJpbmcpOiB2b2lkCm1pbnRBc2E6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE5MAoJLy8gYXNzZXJ0KGdsb2JhbHMuY2FsbGVyQXBwbGljYXRpb25JRCA9PT0gQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnJlZ2lzdHJ5QXBwSWQpLCAnY2FsbGVyIG11c3QgYmUgTkZEIHJlZ2lzdHJ5IScpCglnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAoJaW50YyA0IC8vIFRNUExfcmVnaXN0cnlBcHBJZAoJPT0KCgkvLyBjYWxsZXIgbXVzdCBiZSBORkQgcmVnaXN0cnkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxOTEKCS8vIGFzc2VydCh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTUlOVElORykudmFsdWUgPT09IE5GRF9NSU5USU5HX1NUQVRFX1BSRUFTQSkKCWJ5dGVjIDMgLy8gImkubWludGluZyIKCWFwcF9nbG9iYWxfZ2V0CglieXRlYyAxOSAvLyAiMSIKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxOTMKCS8vIGFzc2V0ID0gc2VuZEFzc2V0Q3JlYXRpb24oewoJLy8gICAgICAgICAgICAgY29uZmlnQXNzZXRVbml0TmFtZTogJ05GRCcsCgkvLyAgICAgICAgICAgICBjb25maWdBc3NldE5hbWU6IG5mZE5hbWUsCgkvLyAgICAgICAgICAgICBjb25maWdBc3NldFRvdGFsOiAxLAoJLy8gICAgICAgICAgICAgY29uZmlnQXNzZXREZWNpbWFsczogMCwKCS8vICAgICAgICAgICAgIGNvbmZpZ0Fzc2V0RGVmYXVsdEZyb3plbjogMSwKCS8vICAgICAgICAgICAgIGNvbmZpZ0Fzc2V0VVJMOiB1cmwsCgkvLyAgICAgICAgICAgICBjb25maWdBc3NldE1hbmFnZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgICAgICBjb25maWdBc3NldFJlc2VydmU6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgICAgICBjb25maWdBc3NldENsYXdiYWNrOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyA2IC8vICBhY2ZnCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTk0CgkvLyBjb25maWdBc3NldFVuaXROYW1lOiAnTkZEJwoJcHVzaGJ5dGVzIDB4NGU0NjQ0IC8vICJORkQiCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VW5pdE5hbWUKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxOTUKCS8vIGNvbmZpZ0Fzc2V0TmFtZTogbmZkTmFtZQoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJaXR4bl9maWVsZCBDb25maWdBc3NldE5hbWUKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxOTYKCS8vIGNvbmZpZ0Fzc2V0VG90YWw6IDEKCWludGMgMSAvLyAxCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VG90YWwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxOTcKCS8vIGNvbmZpZ0Fzc2V0RGVjaW1hbHM6IDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVjaW1hbHMKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxOTgKCS8vIGNvbmZpZ0Fzc2V0RGVmYXVsdEZyb3plbjogMQoJaW50YyAxIC8vIDEKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXREZWZhdWx0RnJvemVuCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTk5CgkvLyBjb25maWdBc3NldFVSTDogdXJsCglmcmFtZV9kaWcgLTIgLy8gdXJsOiBzdHJpbmcKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRVUkwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMDAKCS8vIGNvbmZpZ0Fzc2V0TWFuYWdlcjogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRNYW5hZ2VyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjAxCgkvLyBjb25maWdBc3NldFJlc2VydmU6IHRoaXMuYXBwLmFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0UmVzZXJ2ZQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIwMgoJLy8gY29uZmlnQXNzZXRDbGF3YmFjazogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRDbGF3YmFjawoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gQ3JlYXRlZEFzc2V0SUQKCWZyYW1lX2J1cnkgMCAvLyBhc3NldDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjA0CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQVNBSUQpLnZhbHVlID0gaXRvYihhc3NldC5pZCkKCWJ5dGVjIDE4IC8vICJpLmFzYWlkIgoJZnJhbWVfZGlnIDAgLy8gYXNzZXQ6IHVpbnQ2NAoJaXRvYgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMDUKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HKS52YWx1ZSA9IE5GRF9NSU5USU5HX1NUQVRFX1BPU1RBU0EKCWJ5dGVjIDMgLy8gImkubWludGluZyIKCWJ5dGVjIDMwIC8vICIyIgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMDYKCS8vIGxvZyhpdG9iKGFzc2V0LmlkKSkKCWZyYW1lX2RpZyAwIC8vIGFzc2V0OiB1aW50NjQKCWl0b2IKCWxvZwoJcmV0c3ViCgovLyBkZWxldGVGaWVsZHMoYnl0ZVtdW10pdm9pZAoqYWJpX3JvdXRlX2RlbGV0ZUZpZWxkczoKCS8vIGZpZWxkTmFtZXM6IGJ5dGVbXVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCgoJLy8gZXhlY3V0ZSBkZWxldGVGaWVsZHMoYnl0ZVtdW10pdm9pZAoJY2FsbHN1YiBkZWxldGVGaWVsZHMKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGRlbGV0ZUZpZWxkcyhmaWVsZE5hbWVzOiBieXRlc1tdKTogdm9pZApkZWxldGVGaWVsZHM6Cglwcm90byAxIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiA0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjE0CgkvLyBhc3NlcnQoIXRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HKS5leGlzdHMpCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglieXRlYyAzIC8vICJpLm1pbnRpbmciCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMTUKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9USU1FQ0hBTkdFRCkudmFsdWUgPSBpdG9iKGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wKQoJYnl0ZWMgMiAvLyAiaS50aW1lQ2hhbmdlZCIKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjE3CgkvLyBhZG1pblJpZ2h0cyA9IHRoaXMuaXNDdXJyZW50VHhuQ29udHJhY3RBdXRob3JpdHkoKQoJY2FsbHN1YiBpc0N1cnJlbnRUeG5Db250cmFjdEF1dGhvcml0eQoJZnJhbWVfYnVyeSAwIC8vIGFkbWluUmlnaHRzOiBib29sCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjE4CgkvLyBib3hDb3N0cyA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDEgLy8gYm94Q29zdHM6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIxOQoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCipmb3JfMDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIxOQoJLy8gaSA8IGZpZWxkTmFtZXMubGVuZ3RoCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZE5hbWVzOiBieXRlc1tdCglpbnRjIDAgLy8gMAoJZXh0cmFjdF91aW50MTYKCTwKCWJ6ICpmb3JfMF9lbmQKCgkvLyAqaWYxMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIyMAoJLy8gZ2xvYmFscy5vcGNvZGVCdWRnZXQgPCAyMDAKCWdsb2JhbCBPcGNvZGVCdWRnZXQKCWludGMgMTkgLy8gMjAwCgk8CglieiAqaWYxMl9lbmQKCgkvLyAqaWYxMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMjEKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludGMgNyAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCglieXRlYyAxNCAvLyAgI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50YyAxMyAvLyAgRGVsZXRlQXBwbGljYXRpb24KCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMTJfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjIzCgkvLyBuYW1lID0gZmllbGROYW1lc1tpXQoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkTmFtZXM6IGJ5dGVzW10KCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDAgLy8gIGluaXRpYWwgb2Zmc2V0CglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgMiAvLyAyCgkqIC8vIGFjYyAqIDIKCSsKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJdW5jb3ZlciAyCglleHRyYWN0X3VpbnQxNgoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglkdXAgLy8gZHVwbGljYXRlIHN0YXJ0IG9mIGVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXN3YXAKCWV4dHJhY3RfdWludDE2IC8vIGdldCBudW1iZXIgb2YgZWxlbWVudHMKCWludGMgMSAvLyAgZ2V0IHR5cGUgbGVuZ3RoCgkqIC8vIG11bHRpcGx5IGJ5IHR5cGUgbGVuZ3RoCglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWV4dHJhY3QzCglleHRyYWN0IDIgMAoJZnJhbWVfYnVyeSAzIC8vIG5hbWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIyNAoJLy8gYXNzZXJ0KHRoaXMuaXNGaWVsZERlbGV0ZUFsbG93ZWQobmFtZSwgYWRtaW5SaWdodHMpLCAnZmllbGQgbm90IHJlbW92YWJsZSBvciBubyBwZXJtaXNzaW9ucyB0byByZW1vdmUnKQoJZnJhbWVfZGlnIDAgLy8gYWRtaW5SaWdodHM6IGJvb2wKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJY2FsbHN1YiBpc0ZpZWxkRGVsZXRlQWxsb3dlZAoKCS8vIGZpZWxkIG5vdCByZW1vdmFibGUgb3Igbm8gcGVybWlzc2lvbnMgdG8gcmVtb3ZlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMjUKCS8vIGJveFNpemUgPSB0aGlzLmJveGVzKG5hbWUpLnNpemUKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2xlbgoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5ib3hlcyhuYW1lKS5zaXplCglhc3NlcnQKCWZyYW1lX2J1cnkgNCAvLyBib3hTaXplOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMjYKCS8vIHRoaXMuYm94ZXMobmFtZSkuZGVsZXRlKCkKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIyNwoJLy8gYm94Q29zdHMgKz0gU0NCT1hfUEVSQk9YICsgKG5hbWUubGVuZ3RoICsgYm94U2l6ZSkgKiBTQ0JPWF9QRVJCWVRFCglmcmFtZV9kaWcgMSAvLyBib3hDb3N0czogdWludDY0CglpbnRjIDEyIC8vIDI1MDAKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJbGVuCglmcmFtZV9kaWcgNCAvLyBib3hTaXplOiB1aW50NjQKCSsKCWludGMgOSAvLyA0MDAKCSoKCSsKCSsKCWZyYW1lX2J1cnkgMSAvLyBib3hDb3N0czogdWludDY0CgoqZm9yXzBfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMTkKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzAKCipmb3JfMF9lbmQ6CgkvLyAqaWYxM19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIyOQoJLy8gYm94Q29zdHMgPiAwCglmcmFtZV9kaWcgMSAvLyBib3hDb3N0czogdWludDY0CglpbnRjIDAgLy8gMAoJPgoJYnogKmlmMTNfZW5kCgoJLy8gKmlmMTNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjMwCgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgICAgICAgICAgYW1vdW50OiBib3hDb3N0cywKCS8vICAgICAgICAgICAgICAgICByZWNlaXZlcjogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgICAgICAgICAgIG5vdGU6ICdib3hSZWZ1bmQnLAoJLy8gICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjMxCgkvLyBhbW91bnQ6IGJveENvc3RzCglmcmFtZV9kaWcgMSAvLyBib3hDb3N0czogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIzMgoJLy8gcmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlcgoJdHhuIFNlbmRlcgoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIzMwoJLy8gbm90ZTogJ2JveFJlZnVuZCcKCWJ5dGVjIDMxIC8vICAiYm94UmVmdW5kIgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMTNfZW5kOgoJcmV0c3ViCgovLyBkZWxldGVGaWVsZHNGcm9tQXJncygpOiB2b2lkCmRlbGV0ZUZpZWxkc0Zyb21BcmdzOgoJcHJvdG8gMCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gMgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIzOQoJLy8gYXNzZXJ0KCF0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTUlOVElORykuZXhpc3RzKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjQxCgkvLyBhZG1pblJpZ2h0cyA9IHRoaXMuaXNDdXJyZW50VHhuQ29udHJhY3RBdXRob3JpdHkoKQoJY2FsbHN1YiBpc0N1cnJlbnRUeG5Db250cmFjdEF1dGhvcml0eQoJZnJhbWVfYnVyeSAwIC8vIGFkbWluUmlnaHRzOiBib29sCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjQyCgkvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAxOyBpIDwgdGhpcy50eG4ubnVtQXBwQXJnczsgaSArPSAxKQoJaW50YyAxIC8vIDEKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCipmb3JfMToKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI0MgoJLy8gaSA8IHRoaXMudHhuLm51bUFwcEFyZ3MKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJdHhuIE51bUFwcEFyZ3MKCTwKCWJ6ICpmb3JfMV9lbmQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNDMKCS8vIG5hbWUgPSB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhW2ldIGFzIGJ5dGVzCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCXR4bmFzIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfYnVyeSAyIC8vIG5hbWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI0NAoJLy8gYXNzZXJ0KHRoaXMuaXNGaWVsZERlbGV0ZUFsbG93ZWQobmFtZSwgYWRtaW5SaWdodHMpLCAnZmllbGQgbm90IHJlbW92YWJsZSBvciBubyBwZXJtaXNzaW9ucyB0byByZW1vdmUnKQoJZnJhbWVfZGlnIDAgLy8gYWRtaW5SaWdodHM6IGJvb2wKCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJY2FsbHN1YiBpc0ZpZWxkRGVsZXRlQWxsb3dlZAoKCS8vIGZpZWxkIG5vdCByZW1vdmFibGUgb3Igbm8gcGVybWlzc2lvbnMgdG8gcmVtb3ZlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNDUKCS8vIHRoaXMuYm94ZXMobmFtZSkuZGVsZXRlKCkKCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2RlbAoKKmZvcl8xX2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjQyCgkvLyBpICs9IDEKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCWIgKmZvcl8xCgoqZm9yXzFfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjQ3CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyB1cGRhdGVTZWdtZW50Q291bnQoc3RyaW5nLHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfdXBkYXRlU2VnbWVudENvdW50OgoJLy8gY2hpbGROZmRBcHBJRDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gY2hpbGROZmROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSB1cGRhdGVTZWdtZW50Q291bnQoc3RyaW5nLHVpbnQ2NCl2b2lkCgljYWxsc3ViIHVwZGF0ZVNlZ21lbnRDb3VudAoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gdXBkYXRlU2VnbWVudENvdW50KGNoaWxkTmZkTmFtZTogc3RyaW5nLCBjaGlsZE5mZEFwcElEOiB1aW50NjQpOiB2b2lkCnVwZGF0ZVNlZ21lbnRDb3VudDoKCXByb3RvIDIgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNTgKCS8vIGFzc2VydChnbG9iYWxzLmNhbGxlckFwcGxpY2F0aW9uSUQgPT09IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKSwgJ2NhbGxlciBtdXN0IGJlIE5GRCByZWdpc3RyeSEnKQoJZ2xvYmFsIENhbGxlckFwcGxpY2F0aW9uSUQKCWludGMgNCAvLyBUTVBMX3JlZ2lzdHJ5QXBwSWQKCT09CgoJLy8gY2FsbGVyIG11c3QgYmUgTkZEIHJlZ2lzdHJ5IQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjU5CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICB0aGlzLnNhZmVHbG9iYWxCeXRlR2V0RXgoY2hpbGROZmRBcHBJRCwgTkZEX0tFWV9NSU5USU5HKSA9PT0gTkZEX01JTlRJTkdfU1RBVEVfUE9TVEFTQSwKCS8vICAgICAgICAgICAgICdjaGlsZCBORkQgTVVTVCBzdGlsbCBiZSBpbiBwcmUtY2xhaW0gc3RhdGUhJywKCS8vICAgICAgICAgKQoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJZnJhbWVfZGlnIC0yIC8vIGNoaWxkTmZkQXBwSUQ6IHVpbnQ2NAoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldEV4CglieXRlYyAzMCAvLyAiMiIKCT09CgoJLy8gY2hpbGQgTkZEIE1VU1Qgc3RpbGwgYmUgaW4gcHJlLWNsYWltIHN0YXRlIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjYzCgkvLyBhc3NlcnQoIXRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HKS5leGlzdHMpCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglieXRlYyAzIC8vICJpLm1pbnRpbmciCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNjQKCS8vIHRoaXMubm90Rm9yU2FsZU9yRXhwaXJlZCgpCgljYWxsc3ViIG5vdEZvclNhbGVPckV4cGlyZWQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNjYKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIHRoaXMuc2FmZUdsb2JhbEJ5dGVHZXRFeChjaGlsZE5mZEFwcElELCBORkRfS0VZX05BTUUpID09PSBjaGlsZE5mZE5hbWUsCgkvLyAgICAgICAgICAgICAncGFzc2VkIGluIGNoaWxkIG5hbWUgbXVzdCBtYXRjaCBuYW1lIGluIGNyZWF0ZWQgbmZkIHN0YXRlJywKCS8vICAgICAgICAgKQoJYnl0ZWMgNCAvLyAiaS5uYW1lIgoJZnJhbWVfZGlnIC0yIC8vIGNoaWxkTmZkQXBwSUQ6IHVpbnQ2NAoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldEV4CglmcmFtZV9kaWcgLTEgLy8gY2hpbGROZmROYW1lOiBzdHJpbmcKCT09CgoJLy8gcGFzc2VkIGluIGNoaWxkIG5hbWUgbXVzdCBtYXRjaCBuYW1lIGluIGNyZWF0ZWQgbmZkIHN0YXRlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNzAKCS8vIHRoaXNQYXJlbnROYW1lID0gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlCglieXRlYyA0IC8vICJpLm5hbWUiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfYnVyeSAwIC8vIHRoaXNQYXJlbnROYW1lOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNzUKCS8vIGluZGV4Q2hlY2tTdG9wID0gbGVuKGNoaWxkTmZkTmFtZSkgLSBsZW4odGhpc1BhcmVudE5hbWUpIC0gMQoJZnJhbWVfZGlnIC0xIC8vIGNoaWxkTmZkTmFtZTogc3RyaW5nCglsZW4KCWZyYW1lX2RpZyAwIC8vIHRoaXNQYXJlbnROYW1lOiBieXRlW10KCWxlbgoJLQoJaW50YyAxIC8vIDEKCS0KCWZyYW1lX2J1cnkgMSAvLyBpbmRleENoZWNrU3RvcDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mjc2CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICBleHRyYWN0MyhjaGlsZE5mZE5hbWUsIGluZGV4Q2hlY2tTdG9wLCBsZW4odGhpc1BhcmVudE5hbWUpICsgMSkgPT09ICcuJyArIHRoaXNQYXJlbnROYW1lLAoJLy8gICAgICAgICAgICAgJ3BhcmVudCBtdXN0IGJlIHN1ZmZpeCBvZiBjaGlsZCcsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyAtMSAvLyBjaGlsZE5mZE5hbWU6IHN0cmluZwoJZnJhbWVfZGlnIDEgLy8gaW5kZXhDaGVja1N0b3A6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gdGhpc1BhcmVudE5hbWU6IGJ5dGVbXQoJbGVuCglpbnRjIDEgLy8gMQoJKwoJZXh0cmFjdDMKCWJ5dGVjIDI4IC8vICAiLiIKCWZyYW1lX2RpZyAwIC8vIHRoaXNQYXJlbnROYW1lOiBieXRlW10KCWNvbmNhdAoJPT0KCgkvLyBwYXJlbnQgbXVzdCBiZSBzdWZmaXggb2YgY2hpbGQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI4MAoJLy8gYXNzZXJ0KHRoaXMubm9QZXJpb2RCZWZvcmVJbmRleChjaGlsZE5mZE5hbWUsIGluZGV4Q2hlY2tTdG9wKSkKCWZyYW1lX2RpZyAxIC8vIGluZGV4Q2hlY2tTdG9wOiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBjaGlsZE5mZE5hbWU6IHN0cmluZwoJY2FsbHN1YiBub1BlcmlvZEJlZm9yZUluZGV4Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyODEKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUdNRU5UQ09VTlQpLnZhbHVlID0gaXRvYih0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9TRUdNRU5UQ09VTlQpICsgMSkKCWJ5dGVjIDM1IC8vICJpLnNlZ21lbnRDb3VudCIKCWR1cAoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglpbnRjIDEgLy8gMQoJKwoJaXRvYgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyODIKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9USU1FQ0hBTkdFRCkudmFsdWUgPSBpdG9iKGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wKQoJYnl0ZWMgMiAvLyAiaS50aW1lQ2hhbmdlZCIKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGdldEZpZWxkVXBkYXRlQ29zdChieXRlW11bXSl1aW50NjQKKmFiaV9yb3V0ZV9nZXRGaWVsZFVwZGF0ZUNvc3Q6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDExIC8vIDB4MTUxZjdjNzUKCgkvLyBmaWVsZEFuZFZhbHM6IGJ5dGVbXVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCgoJLy8gZXhlY3V0ZSBnZXRGaWVsZFVwZGF0ZUNvc3QoYnl0ZVtdW10pdWludDY0CgljYWxsc3ViIGdldEZpZWxkVXBkYXRlQ29zdAoJaXRvYgoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdldEZpZWxkVXBkYXRlQ29zdChmaWVsZEFuZFZhbHM6IGJ5dGVzW10pOiB1aW50NjQKZ2V0RmllbGRVcGRhdGVDb3N0OgoJcHJvdG8gMSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gNgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI4NwoJLy8gY29zdCA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDAgLy8gY29zdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mjg4CgkvLyByZW1vdmVkQ29zdCA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDEgLy8gcmVtb3ZlZENvc3Q6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI5MAoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZEFuZFZhbHMubGVuZ3RoOyBpICs9IDIpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoKKmZvcl8yOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjkwCgkvLyBpIDwgZmllbGRBbmRWYWxzLmxlbmd0aAoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gZmllbGRBbmRWYWxzOiBieXRlc1tdCglpbnRjIDAgLy8gMAoJZXh0cmFjdF91aW50MTYKCTwKCWJ6ICpmb3JfMl9lbmQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyOTEKCS8vIG5hbWUgPSBmaWVsZEFuZFZhbHNbaV0KCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEFuZFZhbHM6IGJ5dGVzW10KCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDAgLy8gIGluaXRpYWwgb2Zmc2V0CglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgMiAvLyAyCgkqIC8vIGFjYyAqIDIKCSsKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJdW5jb3ZlciAyCglleHRyYWN0X3VpbnQxNgoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglkdXAgLy8gZHVwbGljYXRlIHN0YXJ0IG9mIGVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXN3YXAKCWV4dHJhY3RfdWludDE2IC8vIGdldCBudW1iZXIgb2YgZWxlbWVudHMKCWludGMgMSAvLyAgZ2V0IHR5cGUgbGVuZ3RoCgkqIC8vIG11bHRpcGx5IGJ5IHR5cGUgbGVuZ3RoCglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWV4dHJhY3QzCglleHRyYWN0IDIgMAoJZnJhbWVfYnVyeSAzIC8vIG5hbWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI5MgoJLy8gdmFsdWUgPSBmaWVsZEFuZFZhbHNbaSArIDFdCglmcmFtZV9kaWcgLTEgLy8gZmllbGRBbmRWYWxzOiBieXRlc1tdCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyAwIC8vICBpbml0aWFsIG9mZnNldAoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJaW50YyAyIC8vIDIKCSogLy8gYWNjICogMgoJKwoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cgl1bmNvdmVyIDIKCWV4dHJhY3RfdWludDE2CglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWR1cCAvLyBkdXBsaWNhdGUgc3RhcnQgb2YgZWxlbWVudAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJZXh0cmFjdF91aW50MTYgLy8gZ2V0IG51bWJlciBvZiBlbGVtZW50cwoJaW50YyAxIC8vICBnZXQgdHlwZSBsZW5ndGgKCSogLy8gbXVsdGlwbHkgYnkgdHlwZSBsZW5ndGgKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJZXh0cmFjdDMKCWV4dHJhY3QgMiAwCglmcmFtZV9idXJ5IDQgLy8gdmFsdWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI5MwoJLy8gZXhpc3RzID0gdGhpcy5ib3hlcyhuYW1lKS5leGlzdHMKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2xlbgoJc3dhcAoJcG9wCglmcmFtZV9idXJ5IDUgLy8gZXhpc3RzOiBib29sCgoJLy8gKmlmMTRfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyOTUKCS8vIGxlbih2YWx1ZSkgPT09IDAKCWZyYW1lX2RpZyA0IC8vIHZhbHVlOiBieXRlW10KCWxlbgoJaW50YyAwIC8vIDAKCT09CglieiAqaWYxNF9lbmQKCgkvLyAqaWYxNF9jb25zZXF1ZW50CgkvLyAqaWYxNV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI5NgoJLy8gZXhpc3RzCglmcmFtZV9kaWcgNSAvLyBleGlzdHM6IGJvb2wKCWJ6ICppZjE1X2VuZAoKCS8vICppZjE1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI5OAoJLy8gcmVtb3ZlZENvc3QgKz0gU0NCT1hfUEVSQk9YICsgU0NCT1hfUEVSQllURSAqIChsZW4obmFtZSkgKyB0aGlzLmJveGVzKG5hbWUpLnNpemUpCglmcmFtZV9kaWcgMSAvLyByZW1vdmVkQ29zdDogdWludDY0CglpbnRjIDEyIC8vIDI1MDAKCWludGMgOSAvLyA0MDAKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJbGVuCglmcmFtZV9kaWcgMyAvLyBuYW1lOiBieXRlW10KCWJveF9sZW4KCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMobmFtZSkuc2l6ZQoJYXNzZXJ0CgkrCgkqCgkrCgkrCglmcmFtZV9idXJ5IDEgLy8gcmVtb3ZlZENvc3Q6IHVpbnQ2NAoKKmlmMTVfZW5kOgoJYiAqZm9yXzJfY29udGludWUKCippZjE0X2VuZDoKCS8vICppZjE2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzAyCgkvLyAhZXhpc3RzCglmcmFtZV9kaWcgNSAvLyBleGlzdHM6IGJvb2wKCSEKCWJ6ICppZjE2X2VuZAoKCS8vICppZjE2X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjMwNAoJLy8gY29zdCArPSBTQ0JPWF9QRVJCT1ggKyBTQ0JPWF9QRVJCWVRFICogKGxlbihuYW1lKSArIGxlbih2YWx1ZSkpCglmcmFtZV9kaWcgMCAvLyBjb3N0OiB1aW50NjQKCWludGMgMTIgLy8gMjUwMAoJaW50YyA5IC8vIDQwMAoJZnJhbWVfZGlnIDMgLy8gbmFtZTogYnl0ZVtdCglsZW4KCWZyYW1lX2RpZyA0IC8vIHZhbHVlOiBieXRlW10KCWxlbgoJKwoJKgoJKwoJKwoJZnJhbWVfYnVyeSAwIC8vIGNvc3Q6IHVpbnQ2NAoJYiAqZm9yXzJfY29udGludWUKCippZjE2X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjMwNwoJLy8gZXhpc3RpbmdMZW5ndGggPSB0aGlzLmJveGVzKG5hbWUpLnNpemUKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2xlbgoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5ib3hlcyhuYW1lKS5zaXplCglhc3NlcnQKCWZyYW1lX2J1cnkgNiAvLyBleGlzdGluZ0xlbmd0aDogdWludDY0CgoJLy8gKmlmMTdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMDgKCS8vIGxlbih2YWx1ZSkgPD0gZXhpc3RpbmdMZW5ndGgKCWZyYW1lX2RpZyA0IC8vIHZhbHVlOiBieXRlW10KCWxlbgoJZnJhbWVfZGlnIDYgLy8gZXhpc3RpbmdMZW5ndGg6IHVpbnQ2NAoJPD0KCWJ6ICppZjE3X2Vsc2UKCgkvLyAqaWYxN19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMDkKCS8vIHJlbW92ZWRDb3N0ICs9IFNDQk9YX1BFUkJZVEUgKiAoZXhpc3RpbmdMZW5ndGggLSBsZW4odmFsdWUpKQoJZnJhbWVfZGlnIDEgLy8gcmVtb3ZlZENvc3Q6IHVpbnQ2NAoJaW50YyA5IC8vIDQwMAoJZnJhbWVfZGlnIDYgLy8gZXhpc3RpbmdMZW5ndGg6IHVpbnQ2NAoJZnJhbWVfZGlnIDQgLy8gdmFsdWU6IGJ5dGVbXQoJbGVuCgktCgkqCgkrCglmcmFtZV9idXJ5IDEgLy8gcmVtb3ZlZENvc3Q6IHVpbnQ2NAoJYiAqaWYxN19lbmQKCippZjE3X2Vsc2U6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMTEKCS8vIGNvc3QgKz0gU0NCT1hfUEVSQllURSAqIChsZW4odmFsdWUpIC0gZXhpc3RpbmdMZW5ndGgpCglmcmFtZV9kaWcgMCAvLyBjb3N0OiB1aW50NjQKCWludGMgOSAvLyA0MDAKCWZyYW1lX2RpZyA0IC8vIHZhbHVlOiBieXRlW10KCWxlbgoJZnJhbWVfZGlnIDYgLy8gZXhpc3RpbmdMZW5ndGg6IHVpbnQ2NAoJLQoJKgoJKwoJZnJhbWVfYnVyeSAwIC8vIGNvc3Q6IHVpbnQ2NAoKKmlmMTdfZW5kOgoKKmZvcl8yX2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjkwCgkvLyBpICs9IDIKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAyIC8vIDIKCSsKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCWIgKmZvcl8yCgoqZm9yXzJfZW5kOgoJLy8gKmlmMThfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMTUKCS8vIHJlbW92ZWRDb3N0ID4gY29zdAoJZnJhbWVfZGlnIDEgLy8gcmVtb3ZlZENvc3Q6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gY29zdDogdWludDY0Cgk+CglieiAqaWYxOF9lbmQKCgkvLyAqaWYxOF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMTYKCS8vIHJldHVybiAwCglpbnRjIDAgLy8gMAoJYiAqZ2V0RmllbGRVcGRhdGVDb3N0KnJldHVybgoKKmlmMThfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzE4CgkvLyByZXR1cm4gY29zdCAtIHJlbW92ZWRDb3N0CglmcmFtZV9kaWcgMCAvLyBjb3N0OiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIHJlbW92ZWRDb3N0OiB1aW50NjQKCS0KCipnZXRGaWVsZFVwZGF0ZUNvc3QqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gNgoJcmV0c3ViCgovLyB1cGRhdGVGaWVsZHMoYnl0ZVtdW10pdm9pZAoqYWJpX3JvdXRlX3VwZGF0ZUZpZWxkczoKCS8vIGZpZWxkQW5kVmFsczogYnl0ZVtdW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCgkvLyBleGVjdXRlIHVwZGF0ZUZpZWxkcyhieXRlW11bXSl2b2lkCgljYWxsc3ViIHVwZGF0ZUZpZWxkcwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gdXBkYXRlRmllbGRzKGZpZWxkQW5kVmFsczogYnl0ZXNbXSk6IHZvaWQKdXBkYXRlRmllbGRzOgoJcHJvdG8gMSAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gMwoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjMyMgoJLy8gYXNzZXJ0KCF0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTUlOVElORykuZXhpc3RzKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzIzCgkvLyBhc3NlcnQoIXRoaXMuaXNFeHBpcmVkKCksICJjYW4ndCB1cGRhdGUgZmllbGRzIGlmIE5GRCBleHBpcmVkIikKCWNhbGxzdWIgaXNFeHBpcmVkCgkhCgoJLy8gY2FuJ3QgdXBkYXRlIGZpZWxkcyBpZiBORkQgZXhwaXJlZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzI1CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vICppZjE5X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzI4CgkvLyBnbG9iYWxzLmNhbGxlckFwcGxpY2F0aW9uSUQgPT09IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKQoJZ2xvYmFsIENhbGxlckFwcGxpY2F0aW9uSUQKCWludGMgNCAvLyBUTVBMX3JlZ2lzdHJ5QXBwSWQKCT09CglieiAqaWYxOV9lbmQKCgkvLyAqaWYxOV9jb25zZXF1ZW50CgkvLyAqaWYyMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjMyOQoJLy8gZmllbGRBbmRWYWxzLmxlbmd0aCA9PT0gMiAmJiBmaWVsZEFuZFZhbHNbMF0gPT09IE5GRF9GSUVMRF9DQV9UT19WRVJJRlkKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEFuZFZhbHM6IGJ5dGVzW10KCWludGMgMCAvLyAwCglleHRyYWN0X3VpbnQxNgoJaW50YyAyIC8vIDIKCT09CglkdXAKCWJ6ICpza2lwX2FuZDkKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEFuZFZhbHM6IGJ5dGVzW10KCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDIgLy8gMgoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJdW5jb3ZlciAyCglleHRyYWN0X3VpbnQxNgoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglkdXAgLy8gZHVwbGljYXRlIHN0YXJ0IG9mIGVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXN3YXAKCWV4dHJhY3RfdWludDE2IC8vIGdldCBudW1iZXIgb2YgZWxlbWVudHMKCWludGMgMSAvLyAgZ2V0IHR5cGUgbGVuZ3RoCgkqIC8vIG11bHRpcGx5IGJ5IHR5cGUgbGVuZ3RoCglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWV4dHJhY3QzCglleHRyYWN0IDIgMAoJcHVzaGJ5dGVzICJ1LmNhdi5hbGdvLmEiCgk9PQoJJiYKCipza2lwX2FuZDk6CglieiAqaWYyMF9lbmQKCgkvLyAqaWYyMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMzAKCS8vIHRoaXMuYm94ZXMoZmllbGRBbmRWYWxzWzBdKS52YWx1ZSA9IGZpZWxkQW5kVmFsc1sxXQoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkQW5kVmFsczogYnl0ZXNbXQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMiAvLyAyCglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cgl1bmNvdmVyIDIKCWV4dHJhY3RfdWludDE2CglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWR1cCAvLyBkdXBsaWNhdGUgc3RhcnQgb2YgZWxlbWVudAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJZXh0cmFjdF91aW50MTYgLy8gZ2V0IG51bWJlciBvZiBlbGVtZW50cwoJaW50YyAxIC8vICBnZXQgdHlwZSBsZW5ndGgKCSogLy8gbXVsdGlwbHkgYnkgdHlwZSBsZW5ndGgKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJZXh0cmFjdDMKCWV4dHJhY3QgMiAwCglmcmFtZV9kaWcgLTEgLy8gZmllbGRBbmRWYWxzOiBieXRlc1tdCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyAxMCAvLyA0Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cgl1bmNvdmVyIDIKCWV4dHJhY3RfdWludDE2CglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWR1cCAvLyBkdXBsaWNhdGUgc3RhcnQgb2YgZWxlbWVudAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJZXh0cmFjdF91aW50MTYgLy8gZ2V0IG51bWJlciBvZiBlbGVtZW50cwoJaW50YyAxIC8vICBnZXQgdHlwZSBsZW5ndGgKCSogLy8gbXVsdGlwbHkgYnkgdHlwZSBsZW5ndGgKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJZXh0cmFjdDMKCWV4dHJhY3QgMiAwCglib3hfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzMxCgkvLyByZXR1cm4KCXJldHN1YgoKKmlmMjBfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzMzCgkvLyBhc3NlcnQoZmFsc2UsICdpbnZhbGlkIHVwZGF0ZSBjYWxsIGJ5IHJlZ2lzdHJ5JykKCWludGMgMCAvLyAwCgoJLy8gaW52YWxpZCB1cGRhdGUgY2FsbCBieSByZWdpc3RyeQoJYXNzZXJ0CgoqaWYxOV9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMzYKCS8vIGFkbWluUmlnaHRzID0gdGhpcy5pc0N1cnJlbnRUeG5Db250cmFjdEF1dGhvcml0eSgpCgljYWxsc3ViIGlzQ3VycmVudFR4bkNvbnRyYWN0QXV0aG9yaXR5CglmcmFtZV9idXJ5IDAgLy8gYWRtaW5SaWdodHM6IGJvb2wKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMzcKCS8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBmaWVsZEFuZFZhbHMubGVuZ3RoOyBpICs9IDIpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAxIC8vIGk6IHVpbnQ2NAoKKmZvcl8zOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzM3CgkvLyBpIDwgZmllbGRBbmRWYWxzLmxlbmd0aAoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gZmllbGRBbmRWYWxzOiBieXRlc1tdCglpbnRjIDAgLy8gMAoJZXh0cmFjdF91aW50MTYKCTwKCWJ6ICpmb3JfM19lbmQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMzgKCS8vIG5hbWUgPSBmaWVsZEFuZFZhbHNbaV0KCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEFuZFZhbHM6IGJ5dGVzW10KCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDAgLy8gIGluaXRpYWwgb2Zmc2V0CglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludGMgMiAvLyAyCgkqIC8vIGFjYyAqIDIKCSsKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJdW5jb3ZlciAyCglleHRyYWN0X3VpbnQxNgoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglkdXAgLy8gZHVwbGljYXRlIHN0YXJ0IG9mIGVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXN3YXAKCWV4dHJhY3RfdWludDE2IC8vIGdldCBudW1iZXIgb2YgZWxlbWVudHMKCWludGMgMSAvLyAgZ2V0IHR5cGUgbGVuZ3RoCgkqIC8vIG11bHRpcGx5IGJ5IHR5cGUgbGVuZ3RoCglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWV4dHJhY3QzCglleHRyYWN0IDIgMAoJZnJhbWVfYnVyeSAyIC8vIG5hbWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjMzOQoJLy8gdmFsdWUgPSBmaWVsZEFuZFZhbHNbaSArIDFdCglmcmFtZV9kaWcgLTEgLy8gZmllbGRBbmRWYWxzOiBieXRlc1tdCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyAwIC8vICBpbml0aWFsIG9mZnNldAoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJaW50YyAyIC8vIDIKCSogLy8gYWNjICogMgoJKwoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cgl1bmNvdmVyIDIKCWV4dHJhY3RfdWludDE2CglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWR1cCAvLyBkdXBsaWNhdGUgc3RhcnQgb2YgZWxlbWVudAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJZXh0cmFjdF91aW50MTYgLy8gZ2V0IG51bWJlciBvZiBlbGVtZW50cwoJaW50YyAxIC8vICBnZXQgdHlwZSBsZW5ndGgKCSogLy8gbXVsdGlwbHkgYnkgdHlwZSBsZW5ndGgKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJZXh0cmFjdDMKCWV4dHJhY3QgMiAwCglmcmFtZV9idXJ5IDMgLy8gdmFsdWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM0MAoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgIHRoaXMuaXNGaWVsZFVwZGF0ZUFsbG93ZWQobmFtZSwgdmFsdWUsIGFkbWluUmlnaHRzKSwKCS8vICAgICAgICAgICAgICAgICAnZmllbGQgbm90IHVwZGF0YWJsZSBvciBubyBwZXJtaXNzaW9ucyB0byB1cGRhdGUnLAoJLy8gICAgICAgICAgICAgKQoJZnJhbWVfZGlnIDAgLy8gYWRtaW5SaWdodHM6IGJvb2wKCWZyYW1lX2RpZyAzIC8vIHZhbHVlOiBieXRlW10KCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJY2FsbHN1YiBpc0ZpZWxkVXBkYXRlQWxsb3dlZAoKCS8vIGZpZWxkIG5vdCB1cGRhdGFibGUgb3Igbm8gcGVybWlzc2lvbnMgdG8gdXBkYXRlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozNDQKCS8vIHRoaXMuYm94ZXMobmFtZSkuZGVsZXRlKCkKCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2RlbAoKCS8vICppZjIxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzQ1CgkvLyBsZW4odmFsdWUpID4gMAoJZnJhbWVfZGlnIDMgLy8gdmFsdWU6IGJ5dGVbXQoJbGVuCglpbnRjIDAgLy8gMAoJPgoJYnogKmlmMjFfZW5kCgoJLy8gKmlmMjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzQ2CgkvLyB0aGlzLmJveGVzKG5hbWUpLnZhbHVlID0gdmFsdWUKCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJZnJhbWVfZGlnIDMgLy8gdmFsdWU6IGJ5dGVbXQoJYm94X3B1dAoKKmlmMjFfZW5kOgoKKmZvcl8zX2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzM3CgkvLyBpICs9IDIKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50YyAyIC8vIDIKCSsKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCWIgKmZvcl8zCgoqZm9yXzNfZW5kOgoJcmV0c3ViCgovLyB1cGRhdGVGaWVsZHNGcm9tQXJncygpOiB2b2lkCnVwZGF0ZUZpZWxkc0Zyb21BcmdzOgoJcHJvdG8gMCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gMwoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM1MgoJLy8gYXNzZXJ0KCF0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTUlOVElORykuZXhpc3RzKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzUzCgkvLyBhc3NlcnQoIXRoaXMuaXNFeHBpcmVkKCksICJjYW4ndCB1cGRhdGUgZmllbGRzIGlmIE5GRCBleHBpcmVkIikKCWNhbGxzdWIgaXNFeHBpcmVkCgkhCgoJLy8gY2FuJ3QgdXBkYXRlIGZpZWxkcyBpZiBORkQgZXhwaXJlZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzU1CgkvLyBhZG1pblJpZ2h0cyA9IHRoaXMuaXNDdXJyZW50VHhuQ29udHJhY3RBdXRob3JpdHkoKQoJY2FsbHN1YiBpc0N1cnJlbnRUeG5Db250cmFjdEF1dGhvcml0eQoJZnJhbWVfYnVyeSAwIC8vIGFkbWluUmlnaHRzOiBib29sCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzU2CgkvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAxOyBpIDwgdGhpcy50eG4ubnVtQXBwQXJnczsgaSArPSAyKQoJaW50YyAxIC8vIDEKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCipmb3JfNDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM1NgoJLy8gaSA8IHRoaXMudHhuLm51bUFwcEFyZ3MKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJdHhuIE51bUFwcEFyZ3MKCTwKCWJ6ICpmb3JfNF9lbmQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozNTcKCS8vIG5hbWUgPSB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhW2ldIGFzIGJ5dGVzCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCXR4bmFzIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfYnVyeSAyIC8vIG5hbWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM1OAoJLy8gdmFsdWUgPSB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhW2kgKyAxXSBhcyBieXRlcwoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJdHhuYXMgQXBwbGljYXRpb25BcmdzCglmcmFtZV9idXJ5IDMgLy8gdmFsdWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM1OQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgIHRoaXMuaXNGaWVsZFVwZGF0ZUFsbG93ZWQobmFtZSwgdmFsdWUsIGFkbWluUmlnaHRzKSwKCS8vICAgICAgICAgICAgICAgICAnZmllbGQgbm90IHVwZGF0YWJsZSBvciBubyBwZXJtaXNzaW9ucyB0byB1cGRhdGUnLAoJLy8gICAgICAgICAgICAgKQoJZnJhbWVfZGlnIDAgLy8gYWRtaW5SaWdodHM6IGJvb2wKCWZyYW1lX2RpZyAzIC8vIHZhbHVlOiBieXRlW10KCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJY2FsbHN1YiBpc0ZpZWxkVXBkYXRlQWxsb3dlZAoKCS8vIGZpZWxkIG5vdCB1cGRhdGFibGUgb3Igbm8gcGVybWlzc2lvbnMgdG8gdXBkYXRlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozNjMKCS8vIHRoaXMuYm94ZXMobmFtZSkuZGVsZXRlKCkKCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2RlbAoKCS8vICppZjIyX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzY0CgkvLyBsZW4odmFsdWUpID4gMAoJZnJhbWVfZGlnIDMgLy8gdmFsdWU6IGJ5dGVbXQoJbGVuCglpbnRjIDAgLy8gMAoJPgoJYnogKmlmMjJfZW5kCgoJLy8gKmlmMjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzY1CgkvLyB0aGlzLmJveGVzKG5hbWUpLnZhbHVlID0gdmFsdWUKCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJZnJhbWVfZGlnIDMgLy8gdmFsdWU6IGJ5dGVbXQoJYm94X3B1dAoKKmlmMjJfZW5kOgoKKmZvcl80X2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzU2CgkvLyBpICs9IDIKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50YyAyIC8vIDIKCSsKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCWIgKmZvcl80CgoqZm9yXzRfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzY4CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyByZWFkRmllbGQoYnl0ZVtdKWJ5dGVbXQoqYWJpX3JvdXRlX3JlYWRGaWVsZDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMTEgLy8gMHgxNTFmN2M3NQoKCS8vIGZpZWxkTmFtZTogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgcmVhZEZpZWxkKGJ5dGVbXSlieXRlW10KCWNhbGxzdWIgcmVhZEZpZWxkCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHJlYWRGaWVsZChmaWVsZE5hbWU6IGJ5dGVzKTogYnl0ZXMKcmVhZEZpZWxkOgoJcHJvdG8gMSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gNAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM3NAoJLy8gdHJ1c3RUeXBlID0gZXh0cmFjdDMoZmllbGROYW1lLCAwLCAyKQoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkTmFtZTogYnl0ZXMKCWV4dHJhY3QgMCAyCglmcmFtZV9idXJ5IDAgLy8gdHJ1c3RUeXBlOiBieXRlW10KCgkvLyAqaWYyM19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM3NgoJLy8gdGhpcy5pc0ludGVybmFsRmllbGQodHJ1c3RUeXBlKQoJZnJhbWVfZGlnIDAgLy8gdHJ1c3RUeXBlOiBieXRlW10KCWNhbGxzdWIgaXNJbnRlcm5hbEZpZWxkCglieiAqaWYyM19lbmQKCgkvLyAqaWYyM19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozNzcKCS8vIHJldHVybiB0aGlzLnNhZmVHbG9iYWxCeXRlR2V0KGZpZWxkTmFtZSkKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZE5hbWU6IGJ5dGVzCgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0CgliICpyZWFkRmllbGQqcmV0dXJuCgoqaWYyM19lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozNzkKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIHRoaXMuaXNVc2VyRmllbGQodHJ1c3RUeXBlKSB8fCB0aGlzLmlzVmVyaWZpZWRGaWVsZCh0cnVzdFR5cGUpLAoJLy8gICAgICAgICAgICAgJ211c3QgYmUgdXNlci1kZWZpbmVkIG9yIHZlcmlmaWVkIGZpZWxkIHRvIGZldGNoJywKCS8vICAgICAgICAgKQoJZnJhbWVfZGlnIDAgLy8gdHJ1c3RUeXBlOiBieXRlW10KCWNhbGxzdWIgaXNVc2VyRmllbGQKCWR1cAoJYm56ICpza2lwX29yMAoJZnJhbWVfZGlnIDAgLy8gdHJ1c3RUeXBlOiBieXRlW10KCWNhbGxzdWIgaXNWZXJpZmllZEZpZWxkCgl8fAoKKnNraXBfb3IwOgoJLy8gbXVzdCBiZSB1c2VyLWRlZmluZWQgb3IgdmVyaWZpZWQgZmllbGQgdG8gZmV0Y2gKCWFzc2VydAoKCS8vICppZjI0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzgzCgkvLyB0aGlzLmJveGVzKGZpZWxkTmFtZSkuZXhpc3RzCglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBieXRlcwoJYm94X2xlbgoJc3dhcAoJcG9wCglieiAqaWYyNF9lbmQKCgkvLyAqaWYyNF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozODQKCS8vIHJldHVybiB0aGlzLmJveGVzKGZpZWxkTmFtZSkudmFsdWUKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZE5hbWU6IGJ5dGVzCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKGZpZWxkTmFtZSkudmFsdWUKCWFzc2VydAoJYiAqcmVhZEZpZWxkKnJldHVybgoKKmlmMjRfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mzg3CgkvLyBib3hOYW1lID0gZmllbGROYW1lICsgJ18wMCcKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZE5hbWU6IGJ5dGVzCglwdXNoYnl0ZXMgMHg1ZjMwMzAgLy8gIl8wMCIKCWNvbmNhdAoJZnJhbWVfYnVyeSAxIC8vIGJveE5hbWU6IGJ5dGVbXQoKCS8vICppZjI1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mzg4CgkvLyAhdGhpcy5ib3hlcyhib3hOYW1lKS5leGlzdHMKCWZyYW1lX2RpZyAxIC8vIGJveE5hbWU6IGJ5dGVbXQoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglieiAqaWYyNV9lbmQKCgkvLyAqaWYyNV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozODkKCS8vIHJldHVybiAnJwoJYnl0ZWMgMCAvLyAgIiIKCWIgKnJlYWRGaWVsZCpyZXR1cm4KCippZjI1X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM5MgoJLy8gcmV0VmFsdWUgPSB0aGlzLmJveGVzKGJveE5hbWUpLnZhbHVlIGFzIGJ5dGVzCglmcmFtZV9kaWcgMSAvLyBib3hOYW1lOiBieXRlW10KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoYm94TmFtZSkudmFsdWUKCWFzc2VydAoJZnJhbWVfYnVyeSAyIC8vIHJldFZhbHVlOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozOTMKCS8vIG5hbWVQcmVmaXggPSBmaWVsZE5hbWUgKyAnXzAnCglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBieXRlcwoJcHVzaGJ5dGVzIDB4NWYzMCAvLyAiXzAiCgljb25jYXQKCWZyYW1lX2J1cnkgMyAvLyBuYW1lUHJlZml4OiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozOTQKCS8vIGZvciAobGV0IGkgPSAxOyBpIDwgMTA7IGkgKz0gMSkKCWludGMgMSAvLyAxCglmcmFtZV9idXJ5IDQgLy8gaTogdWludDY0CgoqZm9yXzU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozOTQKCS8vIGkgPCAxMAoJZnJhbWVfZGlnIDQgLy8gaTogdWludDY0CglpbnRjIDExIC8vIDEwCgk8CglieiAqZm9yXzVfZW5kCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mzk1CgkvLyBib3hOYW1lID0gbmFtZVByZWZpeCArIGkudG9TdHJpbmcoKQoJZnJhbWVfZGlnIDMgLy8gbmFtZVByZWZpeDogYnl0ZVtdCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWNhbGxzdWIgKml0b2EKCWNvbmNhdAoJZnJhbWVfYnVyeSAxIC8vIGJveE5hbWU6IGJ5dGVbXQoKCS8vICppZjI2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mzk2CgkvLyAhdGhpcy5ib3hlcyhib3hOYW1lKS5leGlzdHMKCWZyYW1lX2RpZyAxIC8vIGJveE5hbWU6IGJ5dGVbXQoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglieiAqaWYyNl9lbmQKCgkvLyAqaWYyNl9jb25zZXF1ZW50CgliICpmb3JfNV9lbmQKCippZjI2X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQwMAoJLy8gcmV0VmFsdWUgPSBjb25jYXQocmV0VmFsdWUsIHRoaXMuYm94ZXMoYm94TmFtZSkudmFsdWUpCglmcmFtZV9kaWcgMiAvLyByZXRWYWx1ZTogYnl0ZVtdCglmcmFtZV9kaWcgMSAvLyBib3hOYW1lOiBieXRlW10KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoYm94TmFtZSkudmFsdWUKCWFzc2VydAoJY29uY2F0CglmcmFtZV9idXJ5IDIgLy8gcmV0VmFsdWU6IGJ5dGVbXQoKKmZvcl81X2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mzk0CgkvLyBpICs9IDEKCWZyYW1lX2RpZyA0IC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgNCAvLyBpOiB1aW50NjQKCWIgKmZvcl81CgoqZm9yXzVfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDAyCgkvLyByZXR1cm4gcmV0VmFsdWUKCWZyYW1lX2RpZyAyIC8vIHJldFZhbHVlOiBieXRlW10KCipyZWFkRmllbGQqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gNAoJcmV0c3ViCgovLyBvZmZlckZvclNhbGUodWludDY0LGFkZHJlc3Mpdm9pZAoqYWJpX3JvdXRlX29mZmVyRm9yU2FsZToKCS8vIHJlc2VydmVkRm9yOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKHJlc2VydmVkRm9yKSBmb3Igb2ZmZXJGb3JTYWxlIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBzZWxsQW1vdW50OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIG9mZmVyRm9yU2FsZSh1aW50NjQsYWRkcmVzcyl2b2lkCgljYWxsc3ViIG9mZmVyRm9yU2FsZQoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gb2ZmZXJGb3JTYWxlKHNlbGxBbW91bnQ6IHVpbnQ2NCwgcmVzZXJ2ZWRGb3I6IEFkZHJlc3MpOiB2b2lkCm9mZmVyRm9yU2FsZToKCXByb3RvIDIgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDA4CgkvLyBhc3NlcnQoIXRoaXMuaXNFeHBpcmVkKCksICJjYW4ndCBzZWxsIGlmIE5GRCBleHBpcmVkIikKCWNhbGxzdWIgaXNFeHBpcmVkCgkhCgoJLy8gY2FuJ3Qgc2VsbCBpZiBORkQgZXhwaXJlZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDA5CgkvLyBhc3NlcnQoIXRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HKS5leGlzdHMpCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglieXRlYyAzIC8vICJpLm1pbnRpbmciCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0MTAKCS8vIHRoaXMubXVzdEJlQ2FsbGVkQnlPd25lcigpCgljYWxsc3ViIG11c3RCZUNhbGxlZEJ5T3duZXIKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0MTEKCS8vIG91ckJveENvdW50ID0gdGhpcy5hcHAuYWRkcmVzcy50b3RhbEJveGVzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RUb3RhbEJveGVzCglwb3AKCWZyYW1lX2J1cnkgMCAvLyBvdXJCb3hDb3VudDogdWludDY0CgoJLy8gKmlmMjdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0MTYKCS8vIG91ckJveENvdW50ID4gMAoJZnJhbWVfZGlnIDAgLy8gb3VyQm94Q291bnQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT4KCWJ6ICppZjI3X2VuZAoKCS8vICppZjI3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQxNwoJLy8gbG9nKCdib3ggY291bnQ6JyArIG91ckJveENvdW50LnRvU3RyaW5nKCkpCglwdXNoYnl0ZXMgMHg2MjZmNzgyMDYzNmY3NTZlNzQzYSAvLyAiYm94IGNvdW50OiIKCWZyYW1lX2RpZyAwIC8vIG91ckJveENvdW50OiB1aW50NjQKCWNhbGxzdWIgKml0b2EKCWNvbmNhdAoJbG9nCgoqaWYyN19lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0MTkKCS8vIGFzc2VydChvdXJCb3hDb3VudCA9PT0gMCwgJ2NhbiBvbmx5IGJlIHNvbGQgaWYgbm8gdXNlci1kZWZpbmVkIG9yIHZlcmlmaWVkIHByb3BlcnRpZXMgcmVtYWluJykKCWZyYW1lX2RpZyAwIC8vIG91ckJveENvdW50OiB1aW50NjQKCWludGMgMCAvLyAwCgk9PQoKCS8vIGNhbiBvbmx5IGJlIHNvbGQgaWYgbm8gdXNlci1kZWZpbmVkIG9yIHZlcmlmaWVkIHByb3BlcnRpZXMgcmVtYWluCglhc3NlcnQKCgkvLyAqaWYyOF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQyMgoJLy8gbGVuKHRoaXMuc2FmZUdsb2JhbEJ5dGVHZXQoTkZEX0tFWV9DT01NSVNTSU9OMV9BR0VOVCkpICE9PSAwCglieXRlYyA1IC8vICJpLmNvbW1pc3Npb24xQWdlbnQuYSIKCWNhbGxzdWIgc2FmZUdsb2JhbEJ5dGVHZXQKCWxlbgoJaW50YyAwIC8vIDAKCSE9CglieiAqaWYyOF9lbmQKCgkvLyAqaWYyOF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0MjMKCS8vIGFzc2VydChzZWxsQW1vdW50ID49IE5GRF9NSU5fU0VMTEFNT1VOVF9XX0NPTU1JU1NJT05TLCAnbXVzdCBiZSBzb2xkIGZvciBhdCBsZWFzdCBNSU4gYW1vdW50JykKCWZyYW1lX2RpZyAtMSAvLyBzZWxsQW1vdW50OiB1aW50NjQKCWludGMgMTUgLy8gMTAwMDAwMAoJPj0KCgkvLyBtdXN0IGJlIHNvbGQgZm9yIGF0IGxlYXN0IE1JTiBhbW91bnQKCWFzc2VydAoKKmlmMjhfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDI1CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQyNwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0lTU0VHTUVOVExPQ0tFRCkudmFsdWUgPSBORkRfTE9DS0VEX1ZBTF9UUlVFCglieXRlYyAyMSAvLyAiaS5zZWdtZW50TG9ja2VkIgoJYnl0ZWMgMTkgLy8gIjEiCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQzMgoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1NFTExfQU1PVU5UKS52YWx1ZSA9IGl0b2Ioc2VsbEFtb3VudCkKCWJ5dGVjIDYgLy8gImkuc2VsbGFtdCIKCWZyYW1lX2RpZyAtMSAvLyBzZWxsQW1vdW50OiB1aW50NjQKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gKmlmMjlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0NDIKCS8vIHJlc2VydmVkRm9yICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzICYmIHJhd0J5dGVzKHJlc2VydmVkRm9yKSAhPT0gdGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX09XTkVSKQoJZnJhbWVfZGlnIC0yIC8vIHJlc2VydmVkRm9yOiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9CglkdXAKCWJ6ICpza2lwX2FuZDEwCglmcmFtZV9kaWcgLTIgLy8gcmVzZXJ2ZWRGb3I6IEFkZHJlc3MKCWJ5dGVjIDEgLy8gImkub3duZXIuYSIKCWNhbGxzdWIgc2FmZUdsb2JhbEJ5dGVHZXQKCSE9CgkmJgoKKnNraXBfYW5kMTA6CglieiAqaWYyOV9lbHNlaWYxX2NvbmRpdGlvbgoKCS8vICppZjI5X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ0MwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1JFU0VSVkVEX09XTkVSKS52YWx1ZSA9IHJhd0J5dGVzKHJlc2VydmVkRm9yKQoJYnl0ZWMgOCAvLyAiaS5yZXNlcnZlZE93bmVyLmEiCglmcmFtZV9kaWcgLTIgLy8gcmVzZXJ2ZWRGb3I6IEFkZHJlc3MKCWFwcF9nbG9iYWxfcHV0CgliICppZjI5X2VuZAoKKmlmMjlfZWxzZWlmMV9jb25kaXRpb246CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0NDUKCS8vIHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX01JTlRJTkdfS0lDS09GRl9BTU9VTlQpID4gMCAmJgoJLy8gICAgICAgICAgICAgc2VsbEFtb3VudCA8PSB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9NSU5USU5HX0tJQ0tPRkZfQU1PVU5UKQoJYnl0ZWMgMTMgLy8gImkubWludGluZ0tpY2tvZmZBbW91bnQiCgljYWxsc3ViIHNhZmVHbG9iYWxJbnRHZXQKCWludGMgMCAvLyAwCgk+CglkdXAKCWJ6ICpza2lwX2FuZDExCglmcmFtZV9kaWcgLTEgLy8gc2VsbEFtb3VudDogdWludDY0CglieXRlYyAxMyAvLyAiaS5taW50aW5nS2lja29mZkFtb3VudCIKCWNhbGxzdWIgc2FmZUdsb2JhbEludEdldAoJPD0KCSYmCgoqc2tpcF9hbmQxMToKCWJ6ICppZjI5X2Vsc2UKCgkvLyAqaWYyOV9lbHNlaWYxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ0OAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1JFU0VSVkVEX09XTkVSKS52YWx1ZSA9IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HX0tJQ0tPRkZfQ1JFQVRPUikudmFsdWUKCWJ5dGVjIDggLy8gImkucmVzZXJ2ZWRPd25lci5hIgoJYnl0ZWMgMTIgLy8gImkubWludGluZ0tpY2tvZmZDcmVhdG9yLmEiCglhcHBfZ2xvYmFsX2dldAoJYXBwX2dsb2JhbF9wdXQKCWIgKmlmMjlfZW5kCgoqaWYyOV9lbHNlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDUwCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfUkVTRVJWRURfT1dORVIpLmRlbGV0ZSgpCglieXRlYyA4IC8vICJpLnJlc2VydmVkT3duZXIuYSIKCWFwcF9nbG9iYWxfZGVsCgoqaWYyOV9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0NTMKCS8vIHRoaXMubmZkX29mZmVyRm9yU2FsZS5sb2coewoJLy8gICAgICAgICAgICAgYXBwSWQ6IHRoaXMuYXBwLmlkLAoJLy8gICAgICAgICAgICAgbmFtZTogdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLAoJLy8gICAgICAgICAgICAgc2VsbGVyOiBBZGRyZXNzLmZyb21CeXRlcyh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlKSwKCS8vICAgICAgICAgICAgIGFtb3VudDogc2VsbEFtb3VudCwKCS8vICAgICAgICAgICAgIHJlc2VydmVkRm9yOiByZXNlcnZlZEZvciwKCS8vICAgICAgICAgfSkKCXB1c2hieXRlcyAweGMyNGI1YWQ2IC8vIG5mZF9vZmZlckZvclNhbGUodWludDY0LHN0cmluZyxhZGRyZXNzLHVpbnQ2NCxhZGRyZXNzKQoJYnl0ZWMgMCAvLyAgaW5pdGlhbCBoZWFkCglieXRlYyAwIC8vICBpbml0aWFsIHRhaWwKCXB1c2hieXRlcyAweDAwNTIgLy8gaW5pdGlhbCBoZWFkIG9mZnNldAoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJYnl0ZWMgNCAvLyAiaS5uYW1lIgoJYXBwX2dsb2JhbF9nZXQKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CgljYWxsc3ViICpwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudAoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXQKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMSAvLyBzZWxsQW1vdW50OiB1aW50NjQKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMiAvLyByZXNlcnZlZEZvcjogQWRkcmVzcwoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJcG9wIC8vIHBvcCBoZWFkIG9mZnNldAoJY29uY2F0IC8vIGNvbmNhdCBoZWFkIGFuZCB0YWlsCgljb25jYXQKCWxvZwoJcmV0c3ViCgovLyBjYW5jZWxTYWxlKCl2b2lkCiphYmlfcm91dGVfY2FuY2VsU2FsZToKCS8vIGV4ZWN1dGUgY2FuY2VsU2FsZSgpdm9pZAoJY2FsbHN1YiBjYW5jZWxTYWxlCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBjYW5jZWxTYWxlKCk6IHZvaWQKY2FuY2VsU2FsZToKCXByb3RvIDAgMAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ2NQoJLy8gYXNzZXJ0KCF0aGlzLmlzRXhwaXJlZCgpLCAiY2FuJ3QgdXBkYXRlIGZpZWxkcyBpZiBORkQgZXhwaXJlZCIpCgljYWxsc3ViIGlzRXhwaXJlZAoJIQoKCS8vIGNhbid0IHVwZGF0ZSBmaWVsZHMgaWYgTkZEIGV4cGlyZWQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ2NgoJLy8gYXNzZXJ0KCF0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTUlOVElORykuZXhpc3RzKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDY3CgkvLyBhc3NlcnQodGhpcy5pc0ZvclNhbGUoKSwgJ211c3QgYmUgZm9yIHNhbGUnKQoJY2FsbHN1YiBpc0ZvclNhbGUKCgkvLyBtdXN0IGJlIGZvciBzYWxlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0NjgKCS8vIHRoaXMubXVzdEJlQ2FsbGVkQnlPd25lcigpCgljYWxsc3ViIG11c3RCZUNhbGxlZEJ5T3duZXIKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0NjkKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUxMX0FNT1VOVCkuZGVsZXRlKCkKCWJ5dGVjIDYgLy8gImkuc2VsbGFtdCIKCWFwcF9nbG9iYWxfZGVsCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDcwCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfUkVTRVJWRURfT1dORVIpLmRlbGV0ZSgpCglieXRlYyA4IC8vICJpLnJlc2VydmVkT3duZXIuYSIKCWFwcF9nbG9iYWxfZGVsCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDcxCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ3MwoJLy8gdGhpcy5uZmRfc2FsZUNhbmNlbGxlZC5sb2coeyBhcHBJZDogdGhpcy5hcHAuaWQsIG5hbWU6IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9OQU1FKS52YWx1ZSB9KQoJYnl0ZWMgMzYgLy8gIG5mZF9zYWxlQ2FuY2VsbGVkKHVpbnQ2NCxzdHJpbmcpCglieXRlYyAwIC8vICBpbml0aWFsIGhlYWQKCWJ5dGVjIDAgLy8gIGluaXRpYWwgdGFpbAoJYnl0ZWMgNDEgLy8gIGluaXRpYWwgaGVhZCBvZmZzZXQKCXR4bmEgQXBwbGljYXRpb25zIDAKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWJ5dGVjIDQgLy8gImkubmFtZSIKCWFwcF9nbG9iYWxfZ2V0CglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoJY29uY2F0Cglsb2cKCXJldHN1YgoKLy8gcG9zdE9mZmVyKHVpbnQ2NCxzdHJpbmcpdm9pZAoqYWJpX3JvdXRlX3Bvc3RPZmZlcjoKCS8vIG5vdGU6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZXh0cmFjdCAyIDAKCgkvLyBvZmZlcjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBwb3N0T2ZmZXIodWludDY0LHN0cmluZyl2b2lkCgljYWxsc3ViIHBvc3RPZmZlcgoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gcG9zdE9mZmVyKG9mZmVyOiB1aW50NjQsIG5vdGU6IHN0cmluZyk6IHZvaWQKcG9zdE9mZmVyOgoJcHJvdG8gMiAwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDgwCgkvLyB0aGlzLm5mZF9wb3N0ZWRPZmZlci5sb2coewoJLy8gICAgICAgICAgICAgYXBwSWQ6IHRoaXMuYXBwLmlkLAoJLy8gICAgICAgICAgICAgbmFtZTogdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLAoJLy8gICAgICAgICAgICAgc2VuZGVyOiB0aGlzLnR4bi5zZW5kZXIsCgkvLyAgICAgICAgICAgICBhbW91bnQ6IG9mZmVyLAoJLy8gICAgICAgICAgICAgbm90ZTogbm90ZSwKCS8vICAgICAgICAgfSkKCXB1c2hieXRlcyAweDUyNTMyYjcwIC8vIG5mZF9wb3N0ZWRPZmZlcih1aW50NjQsc3RyaW5nLGFkZHJlc3MsdWludDY0LHN0cmluZykKCWJ5dGVjIDAgLy8gIGluaXRpYWwgaGVhZAoJYnl0ZWMgMCAvLyAgaW5pdGlhbCB0YWlsCglwdXNoYnl0ZXMgMHgwMDM0IC8vIGluaXRpYWwgaGVhZCBvZmZzZXQKCXR4bmEgQXBwbGljYXRpb25zIDAKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWJ5dGVjIDQgLy8gImkubmFtZSIKCWFwcF9nbG9iYWxfZ2V0CglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCXR4biBTZW5kZXIKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMSAvLyBvZmZlcjogdWludDY0CglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgLTIgLy8gbm90ZTogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoJY29uY2F0Cglsb2cKCXJldHN1YgoKLy8gbWludFBheW91dCh1aW50NjQsdWludDY0KSh1aW50NjQsYWRkcmVzcyx1aW50NjQsYWRkcmVzcyx1aW50NjQpCiphYmlfcm91dGVfbWludFBheW91dDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMTEgLy8gMHgxNTFmN2M3NQoKCS8vIHNlZ21lbnRQbGF0Zm9ybUNvc3RJbkFsZ286IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIG9uZVllYXJQcmljZTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBtaW50UGF5b3V0KHVpbnQ2NCx1aW50NjQpKHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCkKCWNhbGxzdWIgbWludFBheW91dAoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIG1pbnRQYXlvdXQob25lWWVhclByaWNlOiB1aW50NjQsIHNlZ21lbnRQbGF0Zm9ybUNvc3RJbkFsZ286IHVpbnQ2NCk6IFBheW91dEluZm8KbWludFBheW91dDoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXBuIDYKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0OTIKCS8vIGFzc2VydChnbG9iYWxzLmNhbGxlckFwcGxpY2F0aW9uSUQgPT09IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKSwgJ2NhbGxlciBtdXN0IGJlIE5GRCByZWdpc3RyeSEnKQoJZ2xvYmFsIENhbGxlckFwcGxpY2F0aW9uSUQKCWludGMgNCAvLyBUTVBMX3JlZ2lzdHJ5QXBwSWQKCT09CgoJLy8gY2FsbGVyIG11c3QgYmUgTkZEIHJlZ2lzdHJ5IQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDkzCgkvLyBhc3NlcnQodGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX01JTlRJTkcpID09PSBORkRfTUlOVElOR19TVEFURV9QT1NUQVNBKQoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldAoJYnl0ZWMgMzAgLy8gIjIiCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDk1CgkvLyBvZmZlckFtdCA9IHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX1NFTExfQU1PVU5UKQoJYnl0ZWMgNiAvLyAiaS5zZWxsYW10IgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglmcmFtZV9idXJ5IDAgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ5OAoJLy8gZ3Jvc3NUb1RyZWFzdXJ5ID0gb2ZmZXJBbXQKCWZyYW1lX2RpZyAwIC8vIG9mZmVyQW10OiB1aW50NjQKCWZyYW1lX2J1cnkgMSAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoKCS8vICppZjMwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTAzCgkvLyBsZW4odGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX1NFR01FTlRfQ09NTUlTU0lPTl9BR0VOVCkpID4gMAoJYnl0ZWMgOSAvLyAiaS5zZWdtZW50QWdlbnQuYSIKCWNhbGxzdWIgc2FmZUdsb2JhbEJ5dGVHZXQKCWxlbgoJaW50YyAwIC8vIDAKCT4KCWJ6ICppZjMwX2Vsc2UKCgkvLyAqaWYzMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1MDcKCS8vIGdyb3NzVG9UcmVhc3VyeSA9IHNlZ21lbnRQbGF0Zm9ybUNvc3RJbkFsZ28KCWZyYW1lX2RpZyAtMiAvLyBzZWdtZW50UGxhdGZvcm1Db3N0SW5BbGdvOiB1aW50NjQKCWZyYW1lX2J1cnkgMSAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjUwOQoJLy8gZXh0cmFEYXlzID0gKDM2NSAqIG9mZmVyQW10KSAvIG9uZVllYXJQcmljZQoJaW50YyA4IC8vIDM2NQoJZnJhbWVfZGlnIDAgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJKgoJZnJhbWVfZGlnIC0xIC8vIG9uZVllYXJQcmljZTogdWludDY0CgkvCglmcmFtZV9idXJ5IDMgLy8gZXh0cmFEYXlzOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1MTEKCS8vIGdyb3NzVG9UcmVhc3VyeSA9IChleHRyYURheXMgKiBzZWdtZW50UGxhdGZvcm1Db3N0SW5BbGdvKSAvIDM2NQoJZnJhbWVfZGlnIDMgLy8gZXh0cmFEYXlzOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBzZWdtZW50UGxhdGZvcm1Db3N0SW5BbGdvOiB1aW50NjQKCSoKCWludGMgOCAvLyAzNjUKCS8KCWZyYW1lX2J1cnkgMSAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoKCS8vICppZjMxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTEyCgkvLyBncm9zc1RvVHJlYXN1cnkgPCBzZWdtZW50UGxhdGZvcm1Db3N0SW5BbGdvCglmcmFtZV9kaWcgMSAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIHNlZ21lbnRQbGF0Zm9ybUNvc3RJbkFsZ286IHVpbnQ2NAoJPAoJYnogKmlmMzFfZW5kCgoJLy8gKmlmMzFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTEzCgkvLyBncm9zc1RvVHJlYXN1cnkgPSBzZWdtZW50UGxhdGZvcm1Db3N0SW5BbGdvCglmcmFtZV9kaWcgLTIgLy8gc2VnbWVudFBsYXRmb3JtQ29zdEluQWxnbzogdWludDY0CglmcmFtZV9idXJ5IDEgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCippZjMxX2VuZDoKCS8vICppZjMyX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTE1CgkvLyBncm9zc1RvVHJlYXN1cnkgPj0gb2ZmZXJBbXQKCWZyYW1lX2RpZyAxIC8vIGdyb3NzVG9UcmVhc3VyeTogdWludDY0CglmcmFtZV9kaWcgMCAvLyBvZmZlckFtdDogdWludDY0Cgk+PQoJYnogKmlmMzJfZW5kCgoJLy8gKmlmMzJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTE2CgkvLyBncm9zc1RvVHJlYXN1cnkgPSBvZmZlckFtdAoJZnJhbWVfZGlnIDAgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJZnJhbWVfYnVyeSAxIC8vIGdyb3NzVG9UcmVhc3VyeTogdWludDY0CgoqaWYzMl9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1MTkKCS8vIHNlZ21lbnRDb21taXNzaW9uVG9QYXkgPSBvZmZlckFtdCAtIGdyb3NzVG9UcmVhc3VyeQoJZnJhbWVfZGlnIDAgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCS0KCWZyYW1lX2J1cnkgMiAvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5OiB1aW50NjQKCWIgKmlmMzBfZW5kCgoqaWYzMF9lbHNlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTIyCgkvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMiAvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5OiB1aW50NjQKCippZjMwX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjUyNgoJLy8gY29tbWlzc2lvblRvUGF5ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNCAvLyBjb21taXNzaW9uVG9QYXk6IHVpbnQ2NAoKCS8vICppZjMzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTI3CgkvLyB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9DT01NSVNTSU9OMSkgPT09IDAKCWJ5dGVjIDcgLy8gImkuY29tbWlzc2lvbjEiCgljYWxsc3ViIHNhZmVHbG9iYWxJbnRHZXQKCWludGMgMCAvLyAwCgk9PQoJYnogKmlmMzNfZWxzZQoKCS8vICppZjMzX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjUyOQoJLy8gY29tbWlzc2lvblRvUGF5ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNCAvLyBjb21taXNzaW9uVG9QYXk6IHVpbnQ2NAoJYiAqaWYzM19lbmQKCippZjMzX2Vsc2U6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1MzMKCS8vIGNvbW1pc3Npb25Ub1BheSA9IChncm9zc1RvVHJlYXN1cnkgKiB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9DT01NSVNTSU9OMSkpIC8gMTAwMAoJZnJhbWVfZGlnIDEgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCWJ5dGVjIDcgLy8gImkuY29tbWlzc2lvbjEiCgljYWxsc3ViIHNhZmVHbG9iYWxJbnRHZXQKCSoKCWludGMgMTggLy8gMTAwMAoJLwoJZnJhbWVfYnVyeSA0IC8vIGNvbW1pc3Npb25Ub1BheTogdWludDY0CgoqaWYzM19lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1MzYKCS8vIGNvbW1pc3Npb25BZ2VudCA9IGdsb2JhbHMuemVyb0FkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJZnJhbWVfYnVyeSA1IC8vIGNvbW1pc3Npb25BZ2VudDogYWRkcmVzcwoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjUzNwoJLy8gc2VnbWVudFJvb3RPd25lciA9IGdsb2JhbHMuemVyb0FkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJZnJhbWVfYnVyeSA2IC8vIHNlZ21lbnRSb290T3duZXI6IGFkZHJlc3MKCgkvLyAqaWYzNF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjUzOQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xX0FHRU5UKS5leGlzdHMKCXR4bmEgQXBwbGljYXRpb25zIDAKCWJ5dGVjIDUgLy8gImkuY29tbWlzc2lvbjFBZ2VudC5hIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJYnogKmlmMzRfZW5kCgoJLy8gKmlmMzRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTQwCgkvLyBjb21taXNzaW9uQWdlbnQgPSBBZGRyZXNzLmZyb21CeXRlcyh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQ09NTUlTU0lPTjFfQUdFTlQpLnZhbHVlKQoJYnl0ZWMgNSAvLyAiaS5jb21taXNzaW9uMUFnZW50LmEiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfYnVyeSA1IC8vIGNvbW1pc3Npb25BZ2VudDogYWRkcmVzcwoKKmlmMzRfZW5kOgoJLy8gKmlmMzVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1NDIKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUdNRU5UX0NPTU1JU1NJT05fQUdFTlQpLmV4aXN0cwoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZWMgOSAvLyAiaS5zZWdtZW50QWdlbnQuYSIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglzd2FwCglwb3AKCWJ6ICppZjM1X2VuZAoKCS8vICppZjM1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU0MwoJLy8gc2VnbWVudFJvb3RPd25lciA9IEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUdNRU5UX0NPTU1JU1NJT05fQUdFTlQpLnZhbHVlKQoJYnl0ZWMgOSAvLyAiaS5zZWdtZW50QWdlbnQuYSIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDYgLy8gc2VnbWVudFJvb3RPd25lcjogYWRkcmVzcwoKKmlmMzVfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTQ3CgkvLyB0aGlzLmRvUGF5b3V0cygKCS8vICAgICAgICAgICAgIGdyb3NzVG9UcmVhc3VyeSwKCS8vICAgICAgICAgICAgIEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUxMRVIpLnZhbHVlKSwKCS8vICAgICAgICAgICAgIGNvbW1pc3Npb25Ub1BheSwKCS8vICAgICAgICAgICAgIHNlZ21lbnRDb21taXNzaW9uVG9QYXksCgkvLyAgICAgICAgICAgICBBZGRyZXNzLmZyb21CeXRlcyh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfU0VHTUVOVF9DT01NSVNTSU9OX0FHRU5UKS52YWx1ZSksCgkvLyAgICAgICAgICkKCWJ5dGVjIDkgLy8gImkuc2VnbWVudEFnZW50LmEiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDIgLy8gc2VnbWVudENvbW1pc3Npb25Ub1BheTogdWludDY0CglmcmFtZV9kaWcgNCAvLyBjb21taXNzaW9uVG9QYXk6IHVpbnQ2NAoJYnl0ZWMgMTAgLy8gImkuc2VsbGVyLmEiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDEgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCWNhbGxzdWIgZG9QYXlvdXRzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTU2CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfU0VMTEVSKS52YWx1ZSA9IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUKCWJ5dGVjIDEwIC8vICJpLnNlbGxlci5hIgoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTU4CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfSElHSEVTVF9TT0xEX0FNT1VOVCkudmFsdWUgPSBpdG9iKG9mZmVyQW10KQoJYnl0ZWMgMjYgLy8gImkuaGlnaGVzdFNvbGRBbXQiCglmcmFtZV9kaWcgMCAvLyBvZmZlckFtdDogdWludDY0CglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU1OQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX01JTlRJTkcpLmRlbGV0ZSgpCglieXRlYyAzIC8vICJpLm1pbnRpbmciCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU2MAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1NFTExfQU1PVU5UKS5kZWxldGUoKQoJYnl0ZWMgNiAvLyAiaS5zZWxsYW10IgoJYXBwX2dsb2JhbF9kZWwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1NjIKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUdNRU5UX0NPTU1JU1NJT05fQUdFTlQpLmRlbGV0ZSgpCglieXRlYyA5IC8vICJpLnNlZ21lbnRBZ2VudC5hIgoJYXBwX2dsb2JhbF9kZWwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1NjQKCS8vIHJldHVybiB7CgkvLyAgICAgICAgICAgICBhbW91bnRUb1NlbGxlcjogZ3Jvc3NUb1RyZWFzdXJ5IC0gY29tbWlzc2lvblRvUGF5LAoJLy8gICAgICAgICAgICAgY29tbWlzc2lvbkFkZHJlc3M6IGNvbW1pc3Npb25BZ2VudCwKCS8vICAgICAgICAgICAgIGFtb3VudFRvQ29tbWlzc2lvbjogY29tbWlzc2lvblRvUGF5LAoJLy8gICAgICAgICAgICAgc2VnbWVudFJvb3RPd25lcjogc2VnbWVudFJvb3RPd25lciwKCS8vICAgICAgICAgICAgIGFtb3VudFRvU2VnbWVudFJvb3Q6IHNlZ21lbnRDb21taXNzaW9uVG9QYXksCgkvLyAgICAgICAgIH0KCWZyYW1lX2RpZyAxIC8vIGdyb3NzVG9UcmVhc3VyeTogdWludDY0CglmcmFtZV9kaWcgNCAvLyBjb21taXNzaW9uVG9QYXk6IHVpbnQ2NAoJLQoJaXRvYgoJZnJhbWVfZGlnIDUgLy8gY29tbWlzc2lvbkFnZW50OiBhZGRyZXNzCgljb25jYXQKCWZyYW1lX2RpZyA0IC8vIGNvbW1pc3Npb25Ub1BheTogdWludDY0CglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyA2IC8vIHNlZ21lbnRSb290T3duZXI6IGFkZHJlc3MKCWNvbmNhdAoJZnJhbWVfZGlnIDIgLy8gc2VnbWVudENvbW1pc3Npb25Ub1BheTogdWludDY0CglpdG9iCgljb25jYXQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiA2CglyZXRzdWIKCi8vIHB1cmNoYXNlKHBheSl2b2lkCiphYmlfcm91dGVfcHVyY2hhc2U6CgkvLyBwYXltZW50OiBwYXkKCXR4biBHcm91cEluZGV4CglpbnRjIDEgLy8gMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50YyAxIC8vICBwYXkKCT09CgoJLy8gYXJndW1lbnQgMCAocGF5bWVudCkgZm9yIHB1cmNoYXNlIG11c3QgYmUgYSBwYXkgdHJhbnNhY3Rpb24KCWFzc2VydAoKCS8vIGV4ZWN1dGUgcHVyY2hhc2UocGF5KXZvaWQKCWNhbGxzdWIgcHVyY2hhc2UKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHB1cmNoYXNlKHBheW1lbnQ6IFBheVR4bik6IHZvaWQKcHVyY2hhc2U6Cglwcm90byAxIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiA4CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTc0CgkvLyBhc3NlcnQoIXRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HKS5leGlzdHMpCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglieXRlYyAzIC8vICJpLm1pbnRpbmciCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1NzUKCS8vIGFzc2VydCghdGhpcy5pc0V4cGlyZWQoKSwgImNhbid0IGJlIGV4cGlyZWQiKQoJY2FsbHN1YiBpc0V4cGlyZWQKCSEKCgkvLyBjYW4ndCBiZSBleHBpcmVkCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1NzYKCS8vIGFzc2VydCh0aGlzLmlzRm9yU2FsZSgpLCAnbXVzdCBiZSBmb3Igc2FsZScpCgljYWxsc3ViIGlzRm9yU2FsZQoKCS8vIG11c3QgYmUgZm9yIHNhbGUKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU3NwoJLy8gc2VsbEFtdCA9IHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX1NFTExfQU1PVU5UKQoJYnl0ZWMgNiAvLyAiaS5zZWxsYW10IgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglmcmFtZV9idXJ5IDAgLy8gc2VsbEFtdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTc4CgkvLyByZXNlcnZlZE93bmVyID0gdGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX1JFU0VSVkVEX09XTkVSKQoJYnl0ZWMgOCAvLyAiaS5yZXNlcnZlZE93bmVyLmEiCgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0CglmcmFtZV9idXJ5IDEgLy8gcmVzZXJ2ZWRPd25lcjogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTc5CgkvLyBvZmZlckFtdCA9IHBheW1lbnQuYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gcGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWZyYW1lX2J1cnkgMiAvLyBvZmZlckFtdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTgwCgkvLyBvcmlnT2ZmZXJhbXQgPSBvZmZlckFtdAoJZnJhbWVfZGlnIDIgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJZnJhbWVfYnVyeSAzIC8vIG9yaWdPZmZlcmFtdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTgxCgkvLyBsb2coJ29yaWdfb2ZmZXI6JyArIG9mZmVyQW10LnRvU3RyaW5nKCkpCglwdXNoYnl0ZXMgMHg2ZjcyNjk2NzVmNmY2NjY2NjU3MjNhIC8vICJvcmlnX29mZmVyOiIKCWZyYW1lX2RpZyAyIC8vIG9mZmVyQW10OiB1aW50NjQKCWNhbGxzdWIgKml0b2EKCWNvbmNhdAoJbG9nCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTgzCgkvLyBhc3NlcnQocGF5bWVudC5zZW5kZXIgPT09IHRoaXMudHhuLnNlbmRlciwgJ3BheW1lbnQgc2VuZGVyIG11c3QgYmUgc2FtZSBhcyBwdXJjaGFzZSBjYWxsZXInKQoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCgl0eG4gU2VuZGVyCgk9PQoKCS8vIHBheW1lbnQgc2VuZGVyIG11c3QgYmUgc2FtZSBhcyBwdXJjaGFzZSBjYWxsZXIKCWFzc2VydAoKCS8vICppZjM2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTg1CgkvLyBsZW4ocmVzZXJ2ZWRPd25lcikgPiAwCglmcmFtZV9kaWcgMSAvLyByZXNlcnZlZE93bmVyOiBieXRlW10KCWxlbgoJaW50YyAwIC8vIDAKCT4KCWJ6ICppZjM2X2VuZAoKCS8vICppZjM2X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU4NgoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgIHJlc2VydmVkT3duZXIgPT09IHJhd0J5dGVzKHBheW1lbnQuc2VuZGVyKSwKCS8vICAgICAgICAgICAgICAgICAiUmVzZXJ2ZWQgb3duZXIgc2V0LCBidXQgc2VuZGVyIGlzbid0IHRoZSByZXNlcnZlZCBhZGRyZXNzIiwKCS8vICAgICAgICAgICAgICkKCWZyYW1lX2RpZyAxIC8vIHJlc2VydmVkT3duZXI6IGJ5dGVbXQoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCgk9PQoKCS8vIFJlc2VydmVkIG93bmVyIHNldCwgYnV0IHNlbmRlciBpc24ndCB0aGUgcmVzZXJ2ZWQgYWRkcmVzcwoJYXNzZXJ0CgoqaWYzNl9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1OTQKCS8vIHJlc2VydmVkT3duZXIgPSByYXdCeXRlcyhwYXltZW50LnNlbmRlcikKCWZyYW1lX2RpZyAtMSAvLyBwYXltZW50OiBQYXlUeG4KCWd0eG5zIFNlbmRlcgoJZnJhbWVfYnVyeSAxIC8vIHJlc2VydmVkT3duZXI6IGJ5dGVbXQoKCS8vICppZjM3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTk5CgkvLyB0aGlzLnNhZmVHbG9iYWxCeXRlR2V0KE5GRF9LRVlfTUlOVElOR19LSUNLT0ZGX0NSRUFUT1IpID09PSByYXdCeXRlcyhwYXltZW50LnNlbmRlcikKCWJ5dGVjIDEyIC8vICJpLm1pbnRpbmdLaWNrb2ZmQ3JlYXRvci5hIgoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldAoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCgk9PQoJYnogKmlmMzdfZW5kCgoJLy8gKmlmMzdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjAwCgkvLyBvZmZlckFtdCArPSB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9NSU5USU5HX0tJQ0tPRkZfQU1PVU5UKQoJZnJhbWVfZGlnIDIgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJYnl0ZWMgMTMgLy8gImkubWludGluZ0tpY2tvZmZBbW91bnQiCgljYWxsc3ViIHNhZmVHbG9iYWxJbnRHZXQKCSsKCWZyYW1lX2J1cnkgMiAvLyBvZmZlckFtdDogdWludDY0CgoqaWYzN19lbmQ6CgkvLyAqaWYzOF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjYwMwoJLy8gbGVuKHRoaXMuc2FmZUdsb2JhbEJ5dGVHZXQoTkZEX0tFWV9DT01NSVNTSU9OMV9BR0VOVCkpID4gMAoJYnl0ZWMgNSAvLyAiaS5jb21taXNzaW9uMUFnZW50LmEiCgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0CglsZW4KCWludGMgMCAvLyAwCgk+CglieiAqaWYzOF9lbmQKCgkvLyAqaWYzOF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MDQKCS8vIGFzc2VydChvZmZlckFtdCA+IE5GRF9NSU5fU0VMTEFNT1VOVF9XX0NPTU1JU1NJT05TLCAnb2ZmZXIgbXVzdCBiZSBhdCBsZWFzdCBtaW4gYW1vdW50JykKCWZyYW1lX2RpZyAyIC8vIG9mZmVyQW10OiB1aW50NjQKCWludGMgMTUgLy8gMTAwMDAwMAoJPgoKCS8vIG9mZmVyIG11c3QgYmUgYXQgbGVhc3QgbWluIGFtb3VudAoJYXNzZXJ0CgoqaWYzOF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MDcKCS8vIGFzc2VydChvZmZlckFtdCA+PSBzZWxsQW10LCAnb2ZmZXIgbXVzdCBiZSBhdCBsZWFzdCBzZWxsIGFtb3VudCcpCglmcmFtZV9kaWcgMiAvLyBvZmZlckFtdDogdWludDY0CglmcmFtZV9kaWcgMCAvLyBzZWxsQW10OiB1aW50NjQKCT49CgoJLy8gb2ZmZXIgbXVzdCBiZSBhdCBsZWFzdCBzZWxsIGFtb3VudAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjEwCgkvLyByZWZ1bmRBbXQgPSBvZmZlckFtdCAtIHNlbGxBbXQKCWZyYW1lX2RpZyAyIC8vIG9mZmVyQW10OiB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIHNlbGxBbXQ6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSA0IC8vIHJlZnVuZEFtdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjExCgkvLyBvZmZlckFtdCAtPSByZWZ1bmRBbXQKCWZyYW1lX2RpZyAyIC8vIG9mZmVyQW10OiB1aW50NjQKCWZyYW1lX2RpZyA0IC8vIHJlZnVuZEFtdDogdWludDY0CgktCglmcmFtZV9idXJ5IDIgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjYxNAoJLy8gdmVyaWZ5UGF5VHhuKHBheW1lbnQsIHsgYW1vdW50OiBvcmlnT2ZmZXJhbXQsIHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzIH0pCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gcGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWZyYW1lX2RpZyAzIC8vIG9yaWdPZmZlcmFtdDogdWludDY0Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoicGF5bWVudCIsImZpZWxkIjoiYW1vdW50IiwiZXhwZWN0ZWQiOiJvcmlnT2ZmZXJhbXQifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gcGF5bWVudDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJwYXltZW50IiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MTcKCS8vIGNvbW1pc3Npb25Ub1BheSA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDUgLy8gY29tbWlzc2lvblRvUGF5OiB1aW50NjQKCgkvLyAqaWYzOV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjYxOAoJLy8gdGhpcy5zYWZlR2xvYmFsSW50R2V0KE5GRF9LRVlfQ09NTUlTU0lPTjEpID09PSAwCglieXRlYyA3IC8vICJpLmNvbW1pc3Npb24xIgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjM5X2Vsc2UKCgkvLyAqaWYzOV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MjAKCS8vIGNvbW1pc3Npb25Ub1BheSA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDUgLy8gY29tbWlzc2lvblRvUGF5OiB1aW50NjQKCWIgKmlmMzlfZW5kCgoqaWYzOV9lbHNlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjI0CgkvLyBjb21taXNzaW9uVG9QYXkgPSAob2ZmZXJBbXQgKiB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9DT01NSVNTSU9OMSkpIC8gMTAwMAoJZnJhbWVfZGlnIDIgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJYnl0ZWMgNyAvLyAiaS5jb21taXNzaW9uMSIKCWNhbGxzdWIgc2FmZUdsb2JhbEludEdldAoJKgoJaW50YyAxOCAvLyAxMDAwCgkvCglmcmFtZV9idXJ5IDUgLy8gY29tbWlzc2lvblRvUGF5OiB1aW50NjQKCippZjM5X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjYyNwoJLy8gY29udkZlZUFkZHIgPSBnbG9iYWxzLnplcm9BZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCWZyYW1lX2J1cnkgNiAvLyBjb252RmVlQWRkcjogYWRkcmVzcwoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjYyOAoJLy8gY29udkZlZSA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDcgLy8gY29udkZlZTogdWludDY0CgoJLy8gKmlmNDBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MjkKCS8vIHRoaXMudHhuLmdyb3VwSW5kZXggPj0gMgoJdHhuIEdyb3VwSW5kZXgKCWludGMgMiAvLyAyCgk+PQoJYnogKmlmNDBfZW5kCgoJLy8gKmlmNDBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjMwCgkvLyBjb252RmVlVHhuID0gdGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4IC0gMl0KCXR4biBHcm91cEluZGV4CglpbnRjIDIgLy8gMgoJLQoJZnJhbWVfYnVyeSA4IC8vIGNvbnZGZWVUeG46IHR4bgoKCS8vICppZjQxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjMyCgkvLyBjb252RmVlVHhuLnR5cGVFbnVtID09PSBUcmFuc2FjdGlvblR5cGUuUGF5bWVudCAmJgoJLy8gICAgICAgICAgICAgICAgIGNvbnZGZWVUeG4uc2VuZGVyID09PSB0aGlzLnR4bi5zZW5kZXIgJiYKCS8vICAgICAgICAgICAgICAgICBjb252RmVlVHhuLm5vdGUgPT09ICdjb252LiBmZWUnCglmcmFtZV9kaWcgOCAvLyBjb252RmVlVHhuOiB0eG4KCWd0eG5zIFR5cGVFbnVtCglpbnRjIDEgLy8gIHBheQoJPT0KCWR1cAoJYnogKnNraXBfYW5kMTIKCWZyYW1lX2RpZyA4IC8vIGNvbnZGZWVUeG46IHR4bgoJZ3R4bnMgU2VuZGVyCgl0eG4gU2VuZGVyCgk9PQoJJiYKCipza2lwX2FuZDEyOgoJZHVwCglieiAqc2tpcF9hbmQxMwoJZnJhbWVfZGlnIDggLy8gY29udkZlZVR4bjogdHhuCglndHhucyBOb3RlCglwdXNoYnl0ZXMgMHg2MzZmNmU3NjJlMjA2NjY1NjUgLy8gImNvbnYuIGZlZSIKCT09CgkmJgoKKnNraXBfYW5kMTM6CglieiAqaWY0MV9lbmQKCgkvLyAqaWY0MV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MzYKCS8vIGNvbnZGZWVBZGRyID0gY29udkZlZVR4bi5yZWNlaXZlcgoJZnJhbWVfZGlnIDggLy8gY29udkZlZVR4bjogdHhuCglndHhucyBSZWNlaXZlcgoJZnJhbWVfYnVyeSA2IC8vIGNvbnZGZWVBZGRyOiBhZGRyZXNzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjM3CgkvLyBjb252RmVlID0gY29udkZlZVR4bi5hbW91bnQKCWZyYW1lX2RpZyA4IC8vIGNvbnZGZWVUeG46IHR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9idXJ5IDcgLy8gY29udkZlZTogdWludDY0CgoqaWY0MV9lbmQ6CgoqaWY0MF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NDEKCS8vIHNlbmRNZXRob2RDYWxsPHR5cGVvZiBORkRSZWdpc3RyeS5wcm90b3R5cGUub3duZXJzaGlwQ2hhbmdlZD4oewoJLy8gICAgICAgICAgICAgYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnJlZ2lzdHJ5QXBwSWQpLAoJLy8gICAgICAgICAgICAgbWV0aG9kQXJnczogWwoJLy8gICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9OQU1FKS52YWx1ZSwKCS8vICAgICAgICAgICAgICAgICB0aGlzLmFwcC5pZCwKCS8vICAgICAgICAgICAgICAgICBBZGRyZXNzLmZyb21CeXRlcyh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlKSwKCS8vICAgICAgICAgICAgICAgICBBZGRyZXNzLmZyb21CeXRlcyhyZXNlcnZlZE93bmVyKSwKCS8vICAgICAgICAgICAgIF0sCgkvLyAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDcgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCXB1c2hieXRlcyAweGYyMmM1N2YyIC8vIG1ldGhvZCAib3duZXJzaGlwQ2hhbmdlZChzdHJpbmcsdWludDY0LGFkZHJlc3MsYWRkcmVzcyl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NDIKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKQoJaW50YyA0IC8vIFRNUExfcmVnaXN0cnlBcHBJZAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjQzCgkvLyBtZXRob2RBcmdzOiBbCgkvLyAgICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLAoJLy8gICAgICAgICAgICAgICAgIHRoaXMuYXBwLmlkLAoJLy8gICAgICAgICAgICAgICAgIEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUpLAoJLy8gICAgICAgICAgICAgICAgIEFkZHJlc3MuZnJvbUJ5dGVzKHJlc2VydmVkT3duZXIpLAoJLy8gICAgICAgICAgICAgXQoJYnl0ZWMgNCAvLyAiaS5uYW1lIgoJYXBwX2dsb2JhbF9nZXQKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWJ5dGVjIDEgLy8gImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDEgLy8gcmVzZXJ2ZWRPd25lcjogYnl0ZVtdCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NTEKCS8vIHRoaXMubmZkX3B1cmNoYXNlZC5sb2coewoJLy8gICAgICAgICAgICAgYXBwSWQ6IHRoaXMuYXBwLmlkLAoJLy8gICAgICAgICAgICAgbmFtZTogdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLAoJLy8gICAgICAgICAgICAgc2VsbGVyOiBBZGRyZXNzLmZyb21CeXRlcyh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlKSwKCS8vICAgICAgICAgICAgIGJ1eWVyOiBBZGRyZXNzLmZyb21CeXRlcyhyZXNlcnZlZE93bmVyKSwKCS8vICAgICAgICAgICAgIHNlbGxBbW91bnQ6IHNlbGxBbXQsCgkvLyAgICAgICAgICAgICBvZmZlckFtb3VudDogb2ZmZXJBbXQsCgkvLyAgICAgICAgICAgICBvdmVycGF5bWVudFJlZnVuZDogcmVmdW5kQW10LAoJLy8gICAgICAgICAgICAgY29udkZlZUFkZHI6IGNvbnZGZWVBZGRyLAoJLy8gICAgICAgICAgICAgY29udkZlZUFtb3VudDogY29udkZlZSwKCS8vICAgICAgICAgfSkKCXB1c2hieXRlcyAweDc4ZGM4OWUzIC8vIG5mZF9wdXJjaGFzZWQodWludDY0LHN0cmluZyxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQpCglieXRlYyAwIC8vICBpbml0aWFsIGhlYWQKCWJ5dGVjIDAgLy8gIGluaXRpYWwgdGFpbAoJcHVzaGJ5dGVzIDB4MDA4YSAvLyBpbml0aWFsIGhlYWQgb2Zmc2V0Cgl0eG5hIEFwcGxpY2F0aW9ucyAwCglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglieXRlYyA0IC8vICJpLm5hbWUiCglhcHBfZ2xvYmFsX2dldAoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNhbGxzdWIgKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50CglieXRlYyAxIC8vICJpLm93bmVyLmEiCglhcHBfZ2xvYmFsX2dldAoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDEgLy8gcmVzZXJ2ZWRPd25lcjogYnl0ZVtdCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgMCAvLyBzZWxsQW10OiB1aW50NjQKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAyIC8vIG9mZmVyQW10OiB1aW50NjQKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyA0IC8vIHJlZnVuZEFtdDogdWludDY0CglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgNiAvLyBjb252RmVlQWRkcjogYWRkcmVzcwoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDcgLy8gY29udkZlZTogdWludDY0CglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50Cglwb3AgLy8gcG9wIGhlYWQgb2Zmc2V0Cgljb25jYXQgLy8gY29uY2F0IGhlYWQgYW5kIHRhaWwKCWNvbmNhdAoJbG9nCgoJLy8gKmlmNDJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NjQKCS8vIHJlZnVuZEFtdCA+IDAKCWZyYW1lX2RpZyA0IC8vIHJlZnVuZEFtdDogdWludDY0CglpbnRjIDAgLy8gMAoJPgoJYnogKmlmNDJfZW5kCgoJLy8gKmlmNDJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjY1CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgICAgICAgICAgYW1vdW50OiByZWZ1bmRBbXQsCgkvLyAgICAgICAgICAgICAgICAgcmVjZWl2ZXI6IHBheW1lbnQuc2VuZGVyLAoJLy8gICAgICAgICAgICAgICAgIG5vdGU6ICdvdmVycGF5bWVudFJlZnVuZCcsCgkvLyAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NjYKCS8vIGFtb3VudDogcmVmdW5kQW10CglmcmFtZV9kaWcgNCAvLyByZWZ1bmRBbXQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NjcKCS8vIHJlY2VpdmVyOiBwYXltZW50LnNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjY4CgkvLyBub3RlOiAnb3ZlcnBheW1lbnRSZWZ1bmQnCglwdXNoYnl0ZXMgMHg2Zjc2NjU3MjcwNjE3OTZkNjU2ZTc0NTI2NTY2NzU2ZTY0IC8vICJvdmVycGF5bWVudFJlZnVuZCIKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCippZjQyX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjY3MQoJLy8gdGhpcy5kb1BheW91dHMoCgkvLyAgICAgICAgICAgICBvZmZlckFtdCwKCS8vICAgICAgICAgICAgIEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUxMRVIpLnZhbHVlKSwKCS8vICAgICAgICAgICAgIGNvbW1pc3Npb25Ub1BheSwKCS8vICAgICAgICAgICAgIDAsCgkvLyAgICAgICAgICAgICBnbG9iYWxzLnplcm9BZGRyZXNzLAoJLy8gICAgICAgICApCglnbG9iYWwgWmVyb0FkZHJlc3MKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgNSAvLyBjb21taXNzaW9uVG9QYXk6IHVpbnQ2NAoJYnl0ZWMgMTAgLy8gImkuc2VsbGVyLmEiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDIgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJY2FsbHN1YiBkb1BheW91dHMKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NzkKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludGMgNyAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCglieXRlYyAxNCAvLyAgI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50YyAxMyAvLyAgRGVsZXRlQXBwbGljYXRpb24KCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCglpdHhuX3N1Ym1pdAoKCS8vICppZjQzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Njg0CgkvLyBsZW4odGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX01JTlRJTkdfS0lDS09GRl9DUkVBVE9SKSkgIT09IDAKCWJ5dGVjIDEyIC8vICJpLm1pbnRpbmdLaWNrb2ZmQ3JlYXRvci5hIgoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldAoJbGVuCglpbnRjIDAgLy8gMAoJIT0KCWJ6ICppZjQzX2VuZAoKCS8vICppZjQzX2NvbnNlcXVlbnQKCS8vICppZjQ0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Njg2CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTUlOVElOR19LSUNLT0ZGX0NSRUFUT1IpLnZhbHVlICE9PSByYXdCeXRlcyhwYXltZW50LnNlbmRlcikgJiYKCS8vICAgICAgICAgICAgICAgICBsZW4odGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX01JTlRJTkcpKSA9PT0gMAoJYnl0ZWMgMTIgLy8gImkubWludGluZ0tpY2tvZmZDcmVhdG9yLmEiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCgkhPQoJZHVwCglieiAqc2tpcF9hbmQxNAoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldAoJbGVuCglpbnRjIDAgLy8gMAoJPT0KCSYmCgoqc2tpcF9hbmQxNDoKCWJ6ICppZjQ0X2VuZAoKCS8vICppZjQ0X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjY4OQoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX01JTlRJTkdfS0lDS09GRl9BTU9VTlQpLAoJLy8gICAgICAgICAgICAgICAgICAgICByZWNlaXZlcjogQWRkcmVzcy5mcm9tQnl0ZXModGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX01JTlRJTkdfS0lDS09GRl9DUkVBVE9SKS52YWx1ZSksCgkvLyAgICAgICAgICAgICAgICAgICAgIG5vdGU6ICdlc2Nyb3dSZWZ1bmQnLAoJLy8gICAgICAgICAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDEgLy8gIHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjY5MAoJLy8gYW1vdW50OiB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9NSU5USU5HX0tJQ0tPRkZfQU1PVU5UKQoJYnl0ZWMgMTMgLy8gImkubWludGluZ0tpY2tvZmZBbW91bnQiCgljYWxsc3ViIHNhZmVHbG9iYWxJbnRHZXQKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjkxCgkvLyByZWNlaXZlcjogQWRkcmVzcy5mcm9tQnl0ZXModGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX01JTlRJTkdfS0lDS09GRl9DUkVBVE9SKS52YWx1ZSkKCWJ5dGVjIDEyIC8vICJpLm1pbnRpbmdLaWNrb2ZmQ3JlYXRvci5hIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2OTIKCS8vIG5vdGU6ICdlc2Nyb3dSZWZ1bmQnCglwdXNoYnl0ZXMgMHg2NTczNjM3MjZmNzc1MjY1NjY3NTZlNjQgLy8gImVzY3Jvd1JlZnVuZCIKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCippZjQ0X2VuZDoKCippZjQzX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjY5OAoJLy8gdGhpcy5jbGF3QXNhRnJvbVRvKEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUpLCB0aGlzLmFwcC5hZGRyZXNzKQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWJ5dGVjIDEgLy8gImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0CgljYWxsc3ViIGNsYXdBc2FGcm9tVG8KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MTEKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUgPSByZXNlcnZlZE93bmVyCglieXRlYyAxIC8vICJpLm93bmVyLmEiCglmcmFtZV9kaWcgMSAvLyByZXNlcnZlZE93bmVyOiBieXRlW10KCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NzEyCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfU0VMTEVSKS52YWx1ZSA9IHJlc2VydmVkT3duZXIKCWJ5dGVjIDEwIC8vICJpLnNlbGxlci5hIgoJZnJhbWVfZGlnIDEgLy8gcmVzZXJ2ZWRPd25lcjogYnl0ZVtdCglhcHBfZ2xvYmFsX3B1dAoKCS8vICppZjQ1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NzEzCgkvLyBvZmZlckFtdCA+IHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX0hJR0hFU1RfU09MRF9BTU9VTlQpCglmcmFtZV9kaWcgMiAvLyBvZmZlckFtdDogdWludDY0CglieXRlYyAyNiAvLyAiaS5oaWdoZXN0U29sZEFtdCIKCWNhbGxzdWIgc2FmZUdsb2JhbEludEdldAoJPgoJYnogKmlmNDVfZW5kCgoJLy8gKmlmNDVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NzE0CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfSElHSEVTVF9TT0xEX0FNT1VOVCkudmFsdWUgPSBpdG9iKG9mZmVyQW10KQoJYnl0ZWMgMjYgLy8gImkuaGlnaGVzdFNvbGRBbXQiCglmcmFtZV9kaWcgMiAvLyBvZmZlckFtdDogdWludDY0CglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKKmlmNDVfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NzE2CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjcxNwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1RJTUVQVVJDSEFTRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDM0IC8vICJpLnRpbWVQdXJjaGFzZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjcxOAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX01JTlRJTkcpLmRlbGV0ZSgpCglieXRlYyAzIC8vICJpLm1pbnRpbmciCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjcxOQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1JFU0VSVkVEX09XTkVSKS5kZWxldGUoKQoJYnl0ZWMgOCAvLyAiaS5yZXNlcnZlZE93bmVyLmEiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjcyMAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1NFTExfQU1PVU5UKS5kZWxldGUoKQoJYnl0ZWMgNiAvLyAiaS5zZWxsYW10IgoJYXBwX2dsb2JhbF9kZWwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MjEKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HX0tJQ0tPRkZfQ1JFQVRPUikuZGVsZXRlKCkKCWJ5dGVjIDEyIC8vICJpLm1pbnRpbmdLaWNrb2ZmQ3JlYXRvci5hIgoJYXBwX2dsb2JhbF9kZWwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MjIKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HX0tJQ0tPRkZfQU1PVU5UKS5kZWxldGUoKQoJYnl0ZWMgMTMgLy8gImkubWludGluZ0tpY2tvZmZBbW91bnQiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjcyMwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1NFR01FTlRfQ09NTUlTU0lPTl9BR0VOVCkuZGVsZXRlKCkKCWJ5dGVjIDkgLy8gImkuc2VnbWVudEFnZW50LmEiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjcyNQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0lTVkFVTFRPUFRJTkxPQ0tFRCkudmFsdWUgPSBORkRfTE9DS0VEX1ZBTF9GQUxTRQoJYnl0ZWMgMjAgLy8gImkudmF1bHRPcHRJbkxvY2tlZCIKCWJ5dGVjIDI0IC8vICIwIgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MjYKCS8vIGxvZyhpdG9iKG9mZmVyQW10KSkKCWZyYW1lX2RpZyAyIC8vIG9mZmVyQW10OiB1aW50NjQKCWl0b2IKCWxvZwoJcmV0c3ViCgovLyBpc0FkZHJlc3NJbkZpZWxkKHN0cmluZyxhZGRyZXNzKWJvb2wKKmFiaV9yb3V0ZV9pc0FkZHJlc3NJbkZpZWxkOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAxMSAvLyAweDE1MWY3Yzc1CgoJLy8gYWRkcmVzczogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMyAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChhZGRyZXNzKSBmb3IgaXNBZGRyZXNzSW5GaWVsZCBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZmllbGROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBpc0FkZHJlc3NJbkZpZWxkKHN0cmluZyxhZGRyZXNzKWJvb2wKCWNhbGxzdWIgaXNBZGRyZXNzSW5GaWVsZAoJYnl0ZWMgMjkgLy8gMHgwMAoJaW50YyAwIC8vIDAKCXVuY292ZXIgMgoJc2V0Yml0Cgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gaXNBZGRyZXNzSW5GaWVsZChmaWVsZE5hbWU6IHN0cmluZywgYWRkcmVzczogQWRkcmVzcyk6IGJvb2xlYW4KaXNBZGRyZXNzSW5GaWVsZDoKCXByb3RvIDIgMQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjczMQoJLy8gYXNzZXJ0KGFkZHJlc3MgIT09IGdsb2JhbHMuemVyb0FkZHJlc3MpCglmcmFtZV9kaWcgLTIgLy8gYWRkcmVzczogQWRkcmVzcwoJZ2xvYmFsIFplcm9BZGRyZXNzCgkhPQoJYXNzZXJ0CgoJLy8gKmlmNDZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MzIKCS8vICF0aGlzLmJveGVzKGZpZWxkTmFtZSkuZXhpc3RzCglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBzdHJpbmcKCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYnogKmlmNDZfZW5kCgoJLy8gKmlmNDZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NzMzCgkvLyByZXR1cm4gZmFsc2UKCWludGMgMCAvLyAwCglyZXRzdWIKCippZjQ2X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjczNQoJLy8gcmV0dXJuIHRoaXMuZmluZEFkZHJJbkJ5dGVzKHRoaXMuYm94ZXMoZmllbGROYW1lKS52YWx1ZSwgYWRkcmVzcykKCWZyYW1lX2RpZyAtMiAvLyBhZGRyZXNzOiBBZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBzdHJpbmcKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoZmllbGROYW1lKS52YWx1ZQoJYXNzZXJ0CgljYWxsc3ViIGZpbmRBZGRySW5CeXRlcwoJcmV0c3ViCgovLyBkb1BheW91dHMoZ3Jvc3NUb1NlbGxlcjogdWludDY0LCBzZWxsZXJBZGRyZXNzOiBBZGRyZXNzLCBjb21taXNzaW9uVG9QYXk6IHVpbnQ2NCwgc2VnbWVudENvbW1pc3Npb25Ub1BheTogdWludDY0LCBzZWdtZW50Q29tbWlzc2lvbkFkZHJlc3M6IEFkZHJlc3MpOiB2b2lkCmRvUGF5b3V0czoKCXByb3RvIDUgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODA2CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgICAgICBhbW91bnQ6IGdyb3NzVG9TZWxsZXIgLSBjb21taXNzaW9uVG9QYXksCgkvLyAgICAgICAgICAgICByZWNlaXZlcjogc2VsbGVyQWRkcmVzcywKCS8vICAgICAgICAgICAgIG5vdGU6ICdzZWxsZXInLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4MDcKCS8vIGFtb3VudDogZ3Jvc3NUb1NlbGxlciAtIGNvbW1pc3Npb25Ub1BheQoJZnJhbWVfZGlnIC0xIC8vIGdyb3NzVG9TZWxsZXI6IHVpbnQ2NAoJZnJhbWVfZGlnIC0zIC8vIGNvbW1pc3Npb25Ub1BheTogdWludDY0CgktCglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgwOAoJLy8gcmVjZWl2ZXI6IHNlbGxlckFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyBzZWxsZXJBZGRyZXNzOiBBZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODA5CgkvLyBub3RlOiAnc2VsbGVyJwoJcHVzaGJ5dGVzIDB4NzM2NTZjNmM2NTcyIC8vICJzZWxsZXIiCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODExCgkvLyBjb21taXNzaW9uQWRkcmVzcyA9IGdsb2JhbHMuemVyb0FkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJZnJhbWVfYnVyeSAwIC8vIGNvbW1pc3Npb25BZGRyZXNzOiBhZGRyZXNzCgoJLy8gKmlmNDdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4MTQKCS8vIGxlbih0aGlzLnNhZmVHbG9iYWxCeXRlR2V0KE5GRF9LRVlfQ09NTUlTU0lPTjFfQUdFTlQpKSAhPT0gMAoJYnl0ZWMgNSAvLyAiaS5jb21taXNzaW9uMUFnZW50LmEiCgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0CglsZW4KCWludGMgMCAvLyAwCgkhPQoJYnogKmlmNDdfZW5kCgoJLy8gKmlmNDdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODE1CgkvLyBjb21taXNzaW9uQWRkcmVzcyA9IEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9DT01NSVNTSU9OMV9BR0VOVCkudmFsdWUpCglieXRlYyA1IC8vICJpLmNvbW1pc3Npb24xQWdlbnQuYSIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDAgLy8gY29tbWlzc2lvbkFkZHJlc3M6IGFkZHJlc3MKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4MTYKCS8vIHNlbmRQYXltZW50KHsKCS8vICAgICAgICAgICAgICAgICBhbW91bnQ6IGNvbW1pc3Npb25Ub1BheSwKCS8vICAgICAgICAgICAgICAgICByZWNlaXZlcjogY29tbWlzc2lvbkFkZHJlc3MsCgkvLyAgICAgICAgICAgICAgICAgbm90ZTogJ2NvbW1pc3Npb24nLAoJLy8gICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODE3CgkvLyBhbW91bnQ6IGNvbW1pc3Npb25Ub1BheQoJZnJhbWVfZGlnIC0zIC8vIGNvbW1pc3Npb25Ub1BheTogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgxOAoJLy8gcmVjZWl2ZXI6IGNvbW1pc3Npb25BZGRyZXNzCglmcmFtZV9kaWcgMCAvLyBjb21taXNzaW9uQWRkcmVzczogYWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgxOQoJLy8gbm90ZTogJ2NvbW1pc3Npb24nCglwdXNoYnl0ZXMgMHg2MzZmNmQ2ZDY5NzM3MzY5NmY2ZSAvLyAiY29tbWlzc2lvbiIKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyAqaWY0OF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgyNQoJLy8gbGVuKHRoaXMuc2FmZUdsb2JhbEJ5dGVHZXQoTkZEX0tFWV9DT01NSVNTSU9OMl9BR0VOVCkpID09PSAwCglieXRlYyAxNiAvLyAiaS5jb21taXNzaW9uMkFnZW50LmEiCgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0CglsZW4KCWludGMgMCAvLyAwCgk9PQoJYnogKmlmNDhfZWxzZQoKCS8vICppZjQ4X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgyNgoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xX0FHRU5UKS5kZWxldGUoKQoJYnl0ZWMgNSAvLyAiaS5jb21taXNzaW9uMUFnZW50LmEiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgyNwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xKS5kZWxldGUoKQoJYnl0ZWMgNyAvLyAiaS5jb21taXNzaW9uMSIKCWFwcF9nbG9iYWxfZGVsCgliICppZjQ4X2VuZAoKKmlmNDhfZWxzZToKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgyOQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xX0FHRU5UKS52YWx1ZSA9IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9DT01NSVNTSU9OMl9BR0VOVCkudmFsdWUKCWJ5dGVjIDUgLy8gImkuY29tbWlzc2lvbjFBZ2VudC5hIgoJYnl0ZWMgMTYgLy8gImkuY29tbWlzc2lvbjJBZ2VudC5hIgoJYXBwX2dsb2JhbF9nZXQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODMwCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQ09NTUlTU0lPTjEpLnZhbHVlID0gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04yKS52YWx1ZQoJYnl0ZWMgNyAvLyAiaS5jb21taXNzaW9uMSIKCWJ5dGVjIDIyIC8vICJpLmNvbW1pc3Npb24yIgoJYXBwX2dsb2JhbF9nZXQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODMxCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQ09NTUlTU0lPTjJfQUdFTlQpLmRlbGV0ZSgpCglieXRlYyAxNiAvLyAiaS5jb21taXNzaW9uMkFnZW50LmEiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgzMgoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04yKS5kZWxldGUoKQoJYnl0ZWMgMjIgLy8gImkuY29tbWlzc2lvbjIiCglhcHBfZ2xvYmFsX2RlbAoKKmlmNDhfZW5kOgoKKmlmNDdfZW5kOgoJLy8gKmlmNDlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4MzgKCS8vIHNlZ21lbnRDb21taXNzaW9uVG9QYXkgIT09IDAKCWZyYW1lX2RpZyAtNCAvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5OiB1aW50NjQKCWludGMgMCAvLyAwCgkhPQoJYnogKmlmNDlfZW5kCgoJLy8gKmlmNDlfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODM5CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgICAgICAgICAgYW1vdW50OiBzZWdtZW50Q29tbWlzc2lvblRvUGF5LAoJLy8gICAgICAgICAgICAgICAgIHJlY2VpdmVyOiBzZWdtZW50Q29tbWlzc2lvbkFkZHJlc3MsCgkvLyAgICAgICAgICAgICAgICAgbm90ZTogJ3NlZ21lbnQnLAoJLy8gICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODQwCgkvLyBhbW91bnQ6IHNlZ21lbnRDb21taXNzaW9uVG9QYXkKCWZyYW1lX2RpZyAtNCAvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5OiB1aW50NjQKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODQxCgkvLyByZWNlaXZlcjogc2VnbWVudENvbW1pc3Npb25BZGRyZXNzCglmcmFtZV9kaWcgLTUgLy8gc2VnbWVudENvbW1pc3Npb25BZGRyZXNzOiBBZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODQyCgkvLyBub3RlOiAnc2VnbWVudCcKCXB1c2hieXRlcyAweDczNjU2NzZkNjU2ZTc0IC8vICJzZWdtZW50IgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmNDlfZW5kOgoJcmV0c3ViCgovLyBnZXRSZW5ld1ByaWNlKCl1aW50NjQKKmFiaV9yb3V0ZV9nZXRSZW5ld1ByaWNlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAxMSAvLyAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBnZXRSZW5ld1ByaWNlKCl1aW50NjQKCWNhbGxzdWIgZ2V0UmVuZXdQcmljZQoJaXRvYgoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdldFJlbmV3UHJpY2UoKTogdWludDY0CmdldFJlbmV3UHJpY2U6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NTAKCS8vIHJldHVybiB0aGlzLmdldFJlbmV3UHJpY2VEYXRhKHRoaXMudHhuLnNlbmRlcikub25lWWVhclByaWNlCgl0eG4gU2VuZGVyCgljYWxsc3ViIGdldFJlbmV3UHJpY2VEYXRhCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAwIDgKCWJ0b2kKCXJldHN1YgoKLy8gdXBkYXRlSGFzaChieXRlW10pdm9pZAoqYWJpX3JvdXRlX3VwZGF0ZUhhc2g6CgkvLyBoYXNoOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSB1cGRhdGVIYXNoKGJ5dGVbXSl2b2lkCgljYWxsc3ViIHVwZGF0ZUhhc2gKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHVwZGF0ZUhhc2goaGFzaDogYnl0ZXMpOiB2b2lkCnVwZGF0ZUhhc2g6Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NTYKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIGxlbihoYXNoKSA9PT0gMzIgJiYgQWRkcmVzcy5mcm9tQnl0ZXMoaGFzaCkgIT09IGdsb2JhbHMuemVyb0FkZHJlc3MsCgkvLyAgICAgICAgICAgICAibXVzdCBwYXNzIDMyLWJ5dGUgaGFzaCB0aGF0IGlzbid0IDAiLAoJLy8gICAgICAgICApCglmcmFtZV9kaWcgLTEgLy8gaGFzaDogYnl0ZXMKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoJZHVwCglieiAqc2tpcF9hbmQxNQoJZnJhbWVfZGlnIC0xIC8vIGhhc2g6IGJ5dGVzCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9CgkmJgoKKnNraXBfYW5kMTU6CgkvLyBtdXN0IHBhc3MgMzItYnl0ZSBoYXNoIHRoYXQgaXNuJ3QgMAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODYxCgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICByYXdCeXRlcyh0aGlzLnR4bi5zZW5kZXIpID09PSB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlIHx8IHRoaXMuaXNDdXJyZW50VHhuQ29udHJhY3RBdXRob3JpdHkoKSwKCS8vICAgICAgICAgICAgICdvbmx5IHR4bmxhYiBvciBvd25lciBjYW4gcmVxdWVzdCBhbiBuZmQgbmZ0IGhhc2ggdXBkYXRlJywKCS8vICAgICAgICAgKQoJdHhuIFNlbmRlcgoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXQKCT09CglkdXAKCWJueiAqc2tpcF9vcjEKCWNhbGxzdWIgaXNDdXJyZW50VHhuQ29udHJhY3RBdXRob3JpdHkKCXx8Cgoqc2tpcF9vcjE6CgkvLyBvbmx5IHR4bmxhYiBvciBvd25lciBjYW4gcmVxdWVzdCBhbiBuZmQgbmZ0IGhhc2ggdXBkYXRlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NjUKCS8vIHNlbmRBc3NldENvbmZpZyh7CgkvLyAgICAgICAgICAgICBjb25maWdBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KGJ0b2kodGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0FTQUlEKS52YWx1ZSkpLAoJLy8gICAgICAgICAgICAgY29uZmlnQXNzZXRNYW5hZ2VyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICAgICAgY29uZmlnQXNzZXRSZXNlcnZlOiBBZGRyZXNzLmZyb21CeXRlcyhoYXNoKSwKCS8vICAgICAgICAgICAgIGNvbmZpZ0Fzc2V0Q2xhd2JhY2s6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDYgLy8gIGFjZmcKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NjYKCS8vIGNvbmZpZ0Fzc2V0OiBBc3NldElELmZyb21VaW50NjQoYnRvaSh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQVNBSUQpLnZhbHVlKSkKCWJ5dGVjIDE4IC8vICJpLmFzYWlkIgoJYXBwX2dsb2JhbF9nZXQKCWJ0b2kKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NjcKCS8vIGNvbmZpZ0Fzc2V0TWFuYWdlcjogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRNYW5hZ2VyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODY4CgkvLyBjb25maWdBc3NldFJlc2VydmU6IEFkZHJlc3MuZnJvbUJ5dGVzKGhhc2gpCglmcmFtZV9kaWcgLTEgLy8gaGFzaDogYnl0ZXMKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRSZXNlcnZlCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODY5CgkvLyBjb25maWdBc3NldENsYXdiYWNrOiB0aGlzLmFwcC5hZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBDb25maWdBc3NldENsYXdiYWNrCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBjb250cmFjdExvY2soYm9vbCl2b2lkCiphYmlfcm91dGVfY29udHJhY3RMb2NrOgoJLy8gbG9jazogYm9vbAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgMSAvLyAxCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGxvY2spIGZvciBjb250cmFjdExvY2sgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIGV4ZWN1dGUgY29udHJhY3RMb2NrKGJvb2wpdm9pZAoJY2FsbHN1YiBjb250cmFjdExvY2sKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGNvbnRyYWN0TG9jayhsb2NrOiBib29sZWFuKTogdm9pZApjb250cmFjdExvY2s6Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NzcKCS8vIHRoaXMuYXNzZXJ0T3duZXJDYWxsZWROb3RGb3JTYWxlT3JFeHBpcmVkKCkKCWNhbGxzdWIgYXNzZXJ0T3duZXJDYWxsZWROb3RGb3JTYWxlT3JFeHBpcmVkCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODc4CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjg3OQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0lTTE9DS0VEKS52YWx1ZSA9IGxvY2sgPyAnMScgOiAnMCcKCWJ5dGVjIDI1IC8vICJpLmNvbnRyYWN0TG9ja2VkIgoJZnJhbWVfZGlnIC0xIC8vIGxvY2s6IGJvb2xlYW4KCWJ6ICp0ZXJuYXJ5MF9mYWxzZQoJYnl0ZWMgMTUgLy8gICIxIgoJYiAqdGVybmFyeTBfZW5kCgoqdGVybmFyeTBfZmFsc2U6CglieXRlYyAyMyAvLyAgIjAiCgoqdGVybmFyeTBfZW5kOgoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gc2VnbWVudExvY2soYm9vbCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3NlZ21lbnRMb2NrOgoJLy8gdXNkUHJpY2U6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIGxvY2s6IGJvb2wKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnRjIDEgLy8gMQoJPT0KCgkvLyBhcmd1bWVudCAxIChsb2NrKSBmb3Igc2VnbWVudExvY2sgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIGV4ZWN1dGUgc2VnbWVudExvY2soYm9vbCx1aW50NjQpdm9pZAoJY2FsbHN1YiBzZWdtZW50TG9jawoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gc2VnbWVudExvY2sobG9jazogYm9vbGVhbiwgdXNkUHJpY2U6IHVpbnQ2NCk6IHZvaWQKc2VnbWVudExvY2s6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjg4NQoJLy8gdGhpcy5hc3NlcnRPd25lckNhbGxlZE5vdEZvclNhbGVPckV4cGlyZWQoKQoJY2FsbHN1YiBhc3NlcnRPd25lckNhbGxlZE5vdEZvclNhbGVPckV4cGlyZWQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4ODYKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9USU1FQ0hBTkdFRCkudmFsdWUgPSBpdG9iKGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wKQoJYnl0ZWMgMiAvLyAiaS50aW1lQ2hhbmdlZCIKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODg3CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfSVNTRUdNRU5UTE9DS0VEKS52YWx1ZSA9IGxvY2sgPyAnMScgOiAnMCcKCWJ5dGVjIDIxIC8vICJpLnNlZ21lbnRMb2NrZWQiCglmcmFtZV9kaWcgLTEgLy8gbG9jazogYm9vbGVhbgoJYnogKnRlcm5hcnkxX2ZhbHNlCglieXRlYyAxNSAvLyAgIjEiCgliICp0ZXJuYXJ5MV9lbmQKCip0ZXJuYXJ5MV9mYWxzZToKCWJ5dGVjIDIzIC8vICAiMCIKCip0ZXJuYXJ5MV9lbmQ6CglhcHBfZ2xvYmFsX3B1dAoKCS8vICppZjUwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODg4CgkvLyBsb2NrCglmcmFtZV9kaWcgLTEgLy8gbG9jazogYm9vbGVhbgoJYnogKmlmNTBfZWxzZQoKCS8vICppZjUwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjg4OQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1NFR01FTlRfVVNEX1BSSUNFKS5kZWxldGUoKQoJYnl0ZWMgMzIgLy8gImkuc2VnbWVudFByaWNlVXNkIgoJYXBwX2dsb2JhbF9kZWwKCWIgKmlmNTBfZW5kCgoqaWY1MF9lbHNlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODkyCgkvLyBjb25zdHJhaW50RGF0YSA9IHNlbmRNZXRob2RDYWxsPHR5cGVvZiBORkRSZWdpc3RyeS5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM+KHsKCS8vICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KHRoaXMucmVnaXN0cnlBcHBJZCksCgkvLyAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyA3IC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglieXRlYyAzNyAvLyAgbWV0aG9kICJnZXRDb25zdHJhaW50cygpKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4OTMKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKQoJaW50YyA0IC8vIFRNUExfcmVnaXN0cnlBcHBJZAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBOdW1Mb2dzCglpbnRjIDEgLy8gMQoJLQoJaXR4bmFzIExvZ3MKCWV4dHJhY3QgNCAwCglmcmFtZV9idXJ5IDAgLy8gY29uc3RyYWludERhdGE6ICh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjg5NQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgIHVzZFByaWNlID49IGNvbnN0cmFpbnREYXRhLnNlZ21lbnRQbGF0Zm9ybUNvc3RJblVzZCwKCS8vICAgICAgICAgICAgICAgICAnYW1vdW50IG11c3QgYmUgYXQgbGVhc3QgTkZEX01JTl9TRUdNRU5UX1VTRCBkb2xsYXJzIGluIGFsZ28nLAoJLy8gICAgICAgICAgICAgKQoJZnJhbWVfZGlnIC0yIC8vIHVzZFByaWNlOiB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIGNvbnN0cmFpbnREYXRhOiAodWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMCA4CglidG9pCgk+PQoKCS8vIGFtb3VudCBtdXN0IGJlIGF0IGxlYXN0IE5GRF9NSU5fU0VHTUVOVF9VU0QgZG9sbGFycyBpbiBhbGdvCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4OTkKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUdNRU5UX1VTRF9QUklDRSkudmFsdWUgPSBpdG9iKHVzZFByaWNlKQoJYnl0ZWMgMzIgLy8gImkuc2VnbWVudFByaWNlVXNkIgoJZnJhbWVfZGlnIC0yIC8vIHVzZFByaWNlOiB1aW50NjQKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoqaWY1MF9lbmQ6CglyZXRzdWIKCi8vIHZhdWx0T3B0SW5Mb2NrKGJvb2wpdm9pZAoqYWJpX3JvdXRlX3ZhdWx0T3B0SW5Mb2NrOgoJLy8gbG9jazogYm9vbAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgMSAvLyAxCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGxvY2spIGZvciB2YXVsdE9wdEluTG9jayBtdXN0IGJlIGEgYm9vbAoJYXNzZXJ0CglpbnRjIDAgLy8gMAoJZ2V0Yml0CgoJLy8gZXhlY3V0ZSB2YXVsdE9wdEluTG9jayhib29sKXZvaWQKCWNhbGxzdWIgdmF1bHRPcHRJbkxvY2sKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHZhdWx0T3B0SW5Mb2NrKGxvY2s6IGJvb2xlYW4pOiB2b2lkCnZhdWx0T3B0SW5Mb2NrOgoJcHJvdG8gMSAwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTA4CgkvLyB0aGlzLmFzc2VydE93bmVyQ2FsbGVkTm90Rm9yU2FsZU9yRXhwaXJlZCgpCgljYWxsc3ViIGFzc2VydE93bmVyQ2FsbGVkTm90Rm9yU2FsZU9yRXhwaXJlZAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjkwOQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1RJTUVDSEFOR0VEKS52YWx1ZSA9IGl0b2IoZ2xvYmFscy5sYXRlc3RUaW1lc3RhbXApCglieXRlYyAyIC8vICJpLnRpbWVDaGFuZ2VkIgoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJaXRvYgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5MTAKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9JU1ZBVUxUT1BUSU5MT0NLRUQpLnZhbHVlID0gbG9jayA/ICcxJyA6ICcwJwoJYnl0ZWMgMjAgLy8gImkudmF1bHRPcHRJbkxvY2tlZCIKCWZyYW1lX2RpZyAtMSAvLyBsb2NrOiBib29sZWFuCglieiAqdGVybmFyeTJfZmFsc2UKCWJ5dGVjIDE1IC8vICAiMSIKCWIgKnRlcm5hcnkyX2VuZAoKKnRlcm5hcnkyX2ZhbHNlOgoJYnl0ZWMgMjMgLy8gICIwIgoKKnRlcm5hcnkyX2VuZDoKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIHZhdWx0T3B0SW4odWludDY0W10pdm9pZAoqYWJpX3JvdXRlX3ZhdWx0T3B0SW46CgkvLyBhc3NldHM6IHVpbnQ2NFtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgdmF1bHRPcHRJbih1aW50NjRbXSl2b2lkCgljYWxsc3ViIHZhdWx0T3B0SW4KCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHZhdWx0T3B0SW4oYXNzZXRzOiBBc3NldElEW10pOiB2b2lkCnZhdWx0T3B0SW46Cglwcm90byAxIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTIwCgkvLyB0aGlzLm5vdEZvclNhbGVPckV4cGlyZWQoKQoJY2FsbHN1YiBub3RGb3JTYWxlT3JFeHBpcmVkCgoJLy8gKmlmNTFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5MjQKCS8vIHRoaXMuaXNWYXVsdEF1dG9PcHRJbkxvY2tlZCgpCgljYWxsc3ViIGlzVmF1bHRBdXRvT3B0SW5Mb2NrZWQKCWJ6ICppZjUxX2VuZAoKCS8vICppZjUxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjkyNQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgIHJhd0J5dGVzKHRoaXMudHhuLnNlbmRlcikgPT09IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUsCgkvLyAgICAgICAgICAgICAgICAgJ3NlbmRlciBtdXN0IGJlIG93bmVyIHdoZW4gdmF1bHQgbG9ja2VkJywKCS8vICAgICAgICAgICAgICkKCXR4biBTZW5kZXIKCWJ5dGVjIDEgLy8gImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoKCS8vIHNlbmRlciBtdXN0IGJlIG93bmVyIHdoZW4gdmF1bHQgbG9ja2VkCglhc3NlcnQKCippZjUxX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjkzMQoJLy8gYXNzZXJ0KHRoaXMudHhuLmdyb3VwSW5kZXggPiAwLCAncGFydCBvZiBvcHQtaW4gZm9yIG5ldyBhc3NldCwgbXVzdCBoYXZlIHByaW9yIHR4biBwYXlpbmcgTUJSJykKCXR4biBHcm91cEluZGV4CglpbnRjIDAgLy8gMAoJPgoKCS8vIHBhcnQgb2Ygb3B0LWluIGZvciBuZXcgYXNzZXQsIG11c3QgaGF2ZSBwcmlvciB0eG4gcGF5aW5nIE1CUgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTMzCgkvLyB2ZXJpZnlQYXlUeG4odGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4IC0gMV0sIHsKCS8vICAgICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICAgICAgYW1vdW50OiAxMDBfMDAwICogYXNzZXRzLmxlbmd0aCwKCS8vICAgICAgICAgfSkKCXR4biBHcm91cEluZGV4CglpbnRjIDEgLy8gMQoJLQoJc3RvcmUgMjQ4IC8vIHZlcmlmeVR4biBpbmRleAoKCS8vIHZlcmlmeSBwYXkKCWxvYWQgMjQ4IC8vIHZlcmlmeVR4biBpbmRleAoJZ3R4bnMgVHlwZUVudW0KCWludGMgMSAvLyAgcGF5Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoidGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4IC0gMV0iLCJmaWVsZCI6InR5cGVFbnVtIiwiZXhwZWN0ZWQiOiJwYXkifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHJlY2VpdmVyCglsb2FkIDI0OCAvLyB2ZXJpZnlUeG4gaW5kZXgKCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InRoaXMudHhuR3JvdXBbdGhpcy50eG4uZ3JvdXBJbmRleCAtIDFdIiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50Cglsb2FkIDI0OCAvLyB2ZXJpZnlUeG4gaW5kZXgKCWd0eG5zIEFtb3VudAoJaW50YyAxNiAvLyAxMDBfMDAwCglmcmFtZV9kaWcgLTEgLy8gYXNzZXRzOiBBc3NldElEW10KCWxlbgoJaW50YyA1IC8vIDgKCS8KCSoKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJ0aGlzLnR4bkdyb3VwW3RoaXMudHhuLmdyb3VwSW5kZXggLSAxXSIsImZpZWxkIjoiYW1vdW50IiwiZXhwZWN0ZWQiOiIxMDBfMDAwICogYXNzZXRzLmxlbmd0aCJ9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5MzcKCS8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpICs9IDEpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAwIC8vIGk6IHVpbnQ2NAoKKmZvcl82OgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTM3CgkvLyBpIDwgYXNzZXRzLmxlbmd0aAoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gYXNzZXRzOiBBc3NldElEW10KCWxlbgoJaW50YyA1IC8vIDgKCS8KCTwKCWJ6ICpmb3JfNl9lbmQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5MzgKCS8vIGFzc2V0SWQgPSBhc3NldHNbaV0KCWZyYW1lX2RpZyAtMSAvLyBhc3NldHM6IEFzc2V0SURbXQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMCAvLyAgaW5pdGlhbCBvZmZzZXQKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJaW50YyA1IC8vIDgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJaW50YyA1IC8vIDgKCWV4dHJhY3QzCglidG9pCglmcmFtZV9idXJ5IDEgLy8gYXNzZXRJZDogdWludDY0CgoJLy8gKmlmNTJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5NDAKCS8vICF0aGlzLmFwcC5hZGRyZXNzLmlzT3B0ZWRJblRvQXNzZXQoYXNzZXRJZCkKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglmcmFtZV9kaWcgMSAvLyBhc3NldElkOiB1aW50NjQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJc3dhcAoJcG9wCgkhCglieiAqaWY1Ml9lbmQKCgkvLyAqaWY1Ml9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5NDEKCS8vIHNlbmRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgICAgICAgICAgICAgICAgeGZlckFzc2V0OiBhc3NldElkLAoJLy8gICAgICAgICAgICAgICAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICAgICAgICAgICAgICBhc3NldEFtb3VudDogMCwKCS8vICAgICAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxMCAvLyAgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5NDIKCS8vIHhmZXJBc3NldDogYXNzZXRJZAoJZnJhbWVfZGlnIDEgLy8gYXNzZXRJZDogdWludDY0CglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk0MwoJLy8gYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk0NAoJLy8gYXNzZXRBbW91bnQ6IDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmNTJfZW5kOgoKKmZvcl82X2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTM3CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMCAvLyBpOiB1aW50NjQKCWIgKmZvcl82CgoqZm9yXzZfZW5kOgoJcmV0c3ViCgovLyB2YXVsdFNlbmQodWludDY0LGFkZHJlc3Msc3RyaW5nLHVpbnQ2NCx1aW50NjRbXSl2b2lkCiphYmlfcm91dGVfdmF1bHRTZW5kOgoJLy8gb3RoZXJBc3NldHM6IHVpbnQ2NFtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglleHRyYWN0IDIgMAoKCS8vIGFzc2V0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBub3RlOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWV4dHJhY3QgMiAwCgoJLy8gcmVjZWl2ZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDMgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMyAocmVjZWl2ZXIpIGZvciB2YXVsdFNlbmQgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGFtb3VudDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSB2YXVsdFNlbmQodWludDY0LGFkZHJlc3Msc3RyaW5nLHVpbnQ2NCx1aW50NjRbXSl2b2lkCgljYWxsc3ViIHZhdWx0U2VuZAoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gdmF1bHRTZW5kKGFtb3VudDogdWludDY0LCByZWNlaXZlcjogQWRkcmVzcywgbm90ZTogc3RyaW5nLCBhc3NldDogdWludDY0LCBvdGhlckFzc2V0czogQXNzZXRJRFtdKTogdm9pZAp2YXVsdFNlbmQ6Cglwcm90byA1IDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiAzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTY0CgkvLyB0aGlzLmFzc2VydE93bmVyQ2FsbGVkTm90Rm9yU2FsZU9yRXhwaXJlZCgpCgljYWxsc3ViIGFzc2VydE93bmVyQ2FsbGVkTm90Rm9yU2FsZU9yRXhwaXJlZAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk2NQoJLy8gYXNzZXJ0KHJlY2VpdmVyICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIC0yIC8vIHJlY2VpdmVyOiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9Cglhc3NlcnQKCgkvLyAqaWY1M19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk2NwoJLy8gYXNzZXQgPT09IDAKCWZyYW1lX2RpZyAtNCAvLyBhc3NldDogdWludDY0CglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjUzX2VuZAoKCS8vICppZjUzX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk2OAoJLy8gYXNzZXJ0KG90aGVyQXNzZXRzLmxlbmd0aCA9PT0gMCwgImNhbid0IHNwZWNpZnkgb3RoZXIgYXNzZXRzIGlmIHNlbmRpbmcgYWxnbyBmcm9tIHZhdWx0IikKCWZyYW1lX2RpZyAtNSAvLyBvdGhlckFzc2V0czogQXNzZXRJRFtdCglsZW4KCWludGMgNSAvLyA4CgkvCglpbnRjIDAgLy8gMAoJPT0KCgkvLyBjYW4ndCBzcGVjaWZ5IG90aGVyIGFzc2V0cyBpZiBzZW5kaW5nIGFsZ28gZnJvbSB2YXVsdAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTY5CgkvLyBhc3NlcnQoYW1vdW50ID4gMCkKCWZyYW1lX2RpZyAtMSAvLyBhbW91bnQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT4KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk3MQoJLy8gbWluQmFsYW5jZSA9IHRoaXMuYXBwLmFkZHJlc3MubWluQmFsYW5jZSArIHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX01JTlRJTkdfS0lDS09GRl9BTU9VTlQpCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCglwb3AKCWJ5dGVjIDEzIC8vICJpLm1pbnRpbmdLaWNrb2ZmQW1vdW50IgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CgkrCglmcmFtZV9idXJ5IDAgLy8gbWluQmFsYW5jZTogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTczCgkvLyBhc3NlcnQodGhpcy5hcHAuYWRkcmVzcy5iYWxhbmNlIC0gYW1vdW50ID49IG1pbkJhbGFuY2UpCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCglwb3AKCWZyYW1lX2RpZyAtMSAvLyBhbW91bnQ6IHVpbnQ2NAoJLQoJZnJhbWVfZGlnIDAgLy8gbWluQmFsYW5jZTogdWludDY0Cgk+PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTc0CgkvLyBzZW5kUGF5bWVudCh7IHJlY2VpdmVyOiByZWNlaXZlciwgYW1vdW50OiBhbW91bnQsIG5vdGU6IG5vdGUgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTc0CgkvLyByZWNlaXZlcjogcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMiAvLyByZWNlaXZlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk3NAoJLy8gYW1vdW50OiBhbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBhbW91bnQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5NzQKCS8vIG5vdGU6IG5vdGUKCWZyYW1lX2RpZyAtMyAvLyBub3RlOiBzdHJpbmcKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5NzUKCS8vIHJldHVybgoJcmV0c3ViCgoqaWY1M19lbmQ6CgkvLyAqaWY1NF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk3OQoJLy8gYW1vdW50ICE9PSAwCglmcmFtZV9kaWcgLTEgLy8gYW1vdW50OiB1aW50NjQKCWludGMgMCAvLyAwCgkhPQoJYnogKmlmNTRfZW5kCgoJLy8gKmlmNTRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTgwCgkvLyBhc3NlcnQob3RoZXJBc3NldHMubGVuZ3RoID09PSAwLCAnY2FuIG9ubHkgc2VuZCBvbmUgYXNzZXQgaWYgYW1vdW50ID09IDAnKQoJZnJhbWVfZGlnIC01IC8vIG90aGVyQXNzZXRzOiBBc3NldElEW10KCWxlbgoJaW50YyA1IC8vIDgKCS8KCWludGMgMCAvLyAwCgk9PQoKCS8vIGNhbiBvbmx5IHNlbmQgb25lIGFzc2V0IGlmIGFtb3VudCA9PSAwCglhc3NlcnQKCippZjU0X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk4MgoJLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8PSBvdGhlckFzc2V0cy5sZW5ndGg7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDEgLy8gaTogdWludDY0CgoqZm9yXzc6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5ODIKCS8vIGkgPD0gb3RoZXJBc3NldHMubGVuZ3RoCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAtNSAvLyBvdGhlckFzc2V0czogQXNzZXRJRFtdCglsZW4KCWludGMgNSAvLyA4CgkvCgk8PQoJYnogKmZvcl83X2VuZAoKCS8vICppZjU1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTg2CgkvLyBpID09PSAwCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludGMgMCAvLyAwCgk9PQoJYnogKmlmNTVfZWxzZQoKCS8vICppZjU1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk4NwoJLy8gYXNzZXRJZCA9IEFzc2V0SUQuZnJvbVVpbnQ2NChhc3NldCkKCWZyYW1lX2RpZyAtNCAvLyBhc3NldDogdWludDY0CglmcmFtZV9idXJ5IDIgLy8gYXNzZXRJZDogQXNzZXRJRAoJYiAqaWY1NV9lbmQKCippZjU1X2Vsc2U6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5ODkKCS8vIGFzc2V0SWQgPSBvdGhlckFzc2V0c1tpIC0gMV0KCWZyYW1lX2RpZyAtNSAvLyBvdGhlckFzc2V0czogQXNzZXRJRFtdCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyAwIC8vICBpbml0aWFsIG9mZnNldAoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJLQoJaW50YyA1IC8vIDgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJaW50YyA1IC8vIDgKCWV4dHJhY3QzCglidG9pCglmcmFtZV9idXJ5IDIgLy8gYXNzZXRJZDogQXNzZXRJRAoKKmlmNTVfZW5kOgoJLy8gKmlmNTZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5OTIKCS8vIGFzc2V0SWQuaWQgPT09IGJ0b2kodGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0FTQUlEKS52YWx1ZSkKCWZyYW1lX2RpZyAyIC8vIGFzc2V0SWQ6IEFzc2V0SUQKCWJ5dGVjIDE4IC8vICJpLmFzYWlkIgoJYXBwX2dsb2JhbF9nZXQKCWJ0b2kKCT09CglieiAqaWY1Nl9lbmQKCgkvLyAqaWY1Nl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5OTMKCS8vIGFzc2VydChyYXdCeXRlcyhyZWNlaXZlcikgPT09IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUsICdyZWNlaXZlciBtdXN0IGJlIG93bmVyJykKCWZyYW1lX2RpZyAtMiAvLyByZWNlaXZlcjogQWRkcmVzcwoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXQKCT09CgoJLy8gcmVjZWl2ZXIgbXVzdCBiZSBvd25lcgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTk0CgkvLyB0aGlzLmNsYXdBc2FGcm9tVG8odGhpcy5hcHAuYWRkcmVzcywgcmVjZWl2ZXIpCglmcmFtZV9kaWcgLTIgLy8gcmVjZWl2ZXI6IEFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgljYWxsc3ViIGNsYXdBc2FGcm9tVG8KCWIgKmZvcl83X2NvbnRpbnVlCgoqaWY1Nl9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5OTcKCS8vIGFzc2V0QmFsID0gcmVjZWl2ZXIuYXNzZXRCYWxhbmNlKGFzc2V0SWQpCglmcmFtZV9kaWcgLTIgLy8gcmVjZWl2ZXI6IEFkZHJlc3MKCWZyYW1lX2RpZyAyIC8vIGFzc2V0SWQ6IEFzc2V0SUQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJcG9wCglmcmFtZV9idXJ5IDMgLy8gYXNzZXRCYWw6IHVpbnQ2NAoKCS8vICppZjU3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTk4CgkvLyBhbW91bnQgPT09IDAgfHwgdGhpcy5hcHAuYWRkcmVzcy5hc3NldEJhbGFuY2UoYXNzZXRJZCkgPT09IGFzc2V0QmFsCglmcmFtZV9kaWcgLTEgLy8gYW1vdW50OiB1aW50NjQKCWludGMgMCAvLyAwCgk9PQoJZHVwCglibnogKnNraXBfb3IyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZnJhbWVfZGlnIDIgLy8gYXNzZXRJZDogQXNzZXRJRAoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglwb3AKCWZyYW1lX2RpZyAzIC8vIGFzc2V0QmFsOiB1aW50NjQKCT09Cgl8fAoKKnNraXBfb3IyOgoJYnogKmlmNTdfZWxzZQoKCS8vICppZjU3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwMDAKCS8vIHNlbmRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgICAgICAgICAgICAgICAgeGZlckFzc2V0OiBhc3NldElkLAoJLy8gICAgICAgICAgICAgICAgICAgICBhc3NldFJlY2VpdmVyOiByZWNlaXZlciwKCS8vICAgICAgICAgICAgICAgICAgICAgYXNzZXRDbG9zZVRvOiByZWNlaXZlciwKCS8vICAgICAgICAgICAgICAgICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKCS8vICAgICAgICAgICAgICAgICAgICAgbm90ZTogbm90ZSwKCS8vICAgICAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxMCAvLyAgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDAxCgkvLyB4ZmVyQXNzZXQ6IGFzc2V0SWQKCWZyYW1lX2RpZyAyIC8vIGFzc2V0SWQ6IEFzc2V0SUQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAwMgoJLy8gYXNzZXRSZWNlaXZlcjogcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMiAvLyByZWNlaXZlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAwMwoJLy8gYXNzZXRDbG9zZVRvOiByZWNlaXZlcgoJZnJhbWVfZGlnIC0yIC8vIHJlY2VpdmVyOiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFzc2V0Q2xvc2VUbwoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwMDQKCS8vIGFzc2V0QW1vdW50OiBhbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBhbW91bnQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwMDUKCS8vIG5vdGU6IG5vdGUKCWZyYW1lX2RpZyAtMyAvLyBub3RlOiBzdHJpbmcKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWIgKmlmNTdfZW5kCgoqaWY1N19lbHNlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAwOAoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoeyB4ZmVyQXNzZXQ6IGFzc2V0SWQsIGFzc2V0UmVjZWl2ZXI6IHJlY2VpdmVyLCBhc3NldEFtb3VudDogYW1vdW50LCBub3RlOiBub3RlIH0pCglpdHhuX2JlZ2luCglpbnRjIDEwIC8vICBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwMDgKCS8vIHhmZXJBc3NldDogYXNzZXRJZAoJZnJhbWVfZGlnIDIgLy8gYXNzZXRJZDogQXNzZXRJRAoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDA4CgkvLyBhc3NldFJlY2VpdmVyOiByZWNlaXZlcgoJZnJhbWVfZGlnIC0yIC8vIHJlY2VpdmVyOiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDA4CgkvLyBhc3NldEFtb3VudDogYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gYW1vdW50OiB1aW50NjQKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDA4CgkvLyBub3RlOiBub3RlCglmcmFtZV9kaWcgLTMgLy8gbm90ZTogc3RyaW5nCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoqaWY1N19lbmQ6CgoqZm9yXzdfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5ODIKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAxIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzcKCipmb3JfN19lbmQ6CglyZXRzdWIKCi8vIHJlbmV3KHBheSl2b2lkCiphYmlfcm91dGVfcmVuZXc6CgkvLyBwYXltZW50OiBwYXkKCXR4biBHcm91cEluZGV4CglpbnRjIDEgLy8gMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50YyAxIC8vICBwYXkKCT09CgoJLy8gYXJndW1lbnQgMCAocGF5bWVudCkgZm9yIHJlbmV3IG11c3QgYmUgYSBwYXkgdHJhbnNhY3Rpb24KCWFzc2VydAoKCS8vIGV4ZWN1dGUgcmVuZXcocGF5KXZvaWQKCWNhbGxzdWIgcmVuZXcKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHJlbmV3KHBheW1lbnQ6IFBheVR4bik6IHZvaWQKLy8KLy8gUmVuZXcgYWRkcyBtb3JlIHRpbWUgdG8gYW4gZXhpc3RpbmcgTkZEcyBleHBpcmF0aW9uLCBvciByZW5ld3MgaXQgaWYgZXhwaXJlZC4KLy8KLy8gQXMgcGFydCBvZiB2Mi0+djMgdXBncmFkZSwgdGhlIE5GRHMgYXJlIGNvbnZlcnRlZCBmcm9tIGxpZmV0aW1lIE5GRHMgdG8gcmVuZXdhbCBORkRzLiBUaGUgdjIgY29udHJhY3QgaXMgdXBncmFkZWQKLy8gdG8gdjMsIHRoZW4gcmVuZXcgaXMgY2FsbGVkIG9uIHRoZSAobm93IHYzKSBuZmQgdG8gdHVybiBpdCBpbnRvIGEgcmVuZXdhbCAobm90ZSB0aGUgaWYgY3VyRXhwaXJhdGlvbiA9PT0gMCBjaGVjaykKLy8KLy8gSWYgYWxyZWFkeSByZW5ld2FsLCB0aGVuIGl0IGV4dGVuZHMgdGhlIGN1cnJlbnQgZXhwaXJhdGlvbiB0aW1lIGJ5IHRoZSB0aW1lIHNwZWNpZmllZCAobWluaW11bSAxIHlyKSAoMzY1IC8gcHJpY2UgcGFpZCAqIG1pbnQgcHJpY2UpCi8vIEV4cGlyYXRpb25zIGNhbiBuZXZlciBiZSBtb3JlIHRoYW4gTkZEX01BWF9FWFBJUkFUSU9OX0RBWVMgZGF5cyBpbiB0aGUgZnV0dXJlLgovLwovLyBJRiB0aGUgTkZEIGlzIGV4cGlyZWQ6Ci8vIHggVGhlIGN1cnJlbnQgb3duZXIgY2FuIHRha2UgaXQgYmFjayBvdmVyIGF0IGJhc2UgcHJpY2UgLSBhbmQgTkZEIG1ldGFkYXRhIGRvZXNuJ3QgaGF2ZSB0byBiZSBjbGVhcmVkIC0gdGhleQovLyBnZXQgaXQgYmFjayBhcy1pcy4KLy8geCBJZiBub3QgY3VycmVudCBvd25lciwgdGhlbiB0aGUgcHJpY2UgZ29lcyBmcm9tIGhpZ2ggb2YgYmFzZSBwcmljZSAqIDEwLDAwMCBkb3duIHRvIGJhc2UgcHJpY2Ugb3ZlciAyNCBocnMgd2hlcmUKLy8gJ2J1eWVyJyBoYXMgdG8gcGF5IGF0IGxlYXN0IHRoYXQgcHJpY2UuICBUaGUgTkZEIE1VU1QgQUxSRUFEWSBIQVZFIElUUyBNRVRBREFUQSBDTEVBUkVEIQovLwovLyBAcGFyYW0ge1BheVR4bn0gcGF5bWVudCAtIFRoZSBwYXltZW50IHRyYW5zYWN0aW9uIGZyb20gd2hpY2ggdGhlIHJlbmV3YWwgcGVyaW9kIGlzIGRldGVybWluZWQuLgpyZW5ldzoKCXByb3RvIDEgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXBuIDExCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAzMQoJLy8gdmVyaWZ5UGF5VHhuKHBheW1lbnQsIHsgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MgfSkKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgUmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoicGF5bWVudCIsImZpZWxkIjoicmVjZWl2ZXIiLCJleHBlY3RlZCI6InRoaXMuYXBwLmFkZHJlc3MifQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAzNAoJLy8gcHJpY2VJbmZvID0gdGhpcy5nZXRSZW5ld1ByaWNlRGF0YSh0aGlzLnR4bi5zZW5kZXIpCgl0eG4gU2VuZGVyCgljYWxsc3ViIGdldFJlbmV3UHJpY2VEYXRhCglmcmFtZV9idXJ5IDAgLy8gcHJpY2VJbmZvOiAodWludDY0LHVpbnQ2NCxib29sLGJvb2wsYm9vbCkKCgkvLyAqaWY1OF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwMzUKCS8vIGdsb2JhbHMub3Bjb2RlQnVkZ2V0IDwgMjAwCglnbG9iYWwgT3Bjb2RlQnVkZ2V0CglpbnRjIDE5IC8vIDIwMAoJPAoJYnogKmlmNThfZW5kCgoJLy8gKmlmNThfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAzNgoJLy8gaW5jcmVhc2VPcGNvZGVCdWRnZXQoKQoJaXR4bl9iZWdpbgoJaW50YyA3IC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCWJ5dGVjIDE0IC8vICAjcHJhZ21hIHZlcnNpb24gMTA7IGludCAxCglkdXAKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCglpbnRjIDEzIC8vICBEZWxldGVBcHBsaWNhdGlvbgoJaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KCWl0eG5fc3VibWl0CgoqaWY1OF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDM4CgkvLyBjb25zdHJhaW50RGF0YSA9IHNlbmRNZXRob2RDYWxsPHR5cGVvZiBORkRSZWdpc3RyeS5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM+KHsKCS8vICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKSwKCS8vICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgNyAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJYnl0ZWMgMzcgLy8gIG1ldGhvZCAiZ2V0Q29uc3RyYWludHMoKSh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KSIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAzOQoJLy8gYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnJlZ2lzdHJ5QXBwSWQpCglpbnRjIDQgLy8gVE1QTF9yZWdpc3RyeUFwcElkCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglpdHhuIE51bUxvZ3MKCWludGMgMSAvLyAxCgktCglpdHhuYXMgTG9ncwoJZXh0cmFjdCA0IDAKCWZyYW1lX2J1cnkgMSAvLyBjb25zdHJhaW50RGF0YTogKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA0MQoJLy8gcmVxUHJpY2UgPSBwcmljZUluZm8ub25lWWVhclByaWNlCglmcmFtZV9kaWcgMCAvLyBwcmljZUluZm86ICh1aW50NjQsdWludDY0LGJvb2wsYm9vbCxib29sKQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgMCA4CglidG9pCglmcmFtZV9idXJ5IDIgLy8gcmVxUHJpY2U6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwNDIKCS8vIG1heEV4cFllYXJzID0gY29uc3RyYWludERhdGEubWF4WWVhcnNBbGxvd2VkCglmcmFtZV9kaWcgMSAvLyBjb25zdHJhaW50RGF0YTogKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDE2IDgKCWJ0b2kKCWZyYW1lX2J1cnkgMyAvLyBtYXhFeHBZZWFyczogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA0MwoJLy8gYXNzZXJ0KHJlcVByaWNlID4gMCkKCWZyYW1lX2RpZyAyIC8vIHJlcVByaWNlOiB1aW50NjQKCWludGMgMCAvLyAwCgk+Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDQ0CgkvLyBvcmlnT3duZXIgPSBBZGRyZXNzLmZyb21CeXRlcyh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlKQoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2J1cnkgNCAvLyBvcmlnT3duZXI6IGFkZHJlc3MKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDQ2CgkvLyBjdXJFeHBpcmF0aW9uID0gdGhpcy5zYWZlR2xvYmFsSW50R2V0KE5GRF9LRVlfRVhQSVJBVElPTlRJTUUpCglieXRlYyAxNyAvLyAiaS5leHBpcmF0aW9uVGltZSIKCWNhbGxzdWIgc2FmZUdsb2JhbEludEdldAoJZnJhbWVfYnVyeSA1IC8vIGN1ckV4cGlyYXRpb246IHVpbnQ2NAoKCS8vICppZjU5X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA0NwoJLy8gY3VyRXhwaXJhdGlvbiAhPT0gMCAmJiB0aGlzLmlzRXhwaXJlZCgpCglmcmFtZV9kaWcgNSAvLyBjdXJFeHBpcmF0aW9uOiB1aW50NjQKCWludGMgMCAvLyAwCgkhPQoJZHVwCglieiAqc2tpcF9hbmQxNgoJY2FsbHN1YiBpc0V4cGlyZWQKCSYmCgoqc2tpcF9hbmQxNjoKCWJ6ICppZjU5X2VuZAoKCS8vICppZjU5X2NvbnNlcXVlbnQKCS8vICppZjYwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA1MgoJLy8gdGhpcy50eG4uc2VuZGVyICE9PSBvcmlnT3duZXIKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyA0IC8vIG9yaWdPd25lcjogYWRkcmVzcwoJIT0KCWJ6ICppZjYwX2VuZAoKCS8vICppZjYwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwNTMKCS8vIGFzc2VydCh0aGlzLmFwcC5hZGRyZXNzLnRvdGFsQm94ZXMgPT09IDAsICJjYW4ndCBjbGFpbSBleHBpcmVkIG5mZCB1bmxlc3MgYWxsIG1ldGFkYXRhIGlzIGNsZWFyZWQiKQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0VG90YWxCb3hlcwoJcG9wCglpbnRjIDAgLy8gMAoJPT0KCgkvLyBjYW4ndCBjbGFpbSBleHBpcmVkIG5mZCB1bmxlc3MgYWxsIG1ldGFkYXRhIGlzIGNsZWFyZWQKCWFzc2VydAoKKmlmNjBfZW5kOgoKKmlmNTlfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA1OQoJLy8gYXNzZXJ0KHBheW1lbnQuYW1vdW50ID49IHJlcVByaWNlLCAnbXVzdCBwYXkgYXQgbGVhc3QgbWluaW11bSByZW5ld2FsIHByaWNlJykKCWZyYW1lX2RpZyAtMSAvLyBwYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJZnJhbWVfZGlnIDIgLy8gcmVxUHJpY2U6IHVpbnQ2NAoJPj0KCgkvLyBtdXN0IHBheSBhdCBsZWFzdCBtaW5pbXVtIHJlbmV3YWwgcHJpY2UKCWFzc2VydAoKCS8vICppZjYxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA2MAoJLy8gY3VyRXhwaXJhdGlvbiA9PT0gMAoJZnJhbWVfZGlnIDUgLy8gY3VyRXhwaXJhdGlvbjogdWludDY0CglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjYxX2Vsc2VpZjFfY29uZGl0aW9uCgoJLy8gKmlmNjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA2MQoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gb3JpZ093bmVyKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIDQgLy8gb3JpZ093bmVyOiBhZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA2MwoJLy8gY3VyRXhwaXJhdGlvbiA9IGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglmcmFtZV9idXJ5IDUgLy8gY3VyRXhwaXJhdGlvbjogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA2NQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xX0FHRU5UKS5kZWxldGUoKQoJYnl0ZWMgNSAvLyAiaS5jb21taXNzaW9uMUFnZW50LmEiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwNjYKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9DT01NSVNTSU9OMSkuZGVsZXRlKCkKCWJ5dGVjIDcgLy8gImkuY29tbWlzc2lvbjEiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwNjcKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9DT01NSVNTSU9OMl9BR0VOVCkuZGVsZXRlKCkKCWJ5dGVjIDE2IC8vICJpLmNvbW1pc3Npb24yQWdlbnQuYSIKCWFwcF9nbG9iYWxfZGVsCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA2OAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04yKS5kZWxldGUoKQoJYnl0ZWMgMjIgLy8gImkuY29tbWlzc2lvbjIiCglhcHBfZ2xvYmFsX2RlbAoJYiAqaWY2MV9lbmQKCippZjYxX2Vsc2VpZjFfY29uZGl0aW9uOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA2OQoJLy8gdGhpcy5pc0V4cGlyZWQoKQoJY2FsbHN1YiBpc0V4cGlyZWQKCWJ6ICppZjYxX2VuZAoKCS8vICppZjYxX2Vsc2VpZjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA3MQoJLy8gY3VyRXhwaXJhdGlvbiA9IGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglmcmFtZV9idXJ5IDUgLy8gY3VyRXhwaXJhdGlvbjogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA3MwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX09XTkVSKS52YWx1ZSA9IHJhd0J5dGVzKHBheW1lbnQuc2VuZGVyKQoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwNzQKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUxMRVIpLnZhbHVlID0gcmF3Qnl0ZXMocGF5bWVudC5zZW5kZXIpCglieXRlYyAxMCAvLyAiaS5zZWxsZXIuYSIKCWZyYW1lX2RpZyAtMSAvLyBwYXltZW50OiBQYXlUeG4KCWd0eG5zIFNlbmRlcgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDc1CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfUkVTRVJWRURfT1dORVIpLmRlbGV0ZSgpCglieXRlYyA4IC8vICJpLnJlc2VydmVkT3duZXIuYSIKCWFwcF9nbG9iYWxfZGVsCgoJLy8gKmlmNjJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDc2CgkvLyB0aGlzLmlzRm9yU2FsZSgpCgljYWxsc3ViIGlzRm9yU2FsZQoJYnogKmlmNjJfZW5kCgoJLy8gKmlmNjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA3OAoJLy8gdGhpcy5uZmRfc2FsZUNhbmNlbGxlZC5sb2coeyBhcHBJZDogdGhpcy5hcHAuaWQsIG5hbWU6IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9OQU1FKS52YWx1ZSB9KQoJYnl0ZWMgMzYgLy8gIG5mZF9zYWxlQ2FuY2VsbGVkKHVpbnQ2NCxzdHJpbmcpCglieXRlYyAwIC8vICBpbml0aWFsIGhlYWQKCWJ5dGVjIDAgLy8gIGluaXRpYWwgdGFpbAoJYnl0ZWMgNDEgLy8gIGluaXRpYWwgaGVhZCBvZmZzZXQKCXR4bmEgQXBwbGljYXRpb25zIDAKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWJ5dGVjIDQgLy8gImkubmFtZSIKCWFwcF9nbG9iYWxfZ2V0CglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoJY29uY2F0Cglsb2cKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDc5CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfU0VMTF9BTU9VTlQpLmRlbGV0ZSgpCglieXRlYyA2IC8vICJpLnNlbGxhbXQiCglhcHBfZ2xvYmFsX2RlbAoKKmlmNjJfZW5kOgoKKmlmNjFfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA4MwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0VYUElSQVRJT05USU1FKS52YWx1ZSA9IGl0b2IoCgkvLyAgICAgICAgICAgICB0aGlzLmNhbGNFeHBpcmF0aW9uKHJlcVByaWNlLCBwYXltZW50LmFtb3VudCwgY3VyRXhwaXJhdGlvbiwgbWF4RXhwWWVhcnMpLAoJLy8gICAgICAgICApCglieXRlYyAxNyAvLyAiaS5leHBpcmF0aW9uVGltZSIKCWZyYW1lX2RpZyAzIC8vIG1heEV4cFllYXJzOiB1aW50NjQKCWZyYW1lX2RpZyA1IC8vIGN1ckV4cGlyYXRpb246IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgMiAvLyByZXFQcmljZTogdWludDY0CgljYWxsc3ViIGNhbGNFeHBpcmF0aW9uCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwODYKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9USU1FQ0hBTkdFRCkudmFsdWUgPSBpdG9iKGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wKQoJYnl0ZWMgMiAvLyAiaS50aW1lQ2hhbmdlZCIKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA4OQoJLy8gcmVuZXdBbXQgPSBwYXltZW50LmFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9idXJ5IDYgLy8gcmVuZXdBbXQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwOTAKCS8vIGdyb3NzVG9UcmVhc3VyeSA9IHJlbmV3QW10CglmcmFtZV9kaWcgNiAvLyByZW5ld0FtdDogdWludDY0CglmcmFtZV9idXJ5IDcgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDkyCgkvLyBzZWdtZW50Q29tbWlzc2lvbkFkZHJlc3MgPSBnbG9iYWxzLnplcm9BZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCWZyYW1lX2J1cnkgOSAvLyBzZWdtZW50Q29tbWlzc2lvbkFkZHJlc3M6IGFkZHJlc3MKCgkvLyAqaWY2M19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwOTcKCS8vIHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX1BBUkVOVF9JRCkgIT09IDAKCWJ5dGVjIDI3IC8vICJpLnBhcmVudEFwcElEIgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglpbnRjIDAgLy8gMAoJIT0KCWJ6ICppZjYzX2Vsc2UKCgkvLyAqaWY2M19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDk4CgkvLyBwYXJlbnRBcHBJZCA9IEFwcElELmZyb21VaW50NjQodGhpcy5zYWZlR2xvYmFsSW50R2V0KE5GRF9LRVlfUEFSRU5UX0lEKSkKCWJ5dGVjIDI3IC8vICJpLnBhcmVudEFwcElEIgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglmcmFtZV9idXJ5IDEwIC8vIHBhcmVudEFwcElkOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDk5CgkvLyBzZWdtZW50Q29tbWlzc2lvbkFkZHJlc3MgPSBBZGRyZXNzLmZyb21CeXRlcyhwYXJlbnRBcHBJZC5nbG9iYWxTdGF0ZShORkRfS0VZX09XTkVSKSBhcyBBZGRyZXNzKQoJZnJhbWVfZGlnIDEwIC8vIHBhcmVudEFwcElkOiB1aW50NjQKCWJ5dGVjIDEgLy8gImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBwYXJlbnRBcHBJZC5nbG9iYWxTdGF0ZShORkRfS0VZX09XTkVSKQoJYXNzZXJ0CglmcmFtZV9idXJ5IDkgLy8gc2VnbWVudENvbW1pc3Npb25BZGRyZXNzOiBhZGRyZXNzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTEwNAoJLy8gZXh0cmFEYXlzID0gKDM2NSAqIHJlbmV3QW10KSAvIHJlcVByaWNlCglpbnRjIDggLy8gMzY1CglmcmFtZV9kaWcgNiAvLyByZW5ld0FtdDogdWludDY0CgkqCglmcmFtZV9kaWcgMiAvLyByZXFQcmljZTogdWludDY0CgkvCglmcmFtZV9idXJ5IDExIC8vIGV4dHJhRGF5czogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTEwNgoJLy8gZ3Jvc3NUb1RyZWFzdXJ5ID0gKGV4dHJhRGF5cyAqIGNvbnN0cmFpbnREYXRhLnNlZ21lbnRQbGF0Zm9ybUNvc3RJbkFsZ28pIC8gMzY1CglmcmFtZV9kaWcgMTEgLy8gZXh0cmFEYXlzOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGNvbnN0cmFpbnREYXRhOiAodWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgOCA4CglidG9pCgkqCglpbnRjIDggLy8gMzY1CgkvCglmcmFtZV9idXJ5IDcgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCgkvLyAqaWY2NF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExMDcKCS8vIGdyb3NzVG9UcmVhc3VyeSA8IGNvbnN0cmFpbnREYXRhLnNlZ21lbnRQbGF0Zm9ybUNvc3RJbkFsZ28KCWZyYW1lX2RpZyA3IC8vIGdyb3NzVG9UcmVhc3VyeTogdWludDY0CglmcmFtZV9kaWcgMSAvLyBjb25zdHJhaW50RGF0YTogKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDggOAoJYnRvaQoJPAoJYnogKmlmNjRfZW5kCgoJLy8gKmlmNjRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTEwOAoJLy8gZ3Jvc3NUb1RyZWFzdXJ5ID0gY29uc3RyYWludERhdGEuc2VnbWVudFBsYXRmb3JtQ29zdEluQWxnbwoJZnJhbWVfZGlnIDEgLy8gY29uc3RyYWludERhdGE6ICh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWZyYW1lX2J1cnkgNyAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoKKmlmNjRfZW5kOgoJLy8gKmlmNjVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTEwCgkvLyBncm9zc1RvVHJlYXN1cnkgPj0gcmVuZXdBbXQKCWZyYW1lX2RpZyA3IC8vIGdyb3NzVG9UcmVhc3VyeTogdWludDY0CglmcmFtZV9kaWcgNiAvLyByZW5ld0FtdDogdWludDY0Cgk+PQoJYnogKmlmNjVfZW5kCgoJLy8gKmlmNjVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTExMQoJLy8gZ3Jvc3NUb1RyZWFzdXJ5ID0gcmVuZXdBbXQKCWZyYW1lX2RpZyA2IC8vIHJlbmV3QW10OiB1aW50NjQKCWZyYW1lX2J1cnkgNyAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoKKmlmNjVfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTExNAoJLy8gc2VnbWVudENvbW1pc3Npb25Ub1BheSA9IHJlbmV3QW10IC0gZ3Jvc3NUb1RyZWFzdXJ5CglmcmFtZV9kaWcgNiAvLyByZW5ld0FtdDogdWludDY0CglmcmFtZV9kaWcgNyAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSA4IC8vIHNlZ21lbnRDb21taXNzaW9uVG9QYXk6IHVpbnQ2NAoJYiAqaWY2M19lbmQKCippZjYzX2Vsc2U6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTE3CgkvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgOCAvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5OiB1aW50NjQKCippZjYzX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExMTkKCS8vIHRoaXMuZG9QYXlvdXRzKAoJLy8gICAgICAgICAgICAgZ3Jvc3NUb1RyZWFzdXJ5LAoJLy8gICAgICAgICAgICAgY29uc3RyYWludERhdGEudHJlYXN1cnlBZGRyZXNzLAoJLy8gICAgICAgICAgICAgMCwKCS8vICAgICAgICAgICAgIHNlZ21lbnRDb21taXNzaW9uVG9QYXksCgkvLyAgICAgICAgICAgICBzZWdtZW50Q29tbWlzc2lvbkFkZHJlc3MsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyA5IC8vIHNlZ21lbnRDb21taXNzaW9uQWRkcmVzczogYWRkcmVzcwoJZnJhbWVfZGlnIDggLy8gc2VnbWVudENvbW1pc3Npb25Ub1BheTogdWludDY0CglpbnRjIDAgLy8gMAoJZnJhbWVfZGlnIDEgLy8gY29uc3RyYWludERhdGE6ICh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAyNCAzMgoJZnJhbWVfZGlnIDcgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCWNhbGxzdWIgZG9QYXlvdXRzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTEyNgoJLy8gdGhpcy5uZmRfcmVuZXdlZC5sb2coewoJLy8gICAgICAgICAgICAgYXBwSWQ6IHRoaXMuYXBwLmlkLAoJLy8gICAgICAgICAgICAgbmFtZTogdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLAoJLy8gICAgICAgICAgICAgb3JpZ093bmVyOiBvcmlnT3duZXIsCgkvLyAgICAgICAgICAgICBidXllcjogcGF5bWVudC5zZW5kZXIsCgkvLyAgICAgICAgICAgICBwcmljZU9uZVllYXI6IHJlcVByaWNlLAoJLy8gICAgICAgICAgICAgcmVuZXdBbW91bnQ6IHBheW1lbnQuYW1vdW50LAoJLy8gICAgICAgICAgICAgZXhwVGltZTogYnRvaSh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfRVhQSVJBVElPTlRJTUUpLnZhbHVlKSwKCS8vICAgICAgICAgfSkKCXB1c2hieXRlcyAweDE0YTc2YTNlIC8vIG5mZF9yZW5ld2VkKHVpbnQ2NCxzdHJpbmcsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZWMgMCAvLyAgaW5pdGlhbCBoZWFkCglieXRlYyAwIC8vICBpbml0aWFsIHRhaWwKCXB1c2hieXRlcyAweDAwNjIgLy8gaW5pdGlhbCBoZWFkIG9mZnNldAoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJYnl0ZWMgNCAvLyAiaS5uYW1lIgoJYXBwX2dsb2JhbF9nZXQKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CgljYWxsc3ViICpwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDQgLy8gb3JpZ093bmVyOiBhZGRyZXNzCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgLTEgLy8gcGF5bWVudDogUGF5VHhuCglndHhucyBTZW5kZXIKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAyIC8vIHJlcVByaWNlOiB1aW50NjQKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMSAvLyBwYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJYnl0ZWMgMTcgLy8gImkuZXhwaXJhdGlvblRpbWUiCglhcHBfZ2xvYmFsX2dldAoJYnRvaQoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJcG9wIC8vIHBvcCBoZWFkIG9mZnNldAoJY29uY2F0IC8vIGNvbmNhdCBoZWFkIGFuZCB0YWlsCgljb25jYXQKCWxvZwoJcmV0c3ViCgovLyBzZXRQcmltYXJ5QWRkcmVzcyhzdHJpbmcsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfc2V0UHJpbWFyeUFkZHJlc3M6CgkvLyBhZGRyZXNzOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGFkZHJlc3MpIGZvciBzZXRQcmltYXJ5QWRkcmVzcyBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZmllbGROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBzZXRQcmltYXJ5QWRkcmVzcyhzdHJpbmcsYWRkcmVzcyl2b2lkCgljYWxsc3ViIHNldFByaW1hcnlBZGRyZXNzCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBzZXRQcmltYXJ5QWRkcmVzcyhmaWVsZE5hbWU6IHN0cmluZywgYWRkcmVzczogQWRkcmVzcyk6IHZvaWQKc2V0UHJpbWFyeUFkZHJlc3M6Cglwcm90byAyIDAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTM5CgkvLyB0aGlzLmFzc2VydE93bmVyQ2FsbGVkTm90Rm9yU2FsZU9yRXhwaXJlZCgpCgljYWxsc3ViIGFzc2VydE93bmVyQ2FsbGVkTm90Rm9yU2FsZU9yRXhwaXJlZAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNDEKCS8vIGFzc2VydChmaWVsZE5hbWUgPT09IE5GRF9GSUVMRF9DQV9WRVJJRklFRF9TRVQpCglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBzdHJpbmcKCXB1c2hieXRlcyAidi5jYUFsZ28uMC5hcyIKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTQyCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNDMKCS8vIHRoaXMuZmluZEFkZHJBbmRTZXRGaXJzdChmaWVsZE5hbWUsIGFkZHJlc3MpCglmcmFtZV9kaWcgLTIgLy8gYWRkcmVzczogQWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkTmFtZTogc3RyaW5nCgljYWxsc3ViIGZpbmRBZGRyQW5kU2V0Rmlyc3QKCXJldHN1YgoKLy8gcmVnaXN0cnlBZGRpbmdWZXJpZmllZEFkZHJlc3Moc3RyaW5nLHN0cmluZylib29sCiphYmlfcm91dGVfcmVnaXN0cnlBZGRpbmdWZXJpZmllZEFkZHJlc3M6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDExIC8vIDB4MTUxZjdjNzUKCgkvLyBmaWVsZFNldE5hbWU6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZXh0cmFjdCAyIDAKCgkvLyBmaWVsZEJlaW5nVmVyaWZpZWQ6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIHJlZ2lzdHJ5QWRkaW5nVmVyaWZpZWRBZGRyZXNzKHN0cmluZyxzdHJpbmcpYm9vbAoJY2FsbHN1YiByZWdpc3RyeUFkZGluZ1ZlcmlmaWVkQWRkcmVzcwoJYnl0ZWMgMjkgLy8gMHgwMAoJaW50YyAwIC8vIDAKCXVuY292ZXIgMgoJc2V0Yml0Cgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gcmVnaXN0cnlBZGRpbmdWZXJpZmllZEFkZHJlc3MoZmllbGRCZWluZ1ZlcmlmaWVkOiBzdHJpbmcsIGZpZWxkU2V0TmFtZTogc3RyaW5nKTogYm9vbGVhbgovLwovLyBBcHByb3ZlZCBjYWxsIGZyb20gcmVnaXN0cnkgaW5zdHJ1Y3RpbmcgdXMgdG8gbW92ZSB0aGUgc3BlY2lmaWVkIHUuY2F2Lnh4IGZpZWxkIGFuZCBhZGQgdG8gdGhlIHNwZWNpZmllZAovLyB2ZXJpZmllZCBmaWVsZC4KLy8KLy8gQHBhcmFtIGZpZWxkQmVpbmdWZXJpZmllZCAtIHt1c2VyLWRlZmluZWQgZmllbGQgdG8gJ3ZlcmlmeScgLSBieSBhZGRpbmcgdG8gc3BlY2lmaWVkIHZlcmlmaWVkIHNldAovLyBpZTogdS5jYXYuYWxnby5hIC0gdXNlci1kZWZpbmVkIHByZS12ZXJpZnl9IC0gTVVTVCBTVEFSVCB3aXRoIHUuY2F2LiAoISkKLy8gZ2V0cyAnYWRkZWQnIHRvICdzZXQnIGluIG5leHQgYXJnIC0gbXVzdCBiZSBmaXhlZC1zaXplZCBieXRlcwovLyBAcGFyYW0gZmllbGRTZXROYW1lIC0ge2ZpZWxkIHNldCBuYW1lIC0gaWU6IHYuY2FBbGdvLjAuYXMsIHYuY2FFdGguMC5hc30gKG11c3QgQkUgdi5jYVsuLi5dLmFzKQovLyBAcmV0dXJucyB0cnVlIGlmIGFkZGVkIG9yIGFscmVhZHkgcHJlc2VudCwgZmFsc2Ugb3RoZXJ3aXNlCnJlZ2lzdHJ5QWRkaW5nVmVyaWZpZWRBZGRyZXNzOgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTU3CgkvLyBhc3NlcnQoZ2xvYmFscy5jYWxsZXJBcHBsaWNhdGlvbklEID09PSBBcHBJRC5mcm9tVWludDY0KHRoaXMucmVnaXN0cnlBcHBJZCksICdjYWxsZXIgbXVzdCBiZSBORkQgcmVnaXN0cnkhJykKCWdsb2JhbCBDYWxsZXJBcHBsaWNhdGlvbklECglpbnRjIDQgLy8gVE1QTF9yZWdpc3RyeUFwcElkCgk9PQoKCS8vIGNhbGxlciBtdXN0IGJlIE5GRCByZWdpc3RyeSEKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNTgKCS8vIHRoaXMubm90Rm9yU2FsZU9yRXhwaXJlZCgpCgljYWxsc3ViIG5vdEZvclNhbGVPckV4cGlyZWQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTU5CgkvLyBhc3NlcnQoZXh0cmFjdDMoZmllbGRCZWluZ1ZlcmlmaWVkLCAwLCA2KSA9PT0gJ3UuY2F2LicsICdmaWVsZCBiZWluZyB2ZXJpZmllZCBNVVNUIFNUQVJUIHdpdGggdS5jYXYnKQoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkQmVpbmdWZXJpZmllZDogc3RyaW5nCglleHRyYWN0IDAgNgoJcHVzaGJ5dGVzIDB4NzUyZTYzNjE3NjJlIC8vICJ1LmNhdi4iCgk9PQoKCS8vIGZpZWxkIGJlaW5nIHZlcmlmaWVkIE1VU1QgU1RBUlQgd2l0aCB1LmNhdgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTE2MAoJLy8gYXNzZXJ0KGV4dHJhY3QzKGZpZWxkU2V0TmFtZSwgMCwgNCkgPT09ICd2LmNhJywgJ2Rlc3RpbmF0aW9uIGZpZWxkIE1VU1QgU1RBUlQgd2l0aCB2LmNhWy4uLi5dJykKCWZyYW1lX2RpZyAtMiAvLyBmaWVsZFNldE5hbWU6IHN0cmluZwoJZXh0cmFjdCAwIDQKCWJ5dGVjIDM4IC8vICAidi5jYSIKCT09CgoJLy8gZGVzdGluYXRpb24gZmllbGQgTVVTVCBTVEFSVCB3aXRoIHYuY2FbLi4uLl0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNjEKCS8vIGFzc2VydChleHRyYWN0MyhmaWVsZFNldE5hbWUsIGxlbihmaWVsZFNldE5hbWUpIC0gMywgMykgPT09ICcuYXMnLCAnZGVzdGluYXRpb24gZmllbGQgbXVzdCBlbmQgRU5EIHdpdGggLmFzJykKCWZyYW1lX2RpZyAtMiAvLyBmaWVsZFNldE5hbWU6IHN0cmluZwoJZnJhbWVfZGlnIC0yIC8vIGZpZWxkU2V0TmFtZTogc3RyaW5nCglsZW4KCWludGMgNiAvLyAzCgktCglpbnRjIDYgLy8gMwoJZXh0cmFjdDMKCWJ5dGVjIDM5IC8vICAiLmFzIgoJPT0KCgkvLyBkZXN0aW5hdGlvbiBmaWVsZCBtdXN0IGVuZCBFTkQgd2l0aCAuYXMKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNjIKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIHRoaXMuYm94ZXMoZmllbGRCZWluZ1ZlcmlmaWVkKS5leGlzdHMsCgkvLyAgICAgICAgICAgICAncmVmZXJlbmNlZCBmaWVsZCB0byBhZGQgYXMgdmVyaWZpZWQgYWRkcmVzcyBtdXN0IGhhdmUgdmFsdWUgaW4gYm94IHN0b3JhZ2UnLAoJLy8gICAgICAgICApCglmcmFtZV9kaWcgLTEgLy8gZmllbGRCZWluZ1ZlcmlmaWVkOiBzdHJpbmcKCWJveF9sZW4KCXN3YXAKCXBvcAoKCS8vIHJlZmVyZW5jZWQgZmllbGQgdG8gYWRkIGFzIHZlcmlmaWVkIGFkZHJlc3MgbXVzdCBoYXZlIHZhbHVlIGluIGJveCBzdG9yYWdlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTY2CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNjgKCS8vIGZpZWxkVmFsdWUgPSB0aGlzLmJveGVzKGZpZWxkQmVpbmdWZXJpZmllZCkudmFsdWUKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEJlaW5nVmVyaWZpZWQ6IHN0cmluZwoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5ib3hlcyhmaWVsZEJlaW5nVmVyaWZpZWQpLnZhbHVlCglhc3NlcnQKCWZyYW1lX2J1cnkgMCAvLyBmaWVsZFZhbHVlOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTY5CgkvLyB0aGlzLmJveGVzKGZpZWxkQmVpbmdWZXJpZmllZCkuZGVsZXRlKCkKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEJlaW5nVmVyaWZpZWQ6IHN0cmluZwoJYm94X2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNzEKCS8vIHRoaXMubmZkX2FkZHJlc3NMaW5rZWQubG9nKHsKCS8vICAgICAgICAgICAgIGFwcElkOiB0aGlzLmFwcC5pZCwKCS8vICAgICAgICAgICAgIG5hbWU6IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9OQU1FKS52YWx1ZSwKCS8vICAgICAgICAgICAgIGFkZHJlc3M6IEFkZHJlc3MuZnJvbUJ5dGVzKGZpZWxkVmFsdWUpLAoJLy8gICAgICAgICB9KQoJcHVzaGJ5dGVzIDB4Y2Y5ZDFlMjQgLy8gbmZkX2FkZHJlc3NMaW5rZWQodWludDY0LHN0cmluZyxhZGRyZXNzKQoJYnl0ZWMgMCAvLyAgaW5pdGlhbCBoZWFkCglieXRlYyAwIC8vICBpbml0aWFsIHRhaWwKCWJ5dGVjIDQyIC8vICBpbml0aWFsIGhlYWQgb2Zmc2V0Cgl0eG5hIEFwcGxpY2F0aW9ucyAwCglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglieXRlYyA0IC8vICJpLm5hbWUiCglhcHBfZ2xvYmFsX2dldAoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNhbGxzdWIgKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgMCAvLyBmaWVsZFZhbHVlOiBieXRlW10KCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoJY29uY2F0Cglsb2cKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTc3CgkvLyByZXR1cm4gdGhpcy5hZGRCeXRlc1RvU2V0KGZpZWxkU2V0TmFtZSwgZmllbGRWYWx1ZSkKCWZyYW1lX2RpZyAwIC8vIGZpZWxkVmFsdWU6IGJ5dGVbXQoJZnJhbWVfZGlnIC0yIC8vIGZpZWxkU2V0TmFtZTogc3RyaW5nCgljYWxsc3ViIGFkZEJ5dGVzVG9TZXQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gcmVnaXN0cnlSZW1vdmluZ1ZlcmlmaWVkQWRkcmVzcyhzdHJpbmcsYWRkcmVzcyxhZGRyZXNzKWJvb2wKKmFiaV9yb3V0ZV9yZWdpc3RyeVJlbW92aW5nVmVyaWZpZWRBZGRyZXNzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAxMSAvLyAweDE1MWY3Yzc1CgoJLy8gbWJyUmVmdW5kRGVzdDogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludGMgMyAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChtYnJSZWZ1bmREZXN0KSBmb3IgcmVnaXN0cnlSZW1vdmluZ1ZlcmlmaWVkQWRkcmVzcyBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gYWRkcmVzczogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMyAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAxIChhZGRyZXNzKSBmb3IgcmVnaXN0cnlSZW1vdmluZ1ZlcmlmaWVkQWRkcmVzcyBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZmllbGRCZWluZ0NoYW5nZWQ6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIHJlZ2lzdHJ5UmVtb3ZpbmdWZXJpZmllZEFkZHJlc3Moc3RyaW5nLGFkZHJlc3MsYWRkcmVzcylib29sCgljYWxsc3ViIHJlZ2lzdHJ5UmVtb3ZpbmdWZXJpZmllZEFkZHJlc3MKCWJ5dGVjIDI5IC8vIDB4MDAKCWludGMgMCAvLyAwCgl1bmNvdmVyIDIKCXNldGJpdAoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHJlZ2lzdHJ5UmVtb3ZpbmdWZXJpZmllZEFkZHJlc3MoZmllbGRCZWluZ0NoYW5nZWQ6IHN0cmluZywgYWRkcmVzczogQWRkcmVzcywgbWJyUmVmdW5kRGVzdDogQWRkcmVzcyk6IGJvb2xlYW4KLy8KLy8gQXBwcm92ZWQgY2FsbCBmcm9tIHJlZ2lzdHJ5IGluc3RydWN0aW5nIHVzIHRvIFJFTU9WRSBhbiBhZGRyZXNzIGZyb20gdGhlIHNwZWNpZmllZCB2ZXJpZmllZCBhZGRyZXNzIHNldAovLwovLyBAcGFyYW0ge3N0cmluZ30gZmllbGRCZWluZ0NoYW5nZWQgLSBUaGUgZmllbGQgYmVpbmcgY2hhbmdlZCBpbiB0aGUgYWRkcmVzcyByZWdpc3RyeS4KLy8gQHBhcmFtIHtBZGRyZXNzfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBmaWVsZC4KLy8gQHBhcmFtIHtBZGRyZXNzfSBtYnJSZWZ1bmREZXN0IC0gdGhlIGFkZHJlc3MgdG8gc2VuZCByZWNsYWltZWQgTUJSIChpZiBhbnkpCi8vIEByZXR1cm4ge2Jvb2xlYW59IC0gdHJ1ZSBpZiB2YWxpZCByZW1vdmVkCnJlZ2lzdHJ5UmVtb3ZpbmdWZXJpZmllZEFkZHJlc3M6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTE4OQoJLy8gYXNzZXJ0KGdsb2JhbHMuY2FsbGVyQXBwbGljYXRpb25JRCA9PT0gQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnJlZ2lzdHJ5QXBwSWQpLCAnY2FsbGVyIG11c3QgYmUgTkZEIHJlZ2lzdHJ5IScpCglnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAoJaW50YyA0IC8vIFRNUExfcmVnaXN0cnlBcHBJZAoJPT0KCgkvLyBjYWxsZXIgbXVzdCBiZSBORkQgcmVnaXN0cnkhCglhc3NlcnQKCgkvLyAqaWY2Nl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExOTEKCS8vICF0aGlzLmlzRXhwaXJlZCgpCgljYWxsc3ViIGlzRXhwaXJlZAoJIQoJYnogKmlmNjZfZW5kCgoJLy8gKmlmNjZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTE5MgoJLy8gYXNzZXJ0KCF0aGlzLmlzRm9yU2FsZSgpLCAiY2FuJ3QgYmUgZm9yIHNhbGUiKQoJY2FsbHN1YiBpc0ZvclNhbGUKCSEKCgkvLyBjYW4ndCBiZSBmb3Igc2FsZQoJYXNzZXJ0CgoqaWY2Nl9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTk0CgkvLyBhc3NlcnQoZXh0cmFjdDMoZmllbGRCZWluZ0NoYW5nZWQsIDAsIDQpID09PSAndi5jYScsICd2ZXJpZmllZCBmaWVsZCBNVVNUIFNUQVJUIHdpdGggdi5jYVsuLi4uXScpCglmcmFtZV9kaWcgLTEgLy8gZmllbGRCZWluZ0NoYW5nZWQ6IHN0cmluZwoJZXh0cmFjdCAwIDQKCWJ5dGVjIDM4IC8vICAidi5jYSIKCT09CgoJLy8gdmVyaWZpZWQgZmllbGQgTVVTVCBTVEFSVCB3aXRoIHYuY2FbLi4uLl0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExOTUKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIGV4dHJhY3QzKGZpZWxkQmVpbmdDaGFuZ2VkLCBsZW4oZmllbGRCZWluZ0NoYW5nZWQpIC0gMywgMykgPT09ICcuYXMnLAoJLy8gICAgICAgICAgICAgJ3ZlcmlmaWVkIGZpZWxkIG11c3QgZW5kIEVORCB3aXRoIC5hcycsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEJlaW5nQ2hhbmdlZDogc3RyaW5nCglmcmFtZV9kaWcgLTEgLy8gZmllbGRCZWluZ0NoYW5nZWQ6IHN0cmluZwoJbGVuCglpbnRjIDYgLy8gMwoJLQoJaW50YyA2IC8vIDMKCWV4dHJhY3QzCglieXRlYyAzOSAvLyAgIi5hcyIKCT09CgoJLy8gdmVyaWZpZWQgZmllbGQgbXVzdCBlbmQgRU5EIHdpdGggLmFzCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTk5CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyMDEKCS8vIGV4aXN0aW5nU2l6ZSA9IHRoaXMuYm94ZXMoZmllbGRCZWluZ0NoYW5nZWQpLnNpemUKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEJlaW5nQ2hhbmdlZDogc3RyaW5nCglib3hfbGVuCgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKGZpZWxkQmVpbmdDaGFuZ2VkKS5zaXplCglhc3NlcnQKCWZyYW1lX2J1cnkgMCAvLyBleGlzdGluZ1NpemU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyMDIKCS8vIHJlbW92ZWQgPSB0aGlzLnJlbW92ZUFkZHJGcm9tU2V0KGZpZWxkQmVpbmdDaGFuZ2VkLCBhZGRyZXNzKQoJZnJhbWVfZGlnIC0yIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEJlaW5nQ2hhbmdlZDogc3RyaW5nCgljYWxsc3ViIHJlbW92ZUFkZHJGcm9tU2V0CglmcmFtZV9idXJ5IDEgLy8gcmVtb3ZlZDogYm9vbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyMDQKCS8vIHRoaXMubmZkX2FkZHJlc3NVbmxpbmtlZC5sb2coewoJLy8gICAgICAgICAgICAgYXBwSWQ6IHRoaXMuYXBwLmlkLAoJLy8gICAgICAgICAgICAgbmFtZTogdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLAoJLy8gICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcywKCS8vICAgICAgICAgfSkKCXB1c2hieXRlcyAweGE0ZDNiOWE3IC8vIG5mZF9hZGRyZXNzVW5saW5rZWQodWludDY0LHN0cmluZyxhZGRyZXNzKQoJYnl0ZWMgMCAvLyAgaW5pdGlhbCBoZWFkCglieXRlYyAwIC8vICBpbml0aWFsIHRhaWwKCWJ5dGVjIDQyIC8vICBpbml0aWFsIGhlYWQgb2Zmc2V0Cgl0eG5hIEFwcGxpY2F0aW9ucyAwCglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglieXRlYyA0IC8vICJpLm5hbWUiCglhcHBfZ2xvYmFsX2dldAoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNhbGxzdWIgKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgLTIgLy8gYWRkcmVzczogQWRkcmVzcwoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJcG9wIC8vIHBvcCBoZWFkIG9mZnNldAoJY29uY2F0IC8vIGNvbmNhdCBoZWFkIGFuZCB0YWlsCgljb25jYXQKCWxvZwoKCS8vICppZjY3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIxMAoJLy8gIXRoaXMuYm94ZXMoZmllbGRCZWluZ0NoYW5nZWQpLmV4aXN0cwoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkQmVpbmdDaGFuZ2VkOiBzdHJpbmcKCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYnogKmlmNjdfZW5kCgoJLy8gKmlmNjdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIxMgoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgICAgICAgICAgIGFtb3VudDogU0NCT1hfUEVSQk9YICsgU0NCT1hfUEVSQllURSAqIChmaWVsZEJlaW5nQ2hhbmdlZC5sZW5ndGggKyBleGlzdGluZ1NpemUpLAoJLy8gICAgICAgICAgICAgICAgIHJlY2VpdmVyOiBtYnJSZWZ1bmREZXN0LAoJLy8gICAgICAgICAgICAgICAgIG5vdGU6ICdib3hSZWZ1bmQnLAoJLy8gICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIxMwoJLy8gYW1vdW50OiBTQ0JPWF9QRVJCT1ggKyBTQ0JPWF9QRVJCWVRFICogKGZpZWxkQmVpbmdDaGFuZ2VkLmxlbmd0aCArIGV4aXN0aW5nU2l6ZSkKCWludGMgMTIgLy8gMjUwMAoJaW50YyA5IC8vIDQwMAoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkQmVpbmdDaGFuZ2VkOiBzdHJpbmcKCWxlbgoJZnJhbWVfZGlnIDAgLy8gZXhpc3RpbmdTaXplOiB1aW50NjQKCSsKCSoKCSsKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIxNAoJLy8gcmVjZWl2ZXI6IG1iclJlZnVuZERlc3QKCWZyYW1lX2RpZyAtMyAvLyBtYnJSZWZ1bmREZXN0OiBBZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIxNQoJLy8gbm90ZTogJ2JveFJlZnVuZCcKCWJ5dGVjIDMxIC8vICAiYm94UmVmdW5kIgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmNjdfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIxOQoJLy8gcmV0dXJuIHJlbW92ZWQKCWZyYW1lX2RpZyAxIC8vIHJlbW92ZWQ6IGJvb2wKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxCglyZXRzdWIKCi8vIGdldFJlbmV3UHJpY2VEYXRhKGNhbGxlcjogQWRkcmVzcyk6IFByaWNlSW5mbwovLwovLyBSZXRyaWV2ZXMgdGhlIHJlbmV3IHByaWNlIGRhdGEgZm9yIGEgZ2l2ZW4gc2VuZGVyIGFkZHJlc3MuCi8vCi8vIEBwYXJhbSBjYWxsZXIgLSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VuZGVyLgovLyBAcmV0dXJucyB7UHJpY2VJbmZvfQpnZXRSZW5ld1ByaWNlRGF0YToKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyMzAKCS8vIHJldHVybiBzZW5kTWV0aG9kQ2FsbDx0eXBlb2YgTkZEUmVnaXN0cnkucHJvdG90eXBlLmdldFByaWNlPih7CgkvLyAgICAgICAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KHRoaXMucmVnaXN0cnlBcHBJZCksCgkvLyAgICAgICAgICAgICBtZXRob2RBcmdzOiBbdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLCBjYWxsZXJdLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyA3IC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglwdXNoYnl0ZXMgMHhmZmMyMzAzYyAvLyBtZXRob2QgImdldFByaWNlKHN0cmluZyxhZGRyZXNzKSh1aW50NjQsdWludDY0LGJvb2wsYm9vbCxib29sKSIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIzMQoJLy8gYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnJlZ2lzdHJ5QXBwSWQpCglpbnRjIDQgLy8gVE1QTF9yZWdpc3RyeUFwcElkCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjMyCgkvLyBtZXRob2RBcmdzOiBbdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLCBjYWxsZXJdCglieXRlYyA0IC8vICJpLm5hbWUiCglhcHBfZ2xvYmFsX2dldAoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgLTEgLy8gY2FsbGVyOiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gTnVtTG9ncwoJaW50YyAxIC8vIDEKCS0KCWl0eG5hcyBMb2dzCglleHRyYWN0IDQgMAoJcmV0c3ViCgovLyB2YXVsdE9wdEluRnJvbUFyZ3MoKTogdm9pZAp2YXVsdE9wdEluRnJvbUFyZ3M6Cglwcm90byAwIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI0MwoJLy8gdGhpcy5ub3RGb3JTYWxlT3JFeHBpcmVkKCkKCWNhbGxzdWIgbm90Rm9yU2FsZU9yRXhwaXJlZAoKCS8vICppZjY4X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI0NwoJLy8gdGhpcy5pc1ZhdWx0QXV0b09wdEluTG9ja2VkKCkKCWNhbGxzdWIgaXNWYXVsdEF1dG9PcHRJbkxvY2tlZAoJYnogKmlmNjhfZW5kCgoJLy8gKmlmNjhfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI0OAoJLy8gYXNzZXJ0KHJhd0J5dGVzKHRoaXMudHhuLnNlbmRlcikgPT09IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUsICdzZW5kZXIgbXVzdCBiZSBvd25lcicpCgl0eG4gU2VuZGVyCglieXRlYyAxIC8vICJpLm93bmVyLmEiCglhcHBfZ2xvYmFsX2dldAoJPT0KCgkvLyBzZW5kZXIgbXVzdCBiZSBvd25lcgoJYXNzZXJ0CgoqaWY2OF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjUxCgkvLyBhc3NlcnQodGhpcy50eG4uZ3JvdXBJbmRleCA+IDAsICdwYXJ0IG9mIG9wdC1pbiBmb3IgbmV3IGFzc2V0LCBtdXN0IGhhdmUgcHJpb3IgdHhuIHBheWluZyBNQlInKQoJdHhuIEdyb3VwSW5kZXgKCWludGMgMCAvLyAwCgk+CgoJLy8gcGFydCBvZiBvcHQtaW4gZm9yIG5ldyBhc3NldCwgbXVzdCBoYXZlIHByaW9yIHR4biBwYXlpbmcgTUJSCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjUzCgkvLyB2ZXJpZnlQYXlUeG4odGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4IC0gMV0sIHsKCS8vICAgICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICAgICAgYW1vdW50OiAxMDBfMDAwICogKHRoaXMudHhuLm51bUFwcEFyZ3MgLSAxKSwKCS8vICAgICAgICAgfSkKCXR4biBHcm91cEluZGV4CglpbnRjIDEgLy8gMQoJLQoJc3RvcmUgMjQ4IC8vIHZlcmlmeVR4biBpbmRleAoKCS8vIHZlcmlmeSBwYXkKCWxvYWQgMjQ4IC8vIHZlcmlmeVR4biBpbmRleAoJZ3R4bnMgVHlwZUVudW0KCWludGMgMSAvLyAgcGF5Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoidGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4IC0gMV0iLCJmaWVsZCI6InR5cGVFbnVtIiwiZXhwZWN0ZWQiOiJwYXkifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHJlY2VpdmVyCglsb2FkIDI0OCAvLyB2ZXJpZnlUeG4gaW5kZXgKCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InRoaXMudHhuR3JvdXBbdGhpcy50eG4uZ3JvdXBJbmRleCAtIDFdIiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50Cglsb2FkIDI0OCAvLyB2ZXJpZnlUeG4gaW5kZXgKCWd0eG5zIEFtb3VudAoJaW50YyAxNiAvLyAxMDBfMDAwCgl0eG4gTnVtQXBwQXJncwoJaW50YyAxIC8vIDEKCS0KCSoKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJ0aGlzLnR4bkdyb3VwW3RoaXMudHhuLmdyb3VwSW5kZXggLSAxXSIsImZpZWxkIjoiYW1vdW50IiwiZXhwZWN0ZWQiOiIxMDBfMDAwICogKHRoaXMudHhuLm51bUFwcEFyZ3MgLSAxKSJ9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjU3CgkvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAxOyBpIDwgdGhpcy50eG4ubnVtQXBwQXJnczsgaSArPSAxKQoJaW50YyAxIC8vIDEKCWZyYW1lX2J1cnkgMCAvLyBpOiB1aW50NjQKCipmb3JfODoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNTcKCS8vIGkgPCB0aGlzLnR4bi5udW1BcHBBcmdzCglmcmFtZV9kaWcgMCAvLyBpOiB1aW50NjQKCXR4biBOdW1BcHBBcmdzCgk8CglieiAqZm9yXzhfZW5kCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI1OAoJLy8gYXNzZXRJZCA9IEFzc2V0SUQuZnJvbVVpbnQ2NChidG9pKHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbaV0pKQoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0Cgl0eG5hcyBBcHBsaWNhdGlvbkFyZ3MKCWJ0b2kKCWZyYW1lX2J1cnkgMSAvLyBhc3NldElkOiB1aW50NjQKCgkvLyAqaWY2OV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNjAKCS8vICF0aGlzLmFwcC5hZGRyZXNzLmlzT3B0ZWRJblRvQXNzZXQoYXNzZXRJZCkKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglmcmFtZV9kaWcgMSAvLyBhc3NldElkOiB1aW50NjQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJc3dhcAoJcG9wCgkhCglieiAqaWY2OV9lbmQKCgkvLyAqaWY2OV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjYxCgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICAgICAgICAgICAgICAgIHhmZXJBc3NldDogYXNzZXRJZCwKCS8vICAgICAgICAgICAgICAgICAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgICAgICAgICAgICAgICAgYXNzZXRBbW91bnQ6IDAsCgkvLyAgICAgICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMTAgLy8gIGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI2MgoJLy8geGZlckFzc2V0OiBhc3NldElkCglmcmFtZV9kaWcgMSAvLyBhc3NldElkOiB1aW50NjQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI2MwoJLy8gYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNjQKCS8vIGFzc2V0QW1vdW50OiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCippZjY5X2VuZDoKCipmb3JfOF9jb250aW51ZToKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNTcKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAwIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzgKCipmb3JfOF9lbmQ6CglyZXRzdWIKCi8vIHNhZmVHbG9iYWxCeXRlR2V0KGtleTogYnl0ZXMpOiBieXRlcwpzYWZlR2xvYmFsQnl0ZUdldDoKCXByb3RvIDEgMQoKCS8vICppZjcwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI3MQoJLy8gIXRoaXMuZ2xvYmFsU3RhdGUoa2V5KS5leGlzdHMKCXR4bmEgQXBwbGljYXRpb25zIDAKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglieiAqaWY3MF9lbmQKCgkvLyAqaWY3MF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjcyCgkvLyByZXR1cm4gJycKCWJ5dGVjIDAgLy8gICIiCglyZXRzdWIKCippZjcwX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNzQKCS8vIHJldHVybiB0aGlzLmdsb2JhbFN0YXRlKGtleSkudmFsdWUKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglhcHBfZ2xvYmFsX2dldAoJcmV0c3ViCgovLyBzYWZlR2xvYmFsQnl0ZUdldEV4KGFwcElkOiB1aW50NjQsIGtleTogYnl0ZXMpOiBieXRlcwpzYWZlR2xvYmFsQnl0ZUdldEV4OgoJcHJvdG8gMiAxCgoJLy8gKmlmNzFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjc4CgkvLyAhQXBwSUQuZnJvbVVpbnQ2NChhcHBJZCkuZ2xvYmFsU3RhdGVFeGlzdHMoa2V5KQoJZnJhbWVfZGlnIC0xIC8vIGFwcElkOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBrZXk6IGJ5dGVzCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglieiAqaWY3MV9lbmQKCgkvLyAqaWY3MV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjc5CgkvLyByZXR1cm4gJycKCWJ5dGVjIDAgLy8gICIiCglyZXRzdWIKCippZjcxX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyODEKCS8vIHJldHVybiBBcHBJRC5mcm9tVWludDY0KGFwcElkKS5nbG9iYWxTdGF0ZShrZXkpIGFzIGJ5dGVzCglmcmFtZV9kaWcgLTEgLy8gYXBwSWQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIGtleTogYnl0ZXMKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KGFwcElkKS5nbG9iYWxTdGF0ZShrZXkpCglhc3NlcnQKCXJldHN1YgoKLy8gc2FmZUdsb2JhbEludEdldChrZXk6IGJ5dGVzKTogdWludDY0CnNhZmVHbG9iYWxJbnRHZXQ6Cglwcm90byAxIDEKCgkvLyAqaWY3Ml9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyODUKCS8vICF0aGlzLmdsb2JhbFN0YXRlKGtleSkuZXhpc3RzCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglmcmFtZV9kaWcgLTEgLy8ga2V5OiBieXRlcwoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoJYnogKmlmNzJfZW5kCgoJLy8gKmlmNzJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI4NgoJLy8gcmV0dXJuIDAKCWludGMgMCAvLyAwCglyZXRzdWIKCippZjcyX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyODgKCS8vIHJldHVybiBidG9pKHRoaXMuZ2xvYmFsU3RhdGUoa2V5KS52YWx1ZSkKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglhcHBfZ2xvYmFsX2dldAoJYnRvaQoJcmV0c3ViCgovLyBpc0N1cnJlbnRUeG5Db250cmFjdEF1dGhvcml0eSgpOiBib29sZWFuCmlzQ3VycmVudFR4bkNvbnRyYWN0QXV0aG9yaXR5OgoJcHJvdG8gMCAxCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI5NAoJLy8gcmV0dXJuIHRoaXMudHhuLnNlbmRlci5hc3NldEJhbGFuY2UodGhpcy5hZG1pbkFzYUlkKSA9PT0gMQoJdHhuIFNlbmRlcgoJaW50YyAyMCAvLyBUTVBMX2FkbWluQXNhSWQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJcG9wCglpbnRjIDEgLy8gMQoJPT0KCXJldHN1YgoKLy8gaXNGaWVsZERlbGV0ZUFsbG93ZWQoZmllbGROYW1lOiBieXRlcywgYWRtaW5SaWdodHM6IGJvb2xlYW4pOiBib29sZWFuCmlzRmllbGREZWxldGVBbGxvd2VkOgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzEyCgkvLyB0cnVzdFR5cGUgPSBleHRyYWN0MyhmaWVsZE5hbWUsIDAsIDIpCglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBieXRlcwoJZXh0cmFjdCAwIDIKCWZyYW1lX2J1cnkgMCAvLyB0cnVzdFR5cGU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzMTQKCS8vIGFzc2VydCghdGhpcy5pc0ludGVybmFsRmllbGQodHJ1c3RUeXBlKSwgJ2ludGVybmFsIGZpZWxkcyBjYW4gbmV2ZXIgYmUgZGVsZXRlZCcpCglmcmFtZV9kaWcgMCAvLyB0cnVzdFR5cGU6IGJ5dGVbXQoJY2FsbHN1YiBpc0ludGVybmFsRmllbGQKCSEKCgkvLyBpbnRlcm5hbCBmaWVsZHMgY2FuIG5ldmVyIGJlIGRlbGV0ZWQKCWFzc2VydAoKCS8vICppZjczX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTMxNwoJLy8gYWRtaW5SaWdodHMKCWZyYW1lX2RpZyAtMiAvLyBhZG1pblJpZ2h0czogYm9vbGVhbgoJYnogKmlmNzNfZW5kCgoJLy8gKmlmNzNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTMxOAoJLy8gcmV0dXJuIHRydWUKCWludGMgMSAvLyAxCgliICppc0ZpZWxkRGVsZXRlQWxsb3dlZCpyZXR1cm4KCippZjczX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzMjEKCS8vIGFzc2VydChsZW4odGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX09XTkVSKSkgPT09IDMyLCAnbXVzdCBiZSBvd25lZCcpCglieXRlYyAxIC8vICJpLm93bmVyLmEiCgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0CglsZW4KCWludGMgMyAvLyAzMgoJPT0KCgkvLyBtdXN0IGJlIG93bmVkCglhc3NlcnQKCgkvLyAqaWY3NF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzMjMKCS8vICF0aGlzLmlzRXhwaXJlZCgpCgljYWxsc3ViIGlzRXhwaXJlZAoJIQoJYnogKmlmNzRfZW5kCgoJLy8gKmlmNzRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTMyNAoJLy8gYXNzZXJ0KCF0aGlzLmlzRm9yU2FsZSgpLCAiY2FuJ3QgYmUgZm9yIHNhbGUiKQoJY2FsbHN1YiBpc0ZvclNhbGUKCSEKCgkvLyBjYW4ndCBiZSBmb3Igc2FsZQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTMyNQoJLy8gdGhpcy5tdXN0QmVDYWxsZWRCeU93bmVyKCkKCWNhbGxzdWIgbXVzdEJlQ2FsbGVkQnlPd25lcgoKKmlmNzRfZW5kOgoJLy8gKmlmNzVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzI4CgkvLyB0aGlzLmlzVXNlckZpZWxkKHRydXN0VHlwZSkKCWZyYW1lX2RpZyAwIC8vIHRydXN0VHlwZTogYnl0ZVtdCgljYWxsc3ViIGlzVXNlckZpZWxkCglieiAqaWY3NV9lbmQKCgkvLyAqaWY3NV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzI5CgkvLyByZXR1cm4gdHJ1ZQoJaW50YyAxIC8vIDEKCWIgKmlzRmllbGREZWxldGVBbGxvd2VkKnJldHVybgoKKmlmNzVfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTMzMgoJLy8gcmV0dXJuIHRoaXMuaXNWZXJpZmllZEZpZWxkKHRydXN0VHlwZSkgJiYgIShleHRyYWN0MyhmaWVsZE5hbWUsIDAsIDgpID09PSAndi5jYUFsZ28nKQoJZnJhbWVfZGlnIDAgLy8gdHJ1c3RUeXBlOiBieXRlW10KCWNhbGxzdWIgaXNWZXJpZmllZEZpZWxkCglkdXAKCWJ6ICpza2lwX2FuZDE3CglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBieXRlcwoJZXh0cmFjdCAwIDgKCWJ5dGVjIDMzIC8vICAidi5jYUFsZ28iCgk9PQoJIQoJJiYKCipza2lwX2FuZDE3OgoKKmlzRmllbGREZWxldGVBbGxvd2VkKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBpc0ZpZWxkVXBkYXRlQWxsb3dlZChuYW1lOiBieXRlcywgdmFsdWU6IGJ5dGVzLCBhZG1pblJpZ2h0czogYm9vbGVhbik6IGJvb2xlYW4KaXNGaWVsZFVwZGF0ZUFsbG93ZWQ6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiAyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM0OAoJLy8gdHJ1c3RUeXBlID0gZXh0cmFjdDMobmFtZSwgMCwgMikKCWZyYW1lX2RpZyAtMSAvLyBuYW1lOiBieXRlcwoJZXh0cmFjdCAwIDIKCWZyYW1lX2J1cnkgMCAvLyB0cnVzdFR5cGU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzNTAKCS8vIGFzc2VydCghdGhpcy5pc0ludGVybmFsRmllbGQodHJ1c3RUeXBlKSwgJ2ludGVybmFsIGZpZWxkcyBjYW4gbmV2ZXIgYmUgdXBkYXRlZCcpCglmcmFtZV9kaWcgMCAvLyB0cnVzdFR5cGU6IGJ5dGVbXQoJY2FsbHN1YiBpc0ludGVybmFsRmllbGQKCSEKCgkvLyBpbnRlcm5hbCBmaWVsZHMgY2FuIG5ldmVyIGJlIHVwZGF0ZWQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzNTEKCS8vIGlzVXNlckZpZWxkID0gdGhpcy5pc1VzZXJGaWVsZCh0cnVzdFR5cGUpCglmcmFtZV9kaWcgMCAvLyB0cnVzdFR5cGU6IGJ5dGVbXQoJY2FsbHN1YiBpc1VzZXJGaWVsZAoJZnJhbWVfYnVyeSAxIC8vIGlzVXNlckZpZWxkOiBib29sCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM1MgoJLy8gaXNWZXJpZmllZEZpZWxkID0gdGhpcy5pc1ZlcmlmaWVkRmllbGQodHJ1c3RUeXBlKQoJZnJhbWVfZGlnIDAgLy8gdHJ1c3RUeXBlOiBieXRlW10KCWNhbGxzdWIgaXNWZXJpZmllZEZpZWxkCglmcmFtZV9idXJ5IDIgLy8gaXNWZXJpZmllZEZpZWxkOiBib29sCgoJLy8gKmlmNzZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzU0CgkvLyBhZG1pblJpZ2h0cyAmJiAoaXNWZXJpZmllZEZpZWxkIHx8IChpc1VzZXJGaWVsZCAmJiBsZW4odmFsdWUpID09PSAwKSkKCWZyYW1lX2RpZyAtMyAvLyBhZG1pblJpZ2h0czogYm9vbGVhbgoJZHVwCglieiAqc2tpcF9hbmQxOAoJZnJhbWVfZGlnIDIgLy8gaXNWZXJpZmllZEZpZWxkOiBib29sCglkdXAKCWJueiAqc2tpcF9vcjMKCWZyYW1lX2RpZyAxIC8vIGlzVXNlckZpZWxkOiBib29sCglkdXAKCWJ6ICpza2lwX2FuZDE5CglmcmFtZV9kaWcgLTIgLy8gdmFsdWU6IGJ5dGVzCglsZW4KCWludGMgMCAvLyAwCgk9PQoJJiYKCipza2lwX2FuZDE5OgoJfHwKCipza2lwX29yMzoKCSYmCgoqc2tpcF9hbmQxODoKCWJ6ICppZjc2X2VuZAoKCS8vICppZjc2X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzNTUKCS8vIHJldHVybiB0cnVlCglpbnRjIDEgLy8gMQoJYiAqaXNGaWVsZFVwZGF0ZUFsbG93ZWQqcmV0dXJuCgoqaWY3Nl9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzU4CgkvLyBhc3NlcnQobGVuKHRoaXMuc2FmZUdsb2JhbEJ5dGVHZXQoTkZEX0tFWV9PV05FUikpID09PSAzMiwgJ211c3QgYmUgb3duZWQnKQoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldAoJbGVuCglpbnRjIDMgLy8gMzIKCT09CgoJLy8gbXVzdCBiZSBvd25lZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM1OQoJLy8gYXNzZXJ0KCF0aGlzLmlzRm9yU2FsZSgpLCAiY2FuJ3QgYmUgZm9yIHNhbGUiKQoJY2FsbHN1YiBpc0ZvclNhbGUKCSEKCgkvLyBjYW4ndCBiZSBmb3Igc2FsZQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM2MAoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gQWRkcmVzcy5mcm9tQnl0ZXModGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX09XTkVSKS52YWx1ZSksICdzZW5kZXIgbXVzdCBiZSBvd25lcicpCgl0eG4gU2VuZGVyCglieXRlYyAxIC8vICJpLm93bmVyLmEiCglhcHBfZ2xvYmFsX2dldAoJPT0KCgkvLyBzZW5kZXIgbXVzdCBiZSBvd25lcgoJYXNzZXJ0CgoJLy8gKmlmNzdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzYyCgkvLyBpc1VzZXJGaWVsZAoJZnJhbWVfZGlnIDEgLy8gaXNVc2VyRmllbGQ6IGJvb2wKCWJ6ICppZjc3X2VuZAoKCS8vICppZjc3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzNjMKCS8vIHJldHVybiB0cnVlCglpbnRjIDEgLy8gMQoJYiAqaXNGaWVsZFVwZGF0ZUFsbG93ZWQqcmV0dXJuCgoqaWY3N19lbmQ6CgkvLyAqaWY3OF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzNjYKCS8vIGxlbihuYW1lKSA+IDgKCWZyYW1lX2RpZyAtMSAvLyBuYW1lOiBieXRlcwoJbGVuCglpbnRjIDUgLy8gOAoJPgoJYnogKmlmNzhfZW5kCgoJLy8gKmlmNzhfY29uc2VxdWVudAoJLy8gKmlmNzlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzY3CgkvLyBleHRyYWN0MyhuYW1lLCAwLCA4KSA9PT0gJ3YuY2FBbGdvJwoJZnJhbWVfZGlnIC0xIC8vIG5hbWU6IGJ5dGVzCglleHRyYWN0IDAgOAoJYnl0ZWMgMzMgLy8gICJ2LmNhQWxnbyIKCT09CglieiAqaWY3OV9lbmQKCgkvLyAqaWY3OV9jb25zZXF1ZW50CgkvLyB1cGRhdGluZyB2LmNhQWxnbyBmaWVsZCBpc24ndCBhbGxvd2VkIHZpYSByZWd1bGFyIGZpZWxkIHVwZGF0ZQoJZXJyCgoqaWY3OV9lbmQ6CgoqaWY3OF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzcyCgkvLyByZXR1cm4gaXNWZXJpZmllZEZpZWxkICYmIGxlbih2YWx1ZSkgPT09IDAKCWZyYW1lX2RpZyAyIC8vIGlzVmVyaWZpZWRGaWVsZDogYm9vbAoJZHVwCglieiAqc2tpcF9hbmQyMAoJZnJhbWVfZGlnIC0yIC8vIHZhbHVlOiBieXRlcwoJbGVuCglpbnRjIDAgLy8gMAoJPT0KCSYmCgoqc2tpcF9hbmQyMDoKCippc0ZpZWxkVXBkYXRlQWxsb3dlZCpyZXR1cm46CgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAyCglyZXRzdWIKCi8vIGlzSW50ZXJuYWxGaWVsZCh0cnVzdFR5cGU6IHN0cmluZyk6IGJvb2xlYW4KaXNJbnRlcm5hbEZpZWxkOgoJcHJvdG8gMSAxCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM3NwoJLy8gcmV0dXJuIHRydXN0VHlwZSA9PT0gJ2kuJwoJZnJhbWVfZGlnIC0xIC8vIHRydXN0VHlwZTogc3RyaW5nCglwdXNoYnl0ZXMgMHg2OTJlIC8vICJpLiIKCT09CglyZXRzdWIKCi8vIGlzVXNlckZpZWxkKHRydXN0VHlwZTogc3RyaW5nKTogYm9vbGVhbgppc1VzZXJGaWVsZDoKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzODIKCS8vIHJldHVybiB0cnVzdFR5cGUgPT09ICd1LicKCWZyYW1lX2RpZyAtMSAvLyB0cnVzdFR5cGU6IHN0cmluZwoJcHVzaGJ5dGVzIDB4NzUyZSAvLyAidS4iCgk9PQoJcmV0c3ViCgovLyBpc1ZlcmlmaWVkRmllbGQodHJ1c3RUeXBlOiBzdHJpbmcpOiBib29sZWFuCmlzVmVyaWZpZWRGaWVsZDoKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzODcKCS8vIHJldHVybiB0cnVzdFR5cGUgPT09ICd2LicKCWZyYW1lX2RpZyAtMSAvLyB0cnVzdFR5cGU6IHN0cmluZwoJcHVzaGJ5dGVzIDB4NzYyZSAvLyAidi4iCgk9PQoJcmV0c3ViCgovLyBpc0ZvclNhbGUoKTogYm9vbGVhbgppc0ZvclNhbGU6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzkxCgkvLyByZXR1cm4gdGhpcy5zYWZlR2xvYmFsSW50R2V0KE5GRF9LRVlfU0VMTF9BTU9VTlQpICE9PSAwCglieXRlYyA2IC8vICJpLnNlbGxhbXQiCgljYWxsc3ViIHNhZmVHbG9iYWxJbnRHZXQKCWludGMgMCAvLyAwCgkhPQoJcmV0c3ViCgovLyBpc0V4cGlyZWQoKTogYm9vbGVhbgppc0V4cGlyZWQ6Cglwcm90byAwIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzOTYKCS8vIGV4cFRpbWUgPSB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9FWFBJUkFUSU9OVElNRSkKCWJ5dGVjIDE3IC8vICJpLmV4cGlyYXRpb25UaW1lIgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglmcmFtZV9idXJ5IDAgLy8gZXhwVGltZTogdWludDY0CgoJLy8gKmlmODBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzk3CgkvLyBleHBUaW1lID09PSAwCglmcmFtZV9kaWcgMCAvLyBleHBUaW1lOiB1aW50NjQKCWludGMgMCAvLyAwCgk9PQoJYnogKmlmODBfZW5kCgoJLy8gKmlmODBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM5OQoJLy8gcmV0dXJuIGZhbHNlCglpbnRjIDAgLy8gMAoJYiAqaXNFeHBpcmVkKnJldHVybgoKKmlmODBfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQwMQoJLy8gcmV0dXJuIGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wID4gZXhwVGltZQoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJZnJhbWVfZGlnIDAgLy8gZXhwVGltZTogdWludDY0Cgk+CgoqaXNFeHBpcmVkKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBpc1ZhdWx0QXV0b09wdEluTG9ja2VkKCk6IGJvb2xlYW4KaXNWYXVsdEF1dG9PcHRJbkxvY2tlZDoKCXByb3RvIDAgMQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0MTAKCS8vIHJldHVybiB0aGlzLnNhZmVHbG9iYWxCeXRlR2V0KE5GRF9LRVlfSVNWQVVMVE9QVElOTE9DS0VEKSA9PT0gJzEnCglieXRlYyAyMCAvLyAiaS52YXVsdE9wdEluTG9ja2VkIgoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldAoJYnl0ZWMgMTUgLy8gICIxIgoJPT0KCXJldHN1YgoKLy8gYXNzZXJ0T3duZXJDYWxsZWROb3RGb3JTYWxlT3JFeHBpcmVkKCk6IHZvaWQKYXNzZXJ0T3duZXJDYWxsZWROb3RGb3JTYWxlT3JFeHBpcmVkOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQxNAoJLy8gdGhpcy5tdXN0QmVDYWxsZWRCeU93bmVyKCkKCWNhbGxzdWIgbXVzdEJlQ2FsbGVkQnlPd25lcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0MTUKCS8vIHRoaXMubm90Rm9yU2FsZU9yRXhwaXJlZCgpCgljYWxsc3ViIG5vdEZvclNhbGVPckV4cGlyZWQKCXJldHN1YgoKLy8gbm90Rm9yU2FsZU9yRXhwaXJlZCgpOiB2b2lkCm5vdEZvclNhbGVPckV4cGlyZWQ6Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDE5CgkvLyBhc3NlcnQoIXRoaXMuaXNGb3JTYWxlKCksICJjYW4ndCBiZSBmb3Igc2FsZSIpCgljYWxsc3ViIGlzRm9yU2FsZQoJIQoKCS8vIGNhbid0IGJlIGZvciBzYWxlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDIwCgkvLyBhc3NlcnQoIXRoaXMuaXNFeHBpcmVkKCksICJjYW4ndCBiZSBleHBpcmVkIikKCWNhbGxzdWIgaXNFeHBpcmVkCgkhCgoJLy8gY2FuJ3QgYmUgZXhwaXJlZAoJYXNzZXJ0CglyZXRzdWIKCi8vIG5vUGVyaW9kQmVmb3JlSW5kZXgobmFtZTogc3RyaW5nLCBzdG9wSW5kZXg6IHVpbnQ2NCk6IGJvb2xlYW4Kbm9QZXJpb2RCZWZvcmVJbmRleDoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQyNQoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBzdG9wSW5kZXg7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDAgLy8gaTogdWludDY0CgoqZm9yXzk6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDI1CgkvLyBpIDwgc3RvcEluZGV4CglmcmFtZV9kaWcgMCAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBzdG9wSW5kZXg6IHVpbnQ2NAoJPAoJYnogKmZvcl85X2VuZAoKCS8vICppZjgxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQyNgoJLy8gZXh0cmFjdDMobmFtZSwgaSwgMSkgPT09ICcuJwoJZnJhbWVfZGlnIC0xIC8vIG5hbWU6IHN0cmluZwoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJZXh0cmFjdDMKCWJ5dGVjIDI4IC8vICAiLiIKCT09CglieiAqaWY4MV9lbmQKCgkvLyAqaWY4MV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDI3CgkvLyByZXR1cm4gZmFsc2UKCWludGMgMCAvLyAwCgliICpub1BlcmlvZEJlZm9yZUluZGV4KnJldHVybgoKKmlmODFfZW5kOgoKKmZvcl85X2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQyNQoJLy8gaSArPSAxCglmcmFtZV9kaWcgMCAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDAgLy8gaTogdWludDY0CgliICpmb3JfOQoKKmZvcl85X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0MzAKCS8vIHJldHVybiB0cnVlCglpbnRjIDEgLy8gMQoKKm5vUGVyaW9kQmVmb3JlSW5kZXgqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCglyZXRzdWIKCi8vIGNhbGNFeHBpcmF0aW9uKHJlbmV3YWxQcmljZTogdWludDY0LCBhbXRQYWlkOiB1aW50NjQsIGN1clRpbWU6IHVpbnQ2NCwgbWF4WWVhcnNBbGxvd2VkOiB1aW50NjQpOiB1aW50NjQKLy8KLy8gQ2FsY3VsYXRlcyB0aGUgbmV3IGV4cGlyYXRpb24gdGltZSBiYXNlZCBvbiB0aGUgcmVuZXdhbCBwcmljZSwgYW1vdW50IHBhaWQsIGN1cnJlbnQgdGltZSwgYW5kIG1heGltdW0geWVhcnMgYWxsb3dlZC4KLy8KLy8gQHBhcmFtIHJlbmV3YWxQcmljZSAtIFRoZSBwcmljZSBmb3IgcmVuZXdpbmcgdGhlIGV4cGlyYXRpb24uCi8vIEBwYXJhbSBhbXRQYWlkIC0gVGhlIGFtb3VudCBwYWlkIGZvciB0aGUgcmVuZXdhbC4KLy8gQHBhcmFtIGN1clRpbWUgLSBUaGUgY3VycmVudCB0aW1lIGluIHVuaXggdGltZSBzZWNvbmRzLgovLyBAcGFyYW0gbWF4WWVhcnNBbGxvd2VkIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHllYXJzIGFsbG93ZWQgZm9yIHRoZSBleHBpcmF0aW9uLgovLwovLyBAcmV0dXJuIFRoZSBuZXcgZXhwaXJhdGlvbiB0aW1lIGluIHVuaXh0aW1lIHNlY29uZHMKY2FsY0V4cGlyYXRpb246Cglwcm90byA0IDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ0NAoJLy8gZXh0cmFTZWNvbmRzID0gKDM2NSAqIGFtdFBhaWQgKiBTRUNTX0lOX0RBWSkgLyByZW5ld2FsUHJpY2UKCWludGMgOCAvLyAzNjUKCWZyYW1lX2RpZyAtMiAvLyBhbXRQYWlkOiB1aW50NjQKCSoKCWludGMgMTQgLy8gODY0MDAKCSoKCWZyYW1lX2RpZyAtMSAvLyByZW5ld2FsUHJpY2U6IHVpbnQ2NAoJLwoJZnJhbWVfYnVyeSAwIC8vIGV4dHJhU2Vjb25kczogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ0NQoJLy8gbmV3RXhwaXJhdGlvbiA9IGN1clRpbWUgKyBleHRyYVNlY29uZHMKCWZyYW1lX2RpZyAtMyAvLyBjdXJUaW1lOiB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIGV4dHJhU2Vjb25kczogdWludDY0CgkrCglmcmFtZV9idXJ5IDEgLy8gbmV3RXhwaXJhdGlvbjogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ0NwoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgbmV3RXhwaXJhdGlvbiA8PSBnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCArIDM2NSAqIG1heFllYXJzQWxsb3dlZCAqIFNFQ1NfSU5fREFZLAoJLy8gICAgICAgICAgICAgJ21heCBleHBpcmF0aW9uIGV4Y2VlZGVkIHBhcmFtZXRlcnMgZGVmaW5lZCBieSByZWdpc3RyeScsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyAxIC8vIG5ld0V4cGlyYXRpb246IHVpbnQ2NAoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJaW50YyA4IC8vIDM2NQoJZnJhbWVfZGlnIC00IC8vIG1heFllYXJzQWxsb3dlZDogdWludDY0CgkqCglpbnRjIDE0IC8vIDg2NDAwCgkqCgkrCgk8PQoKCS8vIG1heCBleHBpcmF0aW9uIGV4Y2VlZGVkIHBhcmFtZXRlcnMgZGVmaW5lZCBieSByZWdpc3RyeQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ1MQoJLy8gcmV0dXJuIG5ld0V4cGlyYXRpb24KCWZyYW1lX2RpZyAxIC8vIG5ld0V4cGlyYXRpb246IHVpbnQ2NAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gcG93MTAoZGVjaW1hbHM6IHVpbnQ2NCk6IHVpbnQ2NApwb3cxMDoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDU1CgkvLyBleHBSZXN1bHQgPSBleHB3KDEwLCBkZWNpbWFscykKCWludGMgMTEgLy8gMTAKCWZyYW1lX2RpZyAtMSAvLyBkZWNpbWFsczogdWludDY0CglleHB3CglmcmFtZV9idXJ5IDAgLy8gZXhwUmVzdWx0IGxvdzogdWludDY0CglmcmFtZV9idXJ5IDEgLy8gZXhwUmVzdWx0IGhpZ2g6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0NTYKCS8vIHJldHVybiBleHBSZXN1bHQubG93CglmcmFtZV9kaWcgMCAvLyBleHBSZXN1bHQgbG93OiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxCglyZXRzdWIKCi8vIGNsYXdBc2FGcm9tVG8oZnJvbTogQWRkcmVzcywgdG86IEFkZHJlc3MpOiB2b2lkCmNsYXdBc2FGcm9tVG86Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ2MgoJLy8gZnJvbUJhbGFuY2UgPSBmcm9tLmFzc2V0QmFsYW5jZShBc3NldElELmZyb21VaW50NjQoYnRvaSh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQVNBSUQpLnZhbHVlKSkpCglmcmFtZV9kaWcgLTEgLy8gZnJvbTogQWRkcmVzcwoJYnl0ZWMgMTggLy8gImkuYXNhaWQiCglhcHBfZ2xvYmFsX2dldAoJYnRvaQoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglwb3AKCWZyYW1lX2J1cnkgMCAvLyBmcm9tQmFsYW5jZTogdWludDY0CgoJLy8gKmlmODJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDY0CgkvLyBmcm9tQmFsYW5jZSAhPT0gMAoJZnJhbWVfZGlnIDAgLy8gZnJvbUJhbGFuY2U6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCSE9CglieiAqaWY4Ml9lbHNlCgoJLy8gKmlmODJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ2NQoJLy8gc2VuZEZyb20gPSBmcm9tCglmcmFtZV9kaWcgLTEgLy8gZnJvbTogQWRkcmVzcwoJZnJhbWVfYnVyeSAxIC8vIHNlbmRGcm9tOiBBZGRyZXNzCgliICppZjgyX2VuZAoKKmlmODJfZWxzZToKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0NjgKCS8vIHNlbmRGcm9tID0gdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWZyYW1lX2J1cnkgMSAvLyBzZW5kRnJvbTogQWRkcmVzcwoKKmlmODJfZW5kOgoJLy8gKmlmODNfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDcwCgkvLyBzZW5kRnJvbSA9PT0gdG8KCWZyYW1lX2RpZyAxIC8vIHNlbmRGcm9tOiBBZGRyZXNzCglmcmFtZV9kaWcgLTIgLy8gdG86IEFkZHJlc3MKCT09CglieiAqaWY4M19lbmQKCgkvLyAqaWY4M19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDcxCgkvLyByZXR1cm4KCXJldHN1YgoKKmlmODNfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ3MwoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgICAgICAgeGZlckFzc2V0OiBBc3NldElELmZyb21VaW50NjQoYnRvaSh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQVNBSUQpLnZhbHVlKSksCgkvLyAgICAgICAgICAgICBhc3NldEFtb3VudDogMSwKCS8vICAgICAgICAgICAgIHNlbmRlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgICAgICAgIGFzc2V0U2VuZGVyOiBzZW5kRnJvbSwKCS8vICAgICAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRvLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxMCAvLyAgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDc0CgkvLyB4ZmVyQXNzZXQ6IEFzc2V0SUQuZnJvbVVpbnQ2NChidG9pKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9BU0FJRCkudmFsdWUpKQoJYnl0ZWMgMTggLy8gImkuYXNhaWQiCglhcHBfZ2xvYmFsX2dldAoJYnRvaQoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDc1CgkvLyBhc3NldEFtb3VudDogMQoJaW50YyAxIC8vIDEKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDc2CgkvLyBzZW5kZXI6IHRoaXMuYXBwLmFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIFNlbmRlcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0NzcKCS8vIGFzc2V0U2VuZGVyOiBzZW5kRnJvbQoJZnJhbWVfZGlnIDEgLy8gc2VuZEZyb206IEFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRTZW5kZXIKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDc4CgkvLyBhc3NldFJlY2VpdmVyOiB0bwoJZnJhbWVfZGlnIC0yIC8vIHRvOiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglyZXRzdWIKCi8vIGZpbmRBZGRySW5CeXRlcyhieXRlc09mU2V0OiBieXRlcywgYWRkcmVzczogQWRkcmVzcyk6IGJvb2xlYW4KLy8KLy8gQ2hlY2tzIGlmIHRoZSBzcGVjaWZpZWQgYWRkcmVzcyBpcyBwcmVzZW50IHdpdGhpbiB0aGUgZ2l2ZW4gc2V0IG9mIGJ5dGVzLgovLwovLyBAcGFyYW0ge2J5dGVzfSBieXRlc09mU2V0IC0gVGhlIHNldCBvZiBieXRlcyB0byBzZWFyY2ggdGhyb3VnaC4KLy8gQHBhcmFtIHtBZGRyZXNzfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gZmluZCB3aXRoaW4gdGhlIHNldCBvZiBieXRlcy4KLy8gQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgZm91bmQgaW4gdGhlIGJ5dGVzLCBvdGhlcndpc2UgZmFsc2UuCmZpbmRBZGRySW5CeXRlczoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDkwCgkvLyBsaW1pdCA9IGJ5dGVzT2ZTZXQubGVuZ3RoIC8gMzIKCWZyYW1lX2RpZyAtMSAvLyBieXRlc09mU2V0OiBieXRlcwoJbGVuCglpbnRjIDMgLy8gMzIKCS8KCWZyYW1lX2J1cnkgMCAvLyBsaW1pdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ5MQoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBsaW1pdDsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCipmb3JfMTA6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDkxCgkvLyBpIDwgbGltaXQKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gbGltaXQ6IHVpbnQ2NAoJPAoJYnogKmZvcl8xMF9lbmQKCgkvLyAqaWY4NF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0OTIKCS8vIGV4dHJhY3QzKGJ5dGVzT2ZTZXQsIGkgKiAzMiwgMzIpID09PSByYXdCeXRlcyhhZGRyZXNzKQoJZnJhbWVfZGlnIC0xIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVzCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludGMgMyAvLyAzMgoJKgoJaW50YyAzIC8vIDMyCglleHRyYWN0MwoJZnJhbWVfZGlnIC0yIC8vIGFkZHJlc3M6IEFkZHJlc3MKCT09CglieiAqaWY4NF9lbmQKCgkvLyAqaWY4NF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDkzCgkvLyByZXR1cm4gdHJ1ZQoJaW50YyAxIC8vIDEKCWIgKmZpbmRBZGRySW5CeXRlcypyZXR1cm4KCippZjg0X2VuZDoKCipmb3JfMTBfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDkxCgkvLyBpICs9IDEKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCWIgKmZvcl8xMAoKKmZvcl8xMF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDk2CgkvLyByZXR1cm4gZmFsc2UKCWludGMgMCAvLyAwCgoqZmluZEFkZHJJbkJ5dGVzKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gZmluZEFkZHJBbmRTZXRGaXJzdChrZXk6IGJ5dGVzLCBhZGRyZXNzOiBBZGRyZXNzKTogdm9pZApmaW5kQWRkckFuZFNldEZpcnN0OgoJcHJvdG8gMiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gNAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MDEKCS8vIGJ5dGVzT2ZTZXQgPSB0aGlzLmJveGVzKGtleSkudmFsdWUKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKGtleSkudmFsdWUKCWFzc2VydAoJZnJhbWVfYnVyeSAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MDMKCS8vIGFzc2VydChhZGRyZXNzICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIC0yIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MDUKCS8vIGFzc2VydChieXRlc09mU2V0Lmxlbmd0aCA+PSA2NCwgImFkZHJlc3MgJ3NldCcgc2hvdWxkIGFscmVhZHkgaGF2ZSBhdCBsZWFzdCB0d28gdmFsdWVzIikKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJbGVuCglwdXNoaW50IDY0Cgk+PQoKCS8vIGFkZHJlc3MgJ3NldCcgc2hvdWxkIGFscmVhZHkgaGF2ZSBhdCBsZWFzdCB0d28gdmFsdWVzCglhc3NlcnQKCgkvLyAqaWY4NV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MDgKCS8vIGV4dHJhY3QzKGJ5dGVzT2ZTZXQsIDAsIDMyKSA9PT0gcmF3Qnl0ZXMoYWRkcmVzcykKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJZXh0cmFjdCAwIDMyCglmcmFtZV9kaWcgLTIgLy8gYWRkcmVzczogQWRkcmVzcwoJPT0KCWJ6ICppZjg1X2VuZAoKCS8vICppZjg1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MDkKCS8vIHJldHVybgoJcmV0c3ViCgoqaWY4NV9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTEyCgkvLyBsaW1pdCA9IGJ5dGVzT2ZTZXQubGVuZ3RoIC8gMzIKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJbGVuCglpbnRjIDMgLy8gMzIKCS8KCWZyYW1lX2J1cnkgMSAvLyBsaW1pdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTUxMwoJLy8gZm91bmRTbG90ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMiAvLyBmb3VuZFNsb3Q6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MTUKCS8vIGZvciAobGV0IGkgPSAxOyBpIDwgbGltaXQ7IGkgKz0gMSkKCWludGMgMSAvLyAxCglmcmFtZV9idXJ5IDMgLy8gaTogdWludDY0CgoqZm9yXzExOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTUxNQoJLy8gaSA8IGxpbWl0CglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGxpbWl0OiB1aW50NjQKCTwKCWJ6ICpmb3JfMTFfZW5kCgoJLy8gKmlmODZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTE2CgkvLyBleHRyYWN0MyhieXRlc09mU2V0LCBpICogMzIsIDMyKSA9PT0gcmF3Qnl0ZXMoYWRkcmVzcykKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJZnJhbWVfZGlnIDMgLy8gaTogdWludDY0CglpbnRjIDMgLy8gMzIKCSoKCWludGMgMyAvLyAzMgoJZXh0cmFjdDMKCWZyYW1lX2RpZyAtMiAvLyBhZGRyZXNzOiBBZGRyZXNzCgk9PQoJYnogKmlmODZfZW5kCgoJLy8gKmlmODZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTUxNwoJLy8gZm91bmRTbG90ID0gaQoJZnJhbWVfZGlnIDMgLy8gaTogdWludDY0CglmcmFtZV9idXJ5IDIgLy8gZm91bmRTbG90OiB1aW50NjQKCWIgKmZvcl8xMV9lbmQKCippZjg2X2VuZDoKCipmb3JfMTFfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTE1CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMyAvLyBpOiB1aW50NjQKCWIgKmZvcl8xMQoKKmZvcl8xMV9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTIxCgkvLyBhc3NlcnQoZm91bmRTbG90ICE9PSAwLCAnYWRkcmVzcyBtdXN0IGJlIGZvdW5kIGluIHNldCBpbiBvcmRlciB0byBtb3ZlIGl0JykKCWZyYW1lX2RpZyAyIC8vIGZvdW5kU2xvdDogdWludDY0CglpbnRjIDAgLy8gMAoJIT0KCgkvLyBhZGRyZXNzIG11c3QgYmUgZm91bmQgaW4gc2V0IGluIG9yZGVyIHRvIG1vdmUgaXQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MjMKCS8vIGFkZHJlc3NBdEZyb250ID0gZXh0cmFjdDMoYnl0ZXNPZlNldCwgMCwgMzIpCglmcmFtZV9kaWcgMCAvLyBieXRlc09mU2V0OiBieXRlW10KCWV4dHJhY3QgMCAzMgoJZnJhbWVfYnVyeSA0IC8vIGFkZHJlc3NBdEZyb250OiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTI1CgkvLyBieXRlc09mU2V0ID0gcmVwbGFjZTMoYnl0ZXNPZlNldCwgMCwgYWRkcmVzcykKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAtMiAvLyBhZGRyZXNzOiBBZGRyZXNzCglyZXBsYWNlMwoJZnJhbWVfYnVyeSAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MjcKCS8vIHRoaXMuYm94ZXMoa2V5KS52YWx1ZSA9IHJlcGxhY2UzKGJ5dGVzT2ZTZXQsIGZvdW5kU2xvdCAqIDMyLCBhZGRyZXNzQXRGcm9udCkKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglmcmFtZV9kaWcgMCAvLyBieXRlc09mU2V0OiBieXRlW10KCWZyYW1lX2RpZyAyIC8vIGZvdW5kU2xvdDogdWludDY0CglpbnRjIDMgLy8gMzIKCSoKCWZyYW1lX2RpZyA0IC8vIGFkZHJlc3NBdEZyb250OiBieXRlW10KCXJlcGxhY2UzCglib3hfcHV0CglyZXRzdWIKCi8vIGFkZEJ5dGVzVG9TZXQoa2V5OiBieXRlcywgYnl0ZXNWYWw6IGJ5dGVzKTogYm9vbGVhbgovLwovLyBBZGRzIGJ5dGVzIHRvIGEgc2V0IGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIGtleS4KLy8KLy8gQHBhcmFtIHtieXRlc30ga2V5IC0gVGhlIGtleSB0byBpZGVudGlmeSB0aGUgc2V0LgovLyBAcGFyYW0ge2J5dGVzfSBieXRlc1ZhbCAtIFRoZSBieXRlcyB0byBiZSBhZGRlZCB0byB0aGUgc2V0LgovLyBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBieXRlcyB3ZXJlIHN1Y2Nlc3NmdWxseSBhZGRlZCB0byB0aGUgc2V0LCBmYWxzZSBvdGhlcndpc2UuCmFkZEJ5dGVzVG9TZXQ6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiA1CgoJLy8gKmlmODdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTM4CgkvLyAhdGhpcy5ib3hlcyhrZXkpLmV4aXN0cwoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYnogKmlmODdfZW5kCgoJLy8gKmlmODdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0MAoJLy8gdGhpcy5ib3hlcyhrZXkpLnZhbHVlID0gYnl0ZXNWYWwKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglmcmFtZV9kaWcgLTIgLy8gYnl0ZXNWYWw6IGJ5dGVzCglib3hfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0MQoJLy8gcmV0dXJuIHRydWUKCWludGMgMSAvLyAxCgliICphZGRCeXRlc1RvU2V0KnJldHVybgoKKmlmODdfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0MwoJLy8gc2l6ZU9mS2V5ID0gbGVuKGJ5dGVzVmFsKQoJZnJhbWVfZGlnIC0yIC8vIGJ5dGVzVmFsOiBieXRlcwoJbGVuCglmcmFtZV9idXJ5IDAgLy8gc2l6ZU9mS2V5OiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTQ0CgkvLyB6ZXJvS2V5ID0gYnplcm8oc2l6ZU9mS2V5KQoJZnJhbWVfZGlnIDAgLy8gc2l6ZU9mS2V5OiB1aW50NjQKCWJ6ZXJvCglmcmFtZV9idXJ5IDEgLy8gemVyb0tleTogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0NQoJLy8gYnl0ZXNPZlNldCA9IHRoaXMuYm94ZXMoa2V5KS52YWx1ZQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoa2V5KS52YWx1ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDIgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0NgoJLy8gbGltaXQgPSBieXRlc09mU2V0Lmxlbmd0aCAvIHNpemVPZktleQoJZnJhbWVfZGlnIDIgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglsZW4KCWZyYW1lX2RpZyAwIC8vIHNpemVPZktleTogdWludDY0CgkvCglmcmFtZV9idXJ5IDMgLy8gbGltaXQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1NDgKCS8vIGFzc2VydChsZW4oYnl0ZXNWYWwpICUgc2l6ZU9mS2V5ID09PSAwLCAnZXhpc3Rpbmcgc2V0IG11c3QgYmUgbXVsdGlwbGUgb2Yga2V5IGJlaW5nIGFkZGVkJykKCWZyYW1lX2RpZyAtMiAvLyBieXRlc1ZhbDogYnl0ZXMKCWxlbgoJZnJhbWVfZGlnIDAgLy8gc2l6ZU9mS2V5OiB1aW50NjQKCSUKCWludGMgMCAvLyAwCgk9PQoKCS8vIGV4aXN0aW5nIHNldCBtdXN0IGJlIG11bHRpcGxlIG9mIGtleSBiZWluZyBhZGRlZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0OQoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBsaW1pdDsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNCAvLyBpOiB1aW50NjQKCipmb3JfMTI6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTQ5CgkvLyBpIDwgbGltaXQKCWZyYW1lX2RpZyA0IC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIDMgLy8gbGltaXQ6IHVpbnQ2NAoJPAoJYnogKmZvcl8xMl9lbmQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTUwCgkvLyBjdXJyZW50VmFsSW5TbG90ID0gZXh0cmFjdDMoYnl0ZXNPZlNldCwgaSAqIHNpemVPZktleSwgc2l6ZU9mS2V5KQoJZnJhbWVfZGlnIDIgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIHNpemVPZktleTogdWludDY0CgkqCglmcmFtZV9kaWcgMCAvLyBzaXplT2ZLZXk6IHVpbnQ2NAoJZXh0cmFjdDMKCWZyYW1lX2J1cnkgNSAvLyBjdXJyZW50VmFsSW5TbG90OiBieXRlW10KCgkvLyAqaWY4OF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1NTIKCS8vIGN1cnJlbnRWYWxJblNsb3QgPT09IHplcm9LZXkKCWZyYW1lX2RpZyA1IC8vIGN1cnJlbnRWYWxJblNsb3Q6IGJ5dGVbXQoJZnJhbWVfZGlnIDEgLy8gemVyb0tleTogYnl0ZVtdCgk9PQoJYnogKmlmODhfZW5kCgoJLy8gKmlmODhfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU1NAoJLy8gdGhpcy5ib3hlcyhrZXkpLnJlcGxhY2UoaSAqIHNpemVPZktleSwgYnl0ZXNWYWwpCglmcmFtZV9kaWcgLTEgLy8ga2V5OiBieXRlcwoJZnJhbWVfZGlnIDQgLy8gaTogdWludDY0CglmcmFtZV9kaWcgMCAvLyBzaXplT2ZLZXk6IHVpbnQ2NAoJKgoJZnJhbWVfZGlnIC0yIC8vIGJ5dGVzVmFsOiBieXRlcwoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTU1CgkvLyByZXR1cm4gdHJ1ZQoJaW50YyAxIC8vIDEKCWIgKmFkZEJ5dGVzVG9TZXQqcmV0dXJuCgoqaWY4OF9lbmQ6CgkvLyAqaWY4OV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1NTcKCS8vIGN1cnJlbnRWYWxJblNsb3QgPT09IGJ5dGVzVmFsCglmcmFtZV9kaWcgNSAvLyBjdXJyZW50VmFsSW5TbG90OiBieXRlW10KCWZyYW1lX2RpZyAtMiAvLyBieXRlc1ZhbDogYnl0ZXMKCT09CglieiAqaWY4OV9lbmQKCgkvLyAqaWY4OV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTU4CgkvLyByZXR1cm4gdHJ1ZQoJaW50YyAxIC8vIDEKCWIgKmFkZEJ5dGVzVG9TZXQqcmV0dXJuCgoqaWY4OV9lbmQ6CgoqZm9yXzEyX2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0OQoJLy8gaSArPSAxCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDQgLy8gaTogdWludDY0CgliICpmb3JfMTIKCipmb3JfMTJfZW5kOgoJLy8gKmlmOTBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTYyCgkvLyBieXRlc09mU2V0Lmxlbmd0aCA8IDEwMTAKCWZyYW1lX2RpZyAyIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJbGVuCglwdXNoaW50IDEwMTAKCTwKCWJ6ICppZjkwX2VuZAoKCS8vICppZjkwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1NjMKCS8vIHRoaXMuYm94ZXMoa2V5KS5kZWxldGUoKQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWJveF9kZWwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTY0CgkvLyB0aGlzLmJveGVzKGtleSkudmFsdWUgPSBjb25jYXQoYnl0ZXNPZlNldCwgYnl0ZXNWYWwpCglmcmFtZV9kaWcgLTEgLy8ga2V5OiBieXRlcwoJZnJhbWVfZGlnIDIgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglmcmFtZV9kaWcgLTIgLy8gYnl0ZXNWYWw6IGJ5dGVzCgljb25jYXQKCWJveF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTY1CgkvLyByZXR1cm4gdHJ1ZQoJaW50YyAxIC8vIDEKCWIgKmFkZEJ5dGVzVG9TZXQqcmV0dXJuCgoqaWY5MF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTY4CgkvLyByZXR1cm4gZmFsc2UKCWludGMgMCAvLyAwCgoqYWRkQnl0ZXNUb1NldCpyZXR1cm46CgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiA1CglyZXRzdWIKCi8vIHJlbW92ZUFkZHJGcm9tU2V0KGtleTogYnl0ZXMsIGFkZHJlc3M6IEFkZHJlc3MpOiBib29sZWFuCi8vCi8vIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBhZGRyZXNzIGZyb20gdGhlIHNldCBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBrZXkuCi8vCi8vIEBwYXJhbSB7Ynl0ZXN9IGtleSAtIFRoZSBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBzZXQuCi8vIEBwYXJhbSB7QWRkcmVzc30gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIHRvIHJlbW92ZSBmcm9tIHRoZSBzZXQuCi8vIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWRkcmVzcyB3YXMgc3VjY2Vzc2Z1bGx5IHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZS4KcmVtb3ZlQWRkckZyb21TZXQ6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiA1CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU3OQoJLy8gYnl0ZXNPZlNldCA9IHRoaXMuYm94ZXMoa2V5KS52YWx1ZQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoa2V5KS52YWx1ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDAgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU4MAoJLy8gbGltaXQgPSBieXRlc09mU2V0Lmxlbmd0aCAvIDMyCglmcmFtZV9kaWcgMCAvLyBieXRlc09mU2V0OiBieXRlW10KCWxlbgoJaW50YyAzIC8vIDMyCgkvCglmcmFtZV9idXJ5IDEgLy8gbGltaXQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1ODIKCS8vIGFzc2VydChhZGRyZXNzICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIC0yIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1ODQKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgbGltaXQ7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDIgLy8gaTogdWludDY0CgoqZm9yXzEzOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU4NAoJLy8gaSA8IGxpbWl0CglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGxpbWl0OiB1aW50NjQKCTwKCWJ6ICpmb3JfMTNfZW5kCgoJLy8gKmlmOTFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTg1CgkvLyBleHRyYWN0MyhieXRlc09mU2V0LCBpICogMzIsIDMyKSA9PT0gcmF3Qnl0ZXMoYWRkcmVzcykKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDMgLy8gMzIKCSoKCWludGMgMyAvLyAzMgoJZXh0cmFjdDMKCWZyYW1lX2RpZyAtMiAvLyBhZGRyZXNzOiBBZGRyZXNzCgk9PQoJYnogKmlmOTFfZW5kCgoJLy8gKmlmOTFfY29uc2VxdWVudAoJLy8gKmlmOTJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTg2CgkvLyBpID09PSBsaW1pdCAtIDEKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gbGltaXQ6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCS0KCT09CglieiAqaWY5Ml9lbmQKCgkvLyAqaWY5Ml9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTg3CgkvLyB0aGlzLmJveGVzKGtleSkuZGVsZXRlKCkKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglib3hfZGVsCgoJLy8gKmlmOTNfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTkwCgkvLyBpID4gMAoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDAgLy8gMAoJPgoJYnogKmlmOTNfZW5kCgoJLy8gKmlmOTNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU5MQoJLy8gdGhpcy5ib3hlcyhrZXkpLnZhbHVlID0gZXh0cmFjdDMoYnl0ZXNPZlNldCwgMCwgaSAqIDMyKQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDMyCgkqCglleHRyYWN0MwoJYm94X3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1OTMKCS8vIGFsbFplcm8gPSB0cnVlCglpbnRjIDEgLy8gMQoJZnJhbWVfYnVyeSAzIC8vIGFsbFplcm86IGJvb2wKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTk0CgkvLyB6ZXJvQWRkciA9IGdsb2JhbHMuemVyb0FkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJZnJhbWVfYnVyeSA0IC8vIHplcm9BZGRyOiBhZGRyZXNzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU5NQoJLy8gZm9yIChsZXQgaiA9IDA7IGogPCBsaW1pdCAtIDE7IGogKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDUgLy8gajogdWludDY0CgoqZm9yXzE0OgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU5NQoJLy8gaiA8IGxpbWl0IC0gMQoJZnJhbWVfZGlnIDUgLy8gajogdWludDY0CglmcmFtZV9kaWcgMSAvLyBsaW1pdDogdWludDY0CglpbnRjIDEgLy8gMQoJLQoJPAoJYnogKmZvcl8xNF9lbmQKCgkvLyAqaWY5NF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1OTYKCS8vIGV4dHJhY3QzKGJ5dGVzT2ZTZXQsIGogKiAzMiwgMzIpICE9PSByYXdCeXRlcyh6ZXJvQWRkcikKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJZnJhbWVfZGlnIDUgLy8gajogdWludDY0CglpbnRjIDMgLy8gMzIKCSoKCWludGMgMyAvLyAzMgoJZXh0cmFjdDMKCWZyYW1lX2RpZyA0IC8vIHplcm9BZGRyOiBhZGRyZXNzCgkhPQoJYnogKmlmOTRfZW5kCgoJLy8gKmlmOTRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU5NwoJLy8gYWxsWmVybyA9IGZhbHNlCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAzIC8vIGFsbFplcm86IGJvb2wKCWIgKmZvcl8xNF9lbmQKCippZjk0X2VuZDoKCipmb3JfMTRfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTk1CgkvLyBqICs9IDEKCWZyYW1lX2RpZyA1IC8vIGo6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgNSAvLyBqOiB1aW50NjQKCWIgKmZvcl8xNAoKKmZvcl8xNF9lbmQ6CgkvLyAqaWY5NV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE2MDEKCS8vIGFsbFplcm8KCWZyYW1lX2RpZyAzIC8vIGFsbFplcm86IGJvb2wKCWJ6ICppZjk1X2VuZAoKCS8vICppZjk1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE2MDIKCS8vIHRoaXMuYm94ZXMoa2V5KS5kZWxldGUoKQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWJveF9kZWwKCippZjk1X2VuZDoKCippZjkzX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE2MDUKCS8vIHJldHVybiB0cnVlCglpbnRjIDEgLy8gMQoJYiAqcmVtb3ZlQWRkckZyb21TZXQqcmV0dXJuCgoqaWY5Ml9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNjA4CgkvLyB0aGlzLmJveGVzKGtleSkucmVwbGFjZShpICogMzIsIHJhd0J5dGVzKGdsb2JhbHMuemVyb0FkZHJlc3MpKQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDMyCgkqCglnbG9iYWwgWmVyb0FkZHJlc3MKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTYwOQoJLy8gcmV0dXJuIHRydWUKCWludGMgMSAvLyAxCgliICpyZW1vdmVBZGRyRnJvbVNldCpyZXR1cm4KCippZjkxX2VuZDoKCipmb3JfMTNfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTg0CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCWIgKmZvcl8xMwoKKmZvcl8xM19lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNjEyCgkvLyByZXR1cm4gZmFsc2UKCWludGMgMCAvLyAwCgoqcmVtb3ZlQWRkckZyb21TZXQqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gNQoJcmV0c3ViCgovLyBtdXN0QmVDYWxsZWRCeU93bmVyKCk6IHZvaWQKbXVzdEJlQ2FsbGVkQnlPd25lcjoKCXByb3RvIDAgMAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE2MTcKCS8vIGFzc2VydChyYXdCeXRlcyh0aGlzLnR4bi5zZW5kZXIpID09PSB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlLCAnc2VuZGVyIG11c3QgYmUgb3duZXInKQoJdHhuIFNlbmRlcgoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXQKCT09CgoJLy8gc2VuZGVyIG11c3QgYmUgb3duZXIKCWFzc2VydAoJcmV0c3ViCgoqY3JlYXRlX05vT3A6CglwdXNoYnl0ZXMgMHgwZGNhNTJjMSAvLyBtZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKHN0cmluZyxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYWRkcmVzcyl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjcmVhdGUgTm9PcAoJZXJyCgoqY2FsbF9Ob09wOgoJcHVzaGJ5dGVzIDB4MzE3MmNhOWQgLy8gbWV0aG9kICJnYXMoKXZvaWQiCglwdXNoYnl0ZXMgMHgwNmRmMmU1YiAvLyBtZXRob2QgIm1pbnRBc2Eoc3RyaW5nLHN0cmluZyl2b2lkIgoJcHVzaGJ5dGVzIDB4NTEzMmRmNzUgLy8gbWV0aG9kICJkZWxldGVGaWVsZHMoYnl0ZVtdW10pdm9pZCIKCXB1c2hieXRlcyAweDBkMjZjNTkxIC8vIG1ldGhvZCAidXBkYXRlU2VnbWVudENvdW50KHN0cmluZyx1aW50NjQpdm9pZCIKCXB1c2hieXRlcyAweDdjNWFlNDk1IC8vIG1ldGhvZCAiZ2V0RmllbGRVcGRhdGVDb3N0KGJ5dGVbXVtdKXVpbnQ2NCIKCXB1c2hieXRlcyAweDc4ZjQyNzExIC8vIG1ldGhvZCAidXBkYXRlRmllbGRzKGJ5dGVbXVtdKXZvaWQiCglwdXNoYnl0ZXMgMHg2YzEzZWRlNCAvLyBtZXRob2QgInJlYWRGaWVsZChieXRlW10pYnl0ZVtdIgoJcHVzaGJ5dGVzIDB4NTA3NmQ5Y2EgLy8gbWV0aG9kICJvZmZlckZvclNhbGUodWludDY0LGFkZHJlc3Mpdm9pZCIKCXB1c2hieXRlcyAweDk5ZjVkNTBkIC8vIG1ldGhvZCAiY2FuY2VsU2FsZSgpdm9pZCIKCXB1c2hieXRlcyAweDkxMzExMmVmIC8vIG1ldGhvZCAicG9zdE9mZmVyKHVpbnQ2NCxzdHJpbmcpdm9pZCIKCXB1c2hieXRlcyAweGQ4NTMzN2M0IC8vIG1ldGhvZCAibWludFBheW91dCh1aW50NjQsdWludDY0KSh1aW50NjQsYWRkcmVzcyx1aW50NjQsYWRkcmVzcyx1aW50NjQpIgoJcHVzaGJ5dGVzIDB4YTM5MmFlODIgLy8gbWV0aG9kICJwdXJjaGFzZShwYXkpdm9pZCIKCXB1c2hieXRlcyAweGQ0NDM5NTJhIC8vIG1ldGhvZCAiaXNBZGRyZXNzSW5GaWVsZChzdHJpbmcsYWRkcmVzcylib29sIgoJcHVzaGJ5dGVzIDB4NTBmNDkwYzIgLy8gbWV0aG9kICJnZXRSZW5ld1ByaWNlKCl1aW50NjQiCglwdXNoYnl0ZXMgMHg3NjJlODJkYSAvLyBtZXRob2QgInVwZGF0ZUhhc2goYnl0ZVtdKXZvaWQiCglwdXNoYnl0ZXMgMHg4ZWJjMmM4MyAvLyBtZXRob2QgImNvbnRyYWN0TG9jayhib29sKXZvaWQiCglwdXNoYnl0ZXMgMHhjZDUzNThhNiAvLyBtZXRob2QgInNlZ21lbnRMb2NrKGJvb2wsdWludDY0KXZvaWQiCglwdXNoYnl0ZXMgMHgzYTY1N2Q3NyAvLyBtZXRob2QgInZhdWx0T3B0SW5Mb2NrKGJvb2wpdm9pZCIKCXB1c2hieXRlcyAweDQxM2QxNTIzIC8vIG1ldGhvZCAidmF1bHRPcHRJbih1aW50NjRbXSl2b2lkIgoJcHVzaGJ5dGVzIDB4NjY4MjFjMWEgLy8gbWV0aG9kICJ2YXVsdFNlbmQodWludDY0LGFkZHJlc3Msc3RyaW5nLHVpbnQ2NCx1aW50NjRbXSl2b2lkIgoJcHVzaGJ5dGVzIDB4NzdmZDViNzQgLy8gbWV0aG9kICJyZW5ldyhwYXkpdm9pZCIKCXB1c2hieXRlcyAweDk3YjZkODZjIC8vIG1ldGhvZCAic2V0UHJpbWFyeUFkZHJlc3Moc3RyaW5nLGFkZHJlc3Mpdm9pZCIKCXB1c2hieXRlcyAweDg1Y2NlZDU3IC8vIG1ldGhvZCAicmVnaXN0cnlBZGRpbmdWZXJpZmllZEFkZHJlc3Moc3RyaW5nLHN0cmluZylib29sIgoJcHVzaGJ5dGVzIDB4YjE4OTBhNzUgLy8gbWV0aG9kICJyZWdpc3RyeVJlbW92aW5nVmVyaWZpZWRBZGRyZXNzKHN0cmluZyxhZGRyZXNzLGFkZHJlc3MpYm9vbCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfZ2FzICphYmlfcm91dGVfbWludEFzYSAqYWJpX3JvdXRlX2RlbGV0ZUZpZWxkcyAqYWJpX3JvdXRlX3VwZGF0ZVNlZ21lbnRDb3VudCAqYWJpX3JvdXRlX2dldEZpZWxkVXBkYXRlQ29zdCAqYWJpX3JvdXRlX3VwZGF0ZUZpZWxkcyAqYWJpX3JvdXRlX3JlYWRGaWVsZCAqYWJpX3JvdXRlX29mZmVyRm9yU2FsZSAqYWJpX3JvdXRlX2NhbmNlbFNhbGUgKmFiaV9yb3V0ZV9wb3N0T2ZmZXIgKmFiaV9yb3V0ZV9taW50UGF5b3V0ICphYmlfcm91dGVfcHVyY2hhc2UgKmFiaV9yb3V0ZV9pc0FkZHJlc3NJbkZpZWxkICphYmlfcm91dGVfZ2V0UmVuZXdQcmljZSAqYWJpX3JvdXRlX3VwZGF0ZUhhc2ggKmFiaV9yb3V0ZV9jb250cmFjdExvY2sgKmFiaV9yb3V0ZV9zZWdtZW50TG9jayAqYWJpX3JvdXRlX3ZhdWx0T3B0SW5Mb2NrICphYmlfcm91dGVfdmF1bHRPcHRJbiAqYWJpX3JvdXRlX3ZhdWx0U2VuZCAqYWJpX3JvdXRlX3JlbmV3ICphYmlfcm91dGVfc2V0UHJpbWFyeUFkZHJlc3MgKmFiaV9yb3V0ZV9yZWdpc3RyeUFkZGluZ1ZlcmlmaWVkQWRkcmVzcyAqYWJpX3JvdXRlX3JlZ2lzdHJ5UmVtb3ZpbmdWZXJpZmllZEFkZHJlc3MKCgkvLyAhISEhIFdBUk5JTkc6IG5vbi1BQkkgcm91dGluZwoJY2FsbHN1YiBvbkNhbGwKCWludGMgMSAvLyAxCglyZXR1cm4KCipjYWxsX1VwZGF0ZUFwcGxpY2F0aW9uOgoJcHVzaGJ5dGVzIDB4MTc0NzQwNWIgLy8gbWV0aG9kICJ1cGRhdGVBcHBsaWNhdGlvbihzdHJpbmcpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfdXBkYXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBVcGRhdGVBcHBsaWNhdGlvbgoJZXJyCgoqaW50VG9Bc2NpaToKCXByb3RvIDEgMQoJcHVzaGJ5dGVzIDB4MzAzMTMyMzMzNDM1MzYzNzM4MzkgLy8gIjAxMjM0NTY3ODkiCglmcmFtZV9kaWcgLTEgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJZXh0cmFjdDMKCXJldHN1YgoJCgoqaXRvYToKCXByb3RvIDEgMQoJZnJhbWVfZGlnIC0xIC8vIGk6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT09CglieiAqaXRvYV9pZl9lbmQKCWJ5dGVjIDIzIC8vIDB4MzAKCXJldHN1YgoKKml0b2FfaWZfZW5kOgoJZnJhbWVfZGlnIC0xIC8vIGk6IHVpbnQ2NAoJaW50YyAxMSAvLyAxMAoJLwoJaW50YyAwIC8vIDAKCT4KCWJ6ICppdG9hX3Rlcm5hcnlfZmFsc2UKCWZyYW1lX2RpZyAtMSAvLyBpOiB1aW50NjQKCWludGMgMTEgLy8gMTAKCS8KCWNhbGxzdWIgKml0b2EKCWIgKml0b2FfdGVybmFyeV9lbmQKCippdG9hX3Rlcm5hcnlfZmFsc2U6CglieXRlYyAwIC8vICAiIgoKKml0b2FfdGVybmFyeV9lbmQ6CglmcmFtZV9kaWcgLTEgLy8gaTogdWludDY0CglpbnRjIDExIC8vIDEwCgklCgljYWxsc3ViICppbnRUb0FzY2lpCgljb25jYXQKCXJldHN1YgoKKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQ6Cglwcm90byA0IDMKCWZyYW1lX2RpZyAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTEgLy8gZWxlbWVudAoJY29uY2F0CglmcmFtZV9kaWcgLTMgLy8gdHVwbGUgdGFpbAoJZnJhbWVfZGlnIC0yIC8vIGhlYWQgb2Zmc2V0CglyZXRzdWIKCipwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudDoKCXByb3RvIDQgMwoJZnJhbWVfZGlnIC00IC8vIHR1cGxlIGhlYWQKCWZyYW1lX2RpZyAtMiAvLyBoZWFkIG9mZnNldAoJY29uY2F0CglmcmFtZV9idXJ5IC00IC8vIHR1cGxlIGhlYWQKCWZyYW1lX2RpZyAtMSAvLyBlbGVtZW50CglkdXAKCWxlbgoJZnJhbWVfZGlnIC0yIC8vIGhlYWQgb2Zmc2V0CglidG9pCgkrCglpdG9iCglleHRyYWN0IDYgMgoJZnJhbWVfYnVyeSAtMiAvLyBoZWFkIG9mZnNldAoJZnJhbWVfZGlnIC0zIC8vIHR1cGxlIHRhaWwKCXN3YXAKCWNvbmNhdAoJZnJhbWVfYnVyeSAtMyAvLyB0dXBsZSB0YWlsCglmcmFtZV9kaWcgLTQgLy8gdHVwbGUgaGVhZAoJZnJhbWVfZGlnIC0zIC8vIHR1cGxlIHRhaWwKCWZyYW1lX2RpZyAtMiAvLyBoZWFkIG9mZnNldAoJcmV0c3Vi", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw"}, "sourceInfo": {"approval": {"pcOffsetMethod": "cblocks", "sourceInfo": [{"pc": [36], "errorMessage": "The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?", "teal": 25}, {"pc": [44], "errorMessage": "argument 0 (segmentRootCommissionAddr) for createApplication must be a address", "teal": 37}, {"pc": [60], "errorMessage": "argument 3 (commission2Addr) for createApplication must be a address", "teal": 55}, {"pc": [72], "errorMessage": "argument 5 (commission1Addr) for createApplication must be a address", "teal": 69}, {"pc": [88], "errorMessage": "argument 8 (buyer) for createApplication must be a address", "teal": 87}, {"pc": [96], "errorMessage": "argument 9 (seller) for createApplication must be a address", "teal": 97}, {"pc": [117], "errorMessage": "caller must be NFD registry!", "teal": 122}, {"pc": [217], "errorMessage": "commission must be between 1 and 50%", "teal": 224}, {"pc": [251], "errorMessage": "commission must be between 1 and 50%", "teal": 262}, {"pc": [382], "errorMessage": "parent commission address must be set if parent app id is set and parent is unlocked", "teal": 370}, {"pc": [393], "errorMessage": "the segment commission agent should be the parent nfd's seller", "teal": 384}, {"pc": [420], "errorMessage": "contract must be unlocked to upgrade", "teal": 420}, {"pc": [426], "errorMessage": "caller must be NFD registry!", "teal": 429}, {"pc": [449], "errorMessage": "can't still be in minting state", "teal": 459}, {"pc": [467], "errorMessage": "NFD can't be expired for these v1/v2 operations", "teal": 481}, {"pc": [731], "errorMessage": "unknown method", "teal": 677}, {"pc": [768], "errorMessage": "caller must be NFD registry!", "teal": 721}, {"pc": [959], "errorMessage": "field not removable or no permissions to remove", "teal": 942}, {"pc": [963], "errorMessage": "box value does not exist: this.boxes(name).size", "teal": 950}, {"pc": [1067], "errorMessage": "field not removable or no permissions to remove", "teal": 1075}, {"pc": [1111], "errorMessage": "caller must be NFD registry!", "teal": 1130}, {"pc": [1121], "errorMessage": "child NFD MUST still be in pre-claim state!", "teal": 1144}, {"pc": [1144], "errorMessage": "passed in child name must match name in created nfd state", "teal": 1172}, {"pc": [1177], "errorMessage": "parent must be suffix of child", "teal": 1209}, {"pc": [1346], "errorMessage": "box value does not exist: this.boxes(name).size", "teal": 1381}, {"pc": [1386], "errorMessage": "box value does not exist: this.boxes(name).size", "teal": 1423}, {"pc": [1487], "errorMessage": "can't update fields if NFD expired", "teal": 1537}, {"pc": [1615], "errorMessage": "invalid update call by registry", "teal": 1644}, {"pc": [1717], "errorMessage": "field not updatable or no permissions to update", "teal": 1738}, {"pc": [1763], "errorMessage": "can't update fields if NFD expired", "teal": 1799}, {"pc": [1803], "errorMessage": "field not updatable or no permissions to update", "teal": 1844}, {"pc": [1902], "errorMessage": "must be user-defined or verified field to fetch", "teal": 1953}, {"pc": [1914], "errorMessage": "box value does not exist: this.boxes(fieldName).value", "teal": 1971}, {"pc": [1944], "errorMessage": "box value does not exist: this.boxes(boxName).value", "teal": 2005}, {"pc": [1994], "errorMessage": "box value does not exist: this.boxes(boxName).value", "teal": 2057}, {"pc": [2021], "errorMessage": "argument 0 (reservedFor) for offerForSale must be a address", "teal": 2093}, {"pc": [2039], "errorMessage": "can't sell if NFD expired", "teal": 2117}, {"pc": [2089], "errorMessage": "can only be sold if no user-defined or verified properties remain", "teal": 2165}, {"pc": [2106], "errorMessage": "must be sold for at least MIN amount", "teal": 2185}, {"pc": [2252], "errorMessage": "can't update fields if NFD expired", "teal": 2323}, {"pc": [2265], "errorMessage": "must be for sale", "teal": 2340}, {"pc": [2420], "errorMessage": "caller must be NFD registry!", "teal": 2484}, {"pc": [2652], "errorMessage": "argument 0 (payment) for purchase must be a pay transaction", "teal": 2751}, {"pc": [2677], "errorMessage": "can't be expired", "teal": 2782}, {"pc": [2681], "errorMessage": "must be for sale", "teal": 2789}, {"pc": [2733], "errorMessage": "payment sender must be same as purchase caller", "teal": 2830}, {"pc": [2749], "errorMessage": "Reserved owner set, but sender isn't the reserved address", "teal": 2853}, {"pc": [2795], "errorMessage": "offer must be at least min amount", "teal": 2900}, {"pc": [2801], "errorMessage": "offer must be at least sell amount", "teal": 2910}, {"pc": [2823], "errorMessage": "transaction verification failed: {\"txn\":\"payment\",\"field\":\"amount\",\"expected\":\"origOfferamt\"}", "teal": 2935}, {"pc": [2831], "errorMessage": "transaction verification failed: {\"txn\":\"payment\",\"field\":\"receiver\",\"expected\":\"this.app.address\"}", "teal": 2944}, {"pc": [3291], "errorMessage": "argument 0 (address) for isAddressInField must be a address", "teal": 3406}, {"pc": [3336], "errorMessage": "box value does not exist: this.boxes(fieldName).value", "teal": 3458}, {"pc": [3553], "errorMessage": "must pass 32-byte hash that isn't 0", "teal": 3711}, {"pc": [3567], "errorMessage": "only txnlab or owner can request an nfd nft hash update", "teal": 3729}, {"pc": [3603], "errorMessage": "argument 0 (lock) for contractLock must be a bool", "teal": 3782}, {"pc": [3649], "errorMessage": "argument 1 (lock) for segmentLock must be a bool", "teal": 3835}, {"pc": [3732], "errorMessage": "amount must be at least NFD_MIN_SEGMENT_USD dollars in algo", "teal": 3930}, {"pc": [3747], "errorMessage": "argument 0 (lock) for vaultOptInLock must be a bool", "teal": 3952}, {"pc": [3812], "errorMessage": "sender must be owner when vault locked", "teal": 4032}, {"pc": [3817], "errorMessage": "part of opt-in for new asset, must have prior txn paying MBR", "teal": 4042}, {"pc": [3830], "errorMessage": "transaction verification failed: {\"txn\":\"this.txnGroup[this.txn.groupIndex - 1]\",\"field\":\"typeEnum\",\"expected\":\"pay\"}", "teal": 4061}, {"pc": [3838], "errorMessage": "transaction verification failed: {\"txn\":\"this.txnGroup[this.txn.groupIndex - 1]\",\"field\":\"receiver\",\"expected\":\"this.app.address\"}", "teal": 4070}, {"pc": [3853], "errorMessage": "transaction verification failed: {\"txn\":\"this.txnGroup[this.txn.groupIndex - 1]\",\"field\":\"amount\",\"expected\":\"100_000 * assets.length\"}", "teal": 4084}, {"pc": [3954], "errorMessage": "argument 3 (receiver) for vaultSend must be a address", "teal": 4198}, {"pc": [3994], "errorMessage": "can't specify other assets if sending algo from vault", "teal": 4247}, {"pc": [4061], "errorMessage": "can only send one asset if amount == 0", "teal": 4329}, {"pc": [4128], "errorMessage": "receiver must be owner", "teal": 4402}, {"pc": [4246], "errorMessage": "argument 0 (payment) for renew must be a pay transaction", "teal": 4545}, {"pc": [4265], "errorMessage": "transaction verification failed: {\"txn\":\"payment\",\"field\":\"receiver\",\"expected\":\"this.app.address\"}", "teal": 4585}, {"pc": [4395], "errorMessage": "can't claim expired nfd unless all metadata is cleared", "teal": 4714}, {"pc": [4403], "errorMessage": "must pay at least minimum renewal price", "teal": 4727}, {"pc": [4559], "errorMessage": "global state value does not exist: parentAppId.globalState(NFD_KEY_OWNER)", "teal": 4900}, {"pc": [4725], "errorMessage": "argument 0 (address) for setPrimaryAddress must be a address", "teal": 5047}, {"pc": [4811], "errorMessage": "caller must be NFD registry!", "teal": 5134}, {"pc": [4829], "errorMessage": "field being verified MUST START with u.cav", "teal": 5148}, {"pc": [4838], "errorMessage": "destination field MUST START with v.ca[....]", "teal": 5158}, {"pc": [4853], "errorMessage": "destination field must end END with .as", "teal": 5173}, {"pc": [4859], "errorMessage": "referenced field to add as verified address must have value in box storage", "teal": 5186}, {"pc": [4868], "errorMessage": "box value does not exist: this.boxes(fieldBeingVerified).value", "teal": 5201}, {"pc": [4933], "errorMessage": "argument 0 (mbrRefundDest) for registryRemovingVerifiedAddress must be a address", "teal": 5261}, {"pc": [4941], "errorMessage": "argument 1 (address) for registryRemovingVerifiedAddress must be a address", "teal": 5271}, {"pc": [4971], "errorMessage": "caller must be NFD registry!", "teal": 5310}, {"pc": [4983], "errorMessage": "can't be for sale", "teal": 5326}, {"pc": [4992], "errorMessage": "verified field MUST START with v.ca[....]", "teal": 5337}, {"pc": [5007], "errorMessage": "verified field must end END with .as", "teal": 5355}, {"pc": [5016], "errorMessage": "box value does not exist: this.boxes(fieldBeingChanged).size", "teal": 5370}, {"pc": [5184], "errorMessage": "sender must be owner", "teal": 5550}, {"pc": [5189], "errorMessage": "part of opt-in for new asset, must have prior txn paying MBR", "teal": 5560}, {"pc": [5202], "errorMessage": "transaction verification failed: {\"txn\":\"this.txnGroup[this.txn.groupIndex - 1]\",\"field\":\"typeEnum\",\"expected\":\"pay\"}", "teal": 5579}, {"pc": [5210], "errorMessage": "transaction verification failed: {\"txn\":\"this.txnGroup[this.txn.groupIndex - 1]\",\"field\":\"receiver\",\"expected\":\"this.app.address\"}", "teal": 5588}, {"pc": [5223], "errorMessage": "transaction verification failed: {\"txn\":\"this.txnGroup[this.txn.groupIndex - 1]\",\"field\":\"amount\",\"expected\":\"100_000 * (this.txn.numAppArgs - 1)\"}", "teal": 5601}, {"pc": [5326], "errorMessage": "global state value does not exist: AppID.fromUint64(appId).globalState(key)", "teal": 5738}, {"pc": [5380], "errorMessage": "internal fields can never be deleted", "teal": 5804}, {"pc": [5397], "errorMessage": "must be owned", "teal": 5828}, {"pc": [5409], "errorMessage": "can't be for sale", "teal": 5844}, {"pc": [5466], "errorMessage": "internal fields can never be updated", "teal": 5906}, {"pc": [5521], "errorMessage": "must be owned", "teal": 5963}, {"pc": [5526], "errorMessage": "can't be for sale", "teal": 5971}, {"pc": [5532], "errorMessage": "sender must be owner", "teal": 5981}, {"pc": [5562], "errorMessage": "updating v.caAlgo field isn't allowed via regular field update", "teal": 6017}, {"pc": [5683], "errorMessage": "can't be for sale", "teal": 6162}, {"pc": [5688], "errorMessage": "can't be expired", "teal": 6170}, {"pc": [5773], "errorMessage": "max expiration exceeded parameters defined by registry", "teal": 6282}, {"pc": [5941], "errorMessage": "box value does not exist: this.boxes(key).value", "teal": 6515}, {"pc": [5956], "errorMessage": "address 'set' should already have at least two values", "teal": 6533}, {"pc": [6024], "errorMessage": "address must be found in set in order to move it", "teal": 6615}, {"pc": [6090], "errorMessage": "box value does not exist: this.boxes(key).value", "teal": 6698}, {"pc": [6109], "errorMessage": "existing set must be multiple of key being added", "teal": 6719}, {"pc": [6216], "errorMessage": "box value does not exist: this.boxes(key).value", "teal": 6855}, {"pc": [6385], "errorMessage": "sender must be owner", "teal": 7064}, {"pc": [6400], "errorMessage": "this contract does not implement the given ABI method for create NoOp", "teal": 7073}, {"pc": [6616], "errorMessage": "this contract does not implement the given ABI method for call UpdateApplication", "teal": 7114}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {"adminAsaId": {"type": "uint64"}, "registryAppId": {"type": "uint64"}}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True)
class PayoutInfo:
    """Struct for PayoutInfo"""
    amountToSeller: int
    commissionAddress: str
    amountToCommission: int
    segmentRootOwner: str
    amountToSegmentRoot: int


@dataclasses.dataclass(frozen=True, kw_only=True)
class MintAsaArgs:
    """Dataclass for mint_asa arguments"""
    nfdName: str
    url: str

    @property
    def abi_method_signature(self) -> str:
        return "mintAsa(string,string)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class DeleteFieldsArgs:
    """Dataclass for delete_fields arguments"""
    fieldNames: list[bytes | str]

    @property
    def abi_method_signature(self) -> str:
        return "deleteFields(byte[][])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class UpdateSegmentCountArgs:
    """Dataclass for update_segment_count arguments"""
    childNfdName: str
    childNfdAppID: int

    @property
    def abi_method_signature(self) -> str:
        return "updateSegmentCount(string,uint64)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetFieldUpdateCostArgs:
    """Dataclass for get_field_update_cost arguments"""
    fieldAndVals: list[bytes | str]

    @property
    def abi_method_signature(self) -> str:
        return "getFieldUpdateCost(byte[][])uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class UpdateFieldsArgs:
    """Dataclass for update_fields arguments"""
    fieldAndVals: list[bytes | str]

    @property
    def abi_method_signature(self) -> str:
        return "updateFields(byte[][])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class ReadFieldArgs:
    """Dataclass for read_field arguments"""
    fieldName: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "readField(byte[])byte[]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class OfferForSaleArgs:
    """Dataclass for offer_for_sale arguments"""
    sellAmount: int
    reservedFor: str

    @property
    def abi_method_signature(self) -> str:
        return "offerForSale(uint64,address)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class PostOfferArgs:
    """Dataclass for post_offer arguments"""
    offer: int
    note: str

    @property
    def abi_method_signature(self) -> str:
        return "postOffer(uint64,string)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class MintPayoutArgs:
    """Dataclass for mint_payout arguments"""
    oneYearPrice: int
    segmentPlatformCostInAlgo: int

    @property
    def abi_method_signature(self) -> str:
        return "mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class PurchaseArgs:
    """Dataclass for purchase arguments"""
    payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "purchase(pay)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class IsAddressInFieldArgs:
    """Dataclass for is_address_in_field arguments"""
    fieldName: str
    address: str

    @property
    def abi_method_signature(self) -> str:
        return "isAddressInField(string,address)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class UpdateHashArgs:
    """Dataclass for update_hash arguments"""
    hash: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "updateHash(byte[])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class ContractLockArgs:
    """Dataclass for contract_lock arguments"""
    lock: bool

    @property
    def abi_method_signature(self) -> str:
        return "contractLock(bool)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class SegmentLockArgs:
    """Dataclass for segment_lock arguments"""
    lock: bool
    usdPrice: int

    @property
    def abi_method_signature(self) -> str:
        return "segmentLock(bool,uint64)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class VaultOptInLockArgs:
    """Dataclass for vault_opt_in_lock arguments"""
    lock: bool

    @property
    def abi_method_signature(self) -> str:
        return "vaultOptInLock(bool)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class VaultOptInArgs:
    """Dataclass for vault_opt_in arguments"""
    assets: list[int]

    @property
    def abi_method_signature(self) -> str:
        return "vaultOptIn(uint64[])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class VaultSendArgs:
    """Dataclass for vault_send arguments"""
    amount: int
    receiver: str
    note: str
    asset: int
    otherAssets: list[int]

    @property
    def abi_method_signature(self) -> str:
        return "vaultSend(uint64,address,string,uint64,uint64[])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class RenewArgs:
    """Dataclass for renew arguments"""
    payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "renew(pay)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class SetPrimaryAddressArgs:
    """Dataclass for set_primary_address arguments"""
    fieldName: str
    address: str

    @property
    def abi_method_signature(self) -> str:
        return "setPrimaryAddress(string,address)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class RegistryAddingVerifiedAddressArgs:
    """Dataclass for registry_adding_verified_address arguments"""
    fieldBeingVerified: str
    fieldSetName: str

    @property
    def abi_method_signature(self) -> str:
        return "registryAddingVerifiedAddress(string,string)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class RegistryRemovingVerifiedAddressArgs:
    """Dataclass for registry_removing_verified_address arguments"""
    fieldBeingChanged: str
    address: str
    mbrRefundDest: str

    @property
    def abi_method_signature(self) -> str:
        return "registryRemovingVerifiedAddress(string,address,address)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateApplicationArgs:
    """Dataclass for create_application arguments"""
    nfdName: str
    seller: str
    buyer: str
    purchaseAmount: int
    expTime: int
    commission1Addr: str
    commission1Pct: int
    commission2Addr: str
    commission2Pct: int
    segmentRootAppId: int
    segmentRootCommissionAddr: str

    @property
    def abi_method_signature(self) -> str:
        return "createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class UpdateApplicationArgs:
    """Dataclass for update_application arguments"""
    versionNum: str

    @property
    def abi_method_signature(self) -> str:
        return "updateApplication(string)void"


class _NfdInstanceUpdate:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def update_application(
        self,
        args: tuple[str] | UpdateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppUpdateMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        compilation_params = compilation_params or algokit_utils.AppClientCompilationParams()
        return self.app_client.params.update(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "updateApplication(string)void",
            "args": method_args,
        }))


class NfdInstanceParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def update(self) -> "_NfdInstanceUpdate":
        return _NfdInstanceUpdate(self.app_client)

    def gas(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "gas()void",
        }))

    def mint_asa(
        self,
        args: tuple[str, str] | MintAsaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mintAsa(string,string)void",
            "args": method_args,
        }))

    def delete_fields(
        self,
        args: tuple[list[bytes | str]] | DeleteFieldsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "deleteFields(byte[][])void",
            "args": method_args,
        }))

    def update_segment_count(
        self,
        args: tuple[str, int] | UpdateSegmentCountArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "updateSegmentCount(string,uint64)void",
            "args": method_args,
        }))

    def get_field_update_cost(
        self,
        args: tuple[list[bytes | str]] | GetFieldUpdateCostArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "getFieldUpdateCost(byte[][])uint64",
            "args": method_args,
        }))

    def update_fields(
        self,
        args: tuple[list[bytes | str]] | UpdateFieldsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "updateFields(byte[][])void",
            "args": method_args,
        }))

    def read_field(
        self,
        args: tuple[bytes | str] | ReadFieldArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "readField(byte[])byte[]",
            "args": method_args,
        }))

    def offer_for_sale(
        self,
        args: tuple[int, str] | OfferForSaleArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "offerForSale(uint64,address)void",
            "args": method_args,
        }))

    def cancel_sale(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "cancelSale()void",
        }))

    def post_offer(
        self,
        args: tuple[int, str] | PostOfferArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "postOffer(uint64,string)void",
            "args": method_args,
        }))

    def mint_payout(
        self,
        args: tuple[int, int] | MintPayoutArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)",
            "args": method_args,
        }))

    def purchase(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | PurchaseArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "purchase(pay)void",
            "args": method_args,
        }))

    def is_address_in_field(
        self,
        args: tuple[str, str] | IsAddressInFieldArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "isAddressInField(string,address)bool",
            "args": method_args,
        }))

    def get_renew_price(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "getRenewPrice()uint64",
        }))

    def update_hash(
        self,
        args: tuple[bytes | str] | UpdateHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "updateHash(byte[])void",
            "args": method_args,
        }))

    def contract_lock(
        self,
        args: tuple[bool] | ContractLockArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "contractLock(bool)void",
            "args": method_args,
        }))

    def segment_lock(
        self,
        args: tuple[bool, int] | SegmentLockArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "segmentLock(bool,uint64)void",
            "args": method_args,
        }))

    def vault_opt_in_lock(
        self,
        args: tuple[bool] | VaultOptInLockArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vaultOptInLock(bool)void",
            "args": method_args,
        }))

    def vault_opt_in(
        self,
        args: tuple[list[int]] | VaultOptInArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vaultOptIn(uint64[])void",
            "args": method_args,
        }))

    def vault_send(
        self,
        args: tuple[int, str, str, int, list[int]] | VaultSendArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vaultSend(uint64,address,string,uint64,uint64[])void",
            "args": method_args,
        }))

    def renew(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | RenewArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "renew(pay)void",
            "args": method_args,
        }))

    def set_primary_address(
        self,
        args: tuple[str, str] | SetPrimaryAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "setPrimaryAddress(string,address)void",
            "args": method_args,
        }))

    def registry_adding_verified_address(
        self,
        args: tuple[str, str] | RegistryAddingVerifiedAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "registryAddingVerifiedAddress(string,string)bool",
            "args": method_args,
        }))

    def registry_removing_verified_address(
        self,
        args: tuple[str, str, str] | RegistryRemovingVerifiedAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "registryRemovingVerifiedAddress(string,address,address)bool",
            "args": method_args,
        }))

    def create_application(
        self,
        args: tuple[str, str, str, int, int, str, int, str, int, int, str] | CreateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class _NfdInstanceUpdateTransaction:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def update_application(
        self,
        args: tuple[str] | UpdateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        compilation_params = compilation_params or algokit_utils.AppClientCompilationParams()
        return self.app_client.create_transaction.update(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "updateApplication(string)void",
            "args": method_args,
        }))


class NfdInstanceCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def update(self) -> "_NfdInstanceUpdateTransaction":
        return _NfdInstanceUpdateTransaction(self.app_client)

    def gas(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "gas()void",
        }))

    def mint_asa(
        self,
        args: tuple[str, str] | MintAsaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mintAsa(string,string)void",
            "args": method_args,
        }))

    def delete_fields(
        self,
        args: tuple[list[bytes | str]] | DeleteFieldsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "deleteFields(byte[][])void",
            "args": method_args,
        }))

    def update_segment_count(
        self,
        args: tuple[str, int] | UpdateSegmentCountArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "updateSegmentCount(string,uint64)void",
            "args": method_args,
        }))

    def get_field_update_cost(
        self,
        args: tuple[list[bytes | str]] | GetFieldUpdateCostArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "getFieldUpdateCost(byte[][])uint64",
            "args": method_args,
        }))

    def update_fields(
        self,
        args: tuple[list[bytes | str]] | UpdateFieldsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "updateFields(byte[][])void",
            "args": method_args,
        }))

    def read_field(
        self,
        args: tuple[bytes | str] | ReadFieldArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "readField(byte[])byte[]",
            "args": method_args,
        }))

    def offer_for_sale(
        self,
        args: tuple[int, str] | OfferForSaleArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "offerForSale(uint64,address)void",
            "args": method_args,
        }))

    def cancel_sale(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "cancelSale()void",
        }))

    def post_offer(
        self,
        args: tuple[int, str] | PostOfferArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "postOffer(uint64,string)void",
            "args": method_args,
        }))

    def mint_payout(
        self,
        args: tuple[int, int] | MintPayoutArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)",
            "args": method_args,
        }))

    def purchase(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | PurchaseArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "purchase(pay)void",
            "args": method_args,
        }))

    def is_address_in_field(
        self,
        args: tuple[str, str] | IsAddressInFieldArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "isAddressInField(string,address)bool",
            "args": method_args,
        }))

    def get_renew_price(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "getRenewPrice()uint64",
        }))

    def update_hash(
        self,
        args: tuple[bytes | str] | UpdateHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "updateHash(byte[])void",
            "args": method_args,
        }))

    def contract_lock(
        self,
        args: tuple[bool] | ContractLockArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "contractLock(bool)void",
            "args": method_args,
        }))

    def segment_lock(
        self,
        args: tuple[bool, int] | SegmentLockArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "segmentLock(bool,uint64)void",
            "args": method_args,
        }))

    def vault_opt_in_lock(
        self,
        args: tuple[bool] | VaultOptInLockArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vaultOptInLock(bool)void",
            "args": method_args,
        }))

    def vault_opt_in(
        self,
        args: tuple[list[int]] | VaultOptInArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vaultOptIn(uint64[])void",
            "args": method_args,
        }))

    def vault_send(
        self,
        args: tuple[int, str, str, int, list[int]] | VaultSendArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vaultSend(uint64,address,string,uint64,uint64[])void",
            "args": method_args,
        }))

    def renew(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | RenewArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "renew(pay)void",
            "args": method_args,
        }))

    def set_primary_address(
        self,
        args: tuple[str, str] | SetPrimaryAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "setPrimaryAddress(string,address)void",
            "args": method_args,
        }))

    def registry_adding_verified_address(
        self,
        args: tuple[str, str] | RegistryAddingVerifiedAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "registryAddingVerifiedAddress(string,string)bool",
            "args": method_args,
        }))

    def registry_removing_verified_address(
        self,
        args: tuple[str, str, str] | RegistryRemovingVerifiedAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "registryRemovingVerifiedAddress(string,address,address)bool",
            "args": method_args,
        }))

    def create_application(
        self,
        args: tuple[str, str, str, int, int, str, int, str, int, int, str] | CreateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class _NfdInstanceUpdateSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def update_application(
        self,
        args: tuple[str] | UpdateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        compilation_params = compilation_params or algokit_utils.AppClientCompilationParams()
        response = self.app_client.send.update(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "updateApplication(string)void",
            "args": method_args,
        }), send_params=send_params, compilation_params=compilation_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppUpdateTransactionResult[None], parsed_response)


class NfdInstanceSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def update(self) -> "_NfdInstanceUpdateSend":
        return _NfdInstanceUpdateSend(self.app_client)

    def gas(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "gas()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def mint_asa(
        self,
        args: tuple[str, str] | MintAsaArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mintAsa(string,string)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def delete_fields(
        self,
        args: tuple[list[bytes | str]] | DeleteFieldsArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "deleteFields(byte[][])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def update_segment_count(
        self,
        args: tuple[str, int] | UpdateSegmentCountArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "updateSegmentCount(string,uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def get_field_update_cost(
        self,
        args: tuple[list[bytes | str]] | GetFieldUpdateCostArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "getFieldUpdateCost(byte[][])uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def update_fields(
        self,
        args: tuple[list[bytes | str]] | UpdateFieldsArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "updateFields(byte[][])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def read_field(
        self,
        args: tuple[bytes | str] | ReadFieldArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "readField(byte[])byte[]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def offer_for_sale(
        self,
        args: tuple[int, str] | OfferForSaleArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "offerForSale(uint64,address)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def cancel_sale(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "cancelSale()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def post_offer(
        self,
        args: tuple[int, str] | PostOfferArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "postOffer(uint64,string)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def mint_payout(
        self,
        args: tuple[int, int] | MintPayoutArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[PayoutInfo]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(PayoutInfo, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[PayoutInfo], parsed_response)

    def purchase(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | PurchaseArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "purchase(pay)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def is_address_in_field(
        self,
        args: tuple[str, str] | IsAddressInFieldArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "isAddressInField(string,address)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def get_renew_price(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "getRenewPrice()uint64",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def update_hash(
        self,
        args: tuple[bytes | str] | UpdateHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "updateHash(byte[])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def contract_lock(
        self,
        args: tuple[bool] | ContractLockArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "contractLock(bool)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def segment_lock(
        self,
        args: tuple[bool, int] | SegmentLockArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "segmentLock(bool,uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def vault_opt_in_lock(
        self,
        args: tuple[bool] | VaultOptInLockArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vaultOptInLock(bool)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def vault_opt_in(
        self,
        args: tuple[list[int]] | VaultOptInArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vaultOptIn(uint64[])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def vault_send(
        self,
        args: tuple[int, str, str, int, list[int]] | VaultSendArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vaultSend(uint64,address,string,uint64,uint64[])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def renew(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | RenewArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "renew(pay)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def set_primary_address(
        self,
        args: tuple[str, str] | SetPrimaryAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "setPrimaryAddress(string,address)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def registry_adding_verified_address(
        self,
        args: tuple[str, str] | RegistryAddingVerifiedAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "registryAddingVerifiedAddress(string,string)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def registry_removing_verified_address(
        self,
        args: tuple[str, str, str] | RegistryRemovingVerifiedAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "registryRemovingVerifiedAddress(string,address,address)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def create_application(
        self,
        args: tuple[str, str, str, int, int, str, int, str, int, int, str] | CreateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class NfdInstanceState:
    """Methods to access state for the current NFDInstance app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def global_state(self) -> "_MapState[bytes, bytes]":
        """Get values from the globalState map in global_state state"""
        return _MapState(
            self.app_client.state.global_state,
            "globalState",
            None
        )

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def boxes(self) -> "_MapState[bytes, bytes]":
        """Get values from the boxes map in box state"""
        return _MapState(
            self.app_client.state.box,
            "boxes",
            None
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class NfdInstanceClient:
    """Client for interacting with NFDInstance smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = NfdInstanceParams(self.app_client)
        self.create_transaction = NfdInstanceCreateTransactionParams(self.app_client)
        self.send = NfdInstanceSend(self.app_client)
        self.state = NfdInstanceState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "NfdInstanceClient":
        return NfdInstanceClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "NfdInstanceClient":
        return NfdInstanceClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "NfdInstanceClient":
        return NfdInstanceClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "NfdInstanceComposer":
        return NfdInstanceComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["gas()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["mintAsa(string,string)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["deleteFields(byte[][])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["updateSegmentCount(string,uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["getFieldUpdateCost(byte[][])uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["updateFields(byte[][])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["readField(byte[])byte[]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["offerForSale(uint64,address)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["cancelSale()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["postOffer(uint64,string)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> PayoutInfo | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["purchase(pay)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["isAddressInField(string,address)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["getRenewPrice()uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["updateHash(byte[])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["contractLock(bool)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["segmentLock(bool,uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["vaultOptInLock(bool)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["vaultOptIn(uint64[])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["vaultSend(uint64,address,string,uint64,uint64[])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["renew(pay)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["setPrimaryAddress(string,address)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["registryAddingVerifiedAddress(string,string)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["registryRemovingVerifiedAddress(string,address,address)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["updateApplication(string)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | PayoutInfo | bool | bytes | int:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class NfdInstanceMethodCallCreateParams(
    algokit_utils.AppClientCreateSchema, algokit_utils.BaseAppClientMethodCallParams[
        CreateApplicationArgs,
        str | None,
    ]
):
    """Parameters for creating NfdInstance contract using ABI"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None
    method: str | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallCreateParams:
        method_args = _parse_abi_args(self.args)
        return algokit_utils.AppClientMethodCallCreateParams(
            **{
                **self.__dict__,
                "method": self.method or getattr(self.args, "abi_method_signature", None),
                "args": method_args,
            }
        )

@dataclasses.dataclass(frozen=True)
class NfdInstanceMethodCallUpdateParams(
    algokit_utils.BaseAppClientMethodCallParams[
        UpdateApplicationArgs,
        str | None,
    ]
):
    """Parameters for calling NfdInstance contract using ABI"""
    on_complete: typing.Literal[OnComplete.UpdateApplicationOC] | None = None
    method: str | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallParams:
        method_args = _parse_abi_args(self.args)
        return algokit_utils.AppClientMethodCallParams(
            **{
                **self.__dict__,
                "method": self.method or getattr(self.args, "abi_method_signature", None),
                "args": method_args,
            }
        )

class NfdInstanceFactory(algokit_utils.TypedAppFactoryProtocol[NfdInstanceMethodCallCreateParams, NfdInstanceMethodCallUpdateParams, None]):
    """Factory for deploying and managing NfdInstanceClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = NfdInstanceFactoryParams(self.app_factory)
        self.create_transaction = NfdInstanceFactoryCreateTransaction(self.app_factory)
        self.send = NfdInstanceFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: NfdInstanceMethodCallCreateParams | None = None,
        update_params: NfdInstanceMethodCallUpdateParams | None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[NfdInstanceClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params.to_algokit_utils_params() if update_params else None,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return NfdInstanceClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> NfdInstanceClient:
        """Get an app client by creator address and name"""
        return NfdInstanceClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> NfdInstanceClient:
        """Get an app client by app ID"""
        return NfdInstanceClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class NfdInstanceFactoryParams:
    """Parameters for creating transactions for NfdInstance contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = NfdInstanceFactoryCreateParams(app_factory)
        self.update = NfdInstanceFactoryUpdateParams(app_factory)
        self.delete = NfdInstanceFactoryDeleteParams(app_factory)

class NfdInstanceFactoryCreateParams:
    """Parameters for 'create' operations of NfdInstance contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def gas(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the gas()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "gas()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def mint_asa(
        self,
        args: tuple[str, str] | MintAsaArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the mintAsa(string,string)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "mintAsa(string,string)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def delete_fields(
        self,
        args: tuple[list[bytes | str]] | DeleteFieldsArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the deleteFields(byte[][])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "deleteFields(byte[][])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def update_segment_count(
        self,
        args: tuple[str, int] | UpdateSegmentCountArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the updateSegmentCount(string,uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "updateSegmentCount(string,uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_field_update_cost(
        self,
        args: tuple[list[bytes | str]] | GetFieldUpdateCostArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the getFieldUpdateCost(byte[][])uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "getFieldUpdateCost(byte[][])uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def update_fields(
        self,
        args: tuple[list[bytes | str]] | UpdateFieldsArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the updateFields(byte[][])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "updateFields(byte[][])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def read_field(
        self,
        args: tuple[bytes | str] | ReadFieldArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the readField(byte[])byte[] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "readField(byte[])byte[]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def offer_for_sale(
        self,
        args: tuple[int, str] | OfferForSaleArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the offerForSale(uint64,address)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "offerForSale(uint64,address)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def cancel_sale(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the cancelSale()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "cancelSale()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def post_offer(
        self,
        args: tuple[int, str] | PostOfferArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the postOffer(uint64,string)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "postOffer(uint64,string)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def mint_payout(
        self,
        args: tuple[int, int] | MintPayoutArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def purchase(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | PurchaseArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the purchase(pay)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "purchase(pay)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def is_address_in_field(
        self,
        args: tuple[str, str] | IsAddressInFieldArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the isAddressInField(string,address)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "isAddressInField(string,address)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_renew_price(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the getRenewPrice()uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "getRenewPrice()uint64",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def update_hash(
        self,
        args: tuple[bytes | str] | UpdateHashArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the updateHash(byte[])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "updateHash(byte[])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def contract_lock(
        self,
        args: tuple[bool] | ContractLockArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the contractLock(bool)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "contractLock(bool)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def segment_lock(
        self,
        args: tuple[bool, int] | SegmentLockArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the segmentLock(bool,uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "segmentLock(bool,uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def vault_opt_in_lock(
        self,
        args: tuple[bool] | VaultOptInLockArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the vaultOptInLock(bool)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "vaultOptInLock(bool)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def vault_opt_in(
        self,
        args: tuple[list[int]] | VaultOptInArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the vaultOptIn(uint64[])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "vaultOptIn(uint64[])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def vault_send(
        self,
        args: tuple[int, str, str, int, list[int]] | VaultSendArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the vaultSend(uint64,address,string,uint64,uint64[])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "vaultSend(uint64,address,string,uint64,uint64[])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def renew(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | RenewArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the renew(pay)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "renew(pay)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def set_primary_address(
        self,
        args: tuple[str, str] | SetPrimaryAddressArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the setPrimaryAddress(string,address)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "setPrimaryAddress(string,address)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def registry_adding_verified_address(
        self,
        args: tuple[str, str] | RegistryAddingVerifiedAddressArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the registryAddingVerifiedAddress(string,string)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "registryAddingVerifiedAddress(string,string)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def registry_removing_verified_address(
        self,
        args: tuple[str, str, str] | RegistryRemovingVerifiedAddressArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the registryRemovingVerifiedAddress(string,address,address)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "registryRemovingVerifiedAddress(string,address,address)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def create_application(
        self,
        args: tuple[str, str, str, int, int, str, int, str, int, int, str] | CreateApplicationArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def update_application(
        self,
        args: tuple[str] | UpdateApplicationArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the updateApplication(string)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "updateApplication(string)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

class NfdInstanceFactoryUpdateParams:
    """Parameters for 'update' operations of NfdInstance contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class NfdInstanceFactoryDeleteParams:
    """Parameters for 'delete' operations of NfdInstance contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class NfdInstanceFactoryCreateTransaction:
    """Create transactions for NfdInstance contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = NfdInstanceFactoryCreateTransactionCreate(app_factory)


class NfdInstanceFactoryCreateTransactionCreate:
    """Create new instances of NfdInstance contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class NfdInstanceFactorySend:
    """Send calls to NfdInstance contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = NfdInstanceFactorySendCreate(app_factory)


class NfdInstanceFactorySendCreate:
    """Send create calls to NfdInstance contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[NfdInstanceClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return NfdInstanceClient(result[0]), result[1]

    def create_application(
        self,
        args: tuple[str, str, str, int, int, str, int, str, int, int, str] | CreateApplicationArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> tuple[NfdInstanceClient, algokit_utils.AppFactoryCreateMethodCallResult[None]]:
            """Creates and sends a transaction using the createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void ABI method"""
            params = params or algokit_utils.CommonAppCallCreateParams()
            client, result = self.app_factory.send.create(
                algokit_utils.AppFactoryCreateMethodCallParams(
                    **{
                    **dataclasses.asdict(params),
                    "method": "createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void",
                    "args": _parse_abi_args(args),
                    }
                ),
                send_params=send_params,
                compilation_params=compilation_params
            )
            return_value = None if result.abi_return is None else typing.cast(None, result.abi_return)
    
            return NfdInstanceClient(client), algokit_utils.AppFactoryCreateMethodCallResult[None](
                **{
                    **result.__dict__,
                    "app_id": result.app_id,
                    "abi_return": return_value,
                    "transaction": result.transaction,
                    "confirmation": result.confirmation,
                    "group_id": result.group_id,
                    "tx_ids": result.tx_ids,
                    "transactions": result.transactions,
                    "confirmations": result.confirmations,
                    "app_address": result.app_address,
                }
            )


class _NfdInstanceUpdateComposer:
    def __init__(self, composer: "NfdInstanceComposer"):
        self.composer = composer
    def update_application(
        self,
        args: tuple[str] | UpdateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self.composer._composer.add_app_update_method_call(
            self.composer.client.params.update.update_application(
                args=args,
                params=params,
                compilation_params=compilation_params
            )
        )
        self.composer._result_mappers.append(
            lambda v: self.composer.client.decode_return_value(
                "updateApplication(string)void", v
            )
        )
        return self.composer


class NfdInstanceComposer:
    """Composer for creating transaction groups for NfdInstance contract calls"""

    def __init__(self, client: "NfdInstanceClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    @property
    def update(self) -> "_NfdInstanceUpdateComposer":
        return _NfdInstanceUpdateComposer(self)

    def gas(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.gas(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "gas()void", v
            )
        )
        return self

    def mint_asa(
        self,
        args: tuple[str, str] | MintAsaArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.mint_asa(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "mintAsa(string,string)void", v
            )
        )
        return self

    def delete_fields(
        self,
        args: tuple[list[bytes | str]] | DeleteFieldsArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.delete_fields(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "deleteFields(byte[][])void", v
            )
        )
        return self

    def update_segment_count(
        self,
        args: tuple[str, int] | UpdateSegmentCountArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.update_segment_count(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "updateSegmentCount(string,uint64)void", v
            )
        )
        return self

    def get_field_update_cost(
        self,
        args: tuple[list[bytes | str]] | GetFieldUpdateCostArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_field_update_cost(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "getFieldUpdateCost(byte[][])uint64", v
            )
        )
        return self

    def update_fields(
        self,
        args: tuple[list[bytes | str]] | UpdateFieldsArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.update_fields(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "updateFields(byte[][])void", v
            )
        )
        return self

    def read_field(
        self,
        args: tuple[bytes | str] | ReadFieldArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.read_field(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "readField(byte[])byte[]", v
            )
        )
        return self

    def offer_for_sale(
        self,
        args: tuple[int, str] | OfferForSaleArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.offer_for_sale(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "offerForSale(uint64,address)void", v
            )
        )
        return self

    def cancel_sale(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.cancel_sale(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "cancelSale()void", v
            )
        )
        return self

    def post_offer(
        self,
        args: tuple[int, str] | PostOfferArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.post_offer(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "postOffer(uint64,string)void", v
            )
        )
        return self

    def mint_payout(
        self,
        args: tuple[int, int] | MintPayoutArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.mint_payout(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)", v
            )
        )
        return self

    def purchase(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | PurchaseArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.purchase(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "purchase(pay)void", v
            )
        )
        return self

    def is_address_in_field(
        self,
        args: tuple[str, str] | IsAddressInFieldArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.is_address_in_field(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "isAddressInField(string,address)bool", v
            )
        )
        return self

    def get_renew_price(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_renew_price(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "getRenewPrice()uint64", v
            )
        )
        return self

    def update_hash(
        self,
        args: tuple[bytes | str] | UpdateHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.update_hash(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "updateHash(byte[])void", v
            )
        )
        return self

    def contract_lock(
        self,
        args: tuple[bool] | ContractLockArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.contract_lock(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "contractLock(bool)void", v
            )
        )
        return self

    def segment_lock(
        self,
        args: tuple[bool, int] | SegmentLockArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.segment_lock(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "segmentLock(bool,uint64)void", v
            )
        )
        return self

    def vault_opt_in_lock(
        self,
        args: tuple[bool] | VaultOptInLockArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.vault_opt_in_lock(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "vaultOptInLock(bool)void", v
            )
        )
        return self

    def vault_opt_in(
        self,
        args: tuple[list[int]] | VaultOptInArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.vault_opt_in(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "vaultOptIn(uint64[])void", v
            )
        )
        return self

    def vault_send(
        self,
        args: tuple[int, str, str, int, list[int]] | VaultSendArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.vault_send(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "vaultSend(uint64,address,string,uint64,uint64[])void", v
            )
        )
        return self

    def renew(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | RenewArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.renew(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "renew(pay)void", v
            )
        )
        return self

    def set_primary_address(
        self,
        args: tuple[str, str] | SetPrimaryAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.set_primary_address(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "setPrimaryAddress(string,address)void", v
            )
        )
        return self

    def registry_adding_verified_address(
        self,
        args: tuple[str, str] | RegistryAddingVerifiedAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.registry_adding_verified_address(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "registryAddingVerifiedAddress(string,string)bool", v
            )
        )
        return self

    def registry_removing_verified_address(
        self,
        args: tuple[str, str, str] | RegistryRemovingVerifiedAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.registry_removing_verified_address(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "registryRemovingVerifiedAddress(string,address,address)bool", v
            )
        )
        return self

    def create_application(
        self,
        args: tuple[str, str, str, int, int, str, int, str, int, int, str] | CreateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_app_call_method_call(
            self.client.params.create_application(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "NfdInstanceComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "NfdInstanceComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
